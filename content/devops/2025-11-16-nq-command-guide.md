---
title: 'nq: 가볍고 단순한 커맨드 라인 잡 큐(Job Queue) 시스템'
tags:
  - nq
  - cli
  - job-queue
  - linux
---
리눅스나 macOS 환경에서 무거운 백그라운드 데몬 없이 간단하게 명령어 실행을 순차적으로 처리하고 싶을 때가 있습니다. `at`이나 `batch` 같은 전통적인 유틸리티도 훌륭하지만, 파일 시스템을 기반으로 더 직관적이고 가볍게 동작하는 `nq`는 훌륭한 대안이 될 수 있습니다.

이 글에서는 `nq`의 기본 개념과 설치 방법, 그리고 실제 사용 사례를 통해 어떻게 명령어 큐를 관리하고 실행하는지 자세히 알아보겠습니다.

## `nq`란 무엇인가?

`nq`는 'the nice queue'를 의미하는 것으로 보이며, 파일 시스템 기반의 간단한 커맨드 라인 큐 유틸리티입니다. 별도의 데몬 프로세스 없이, `nq` 명령어 자체가 백그라운드에서 순차적으로 작업을 처리합니다. 선행 작업이 끝나야 다음 작업이 시작되는 것을 보장해주므로, 여러 빌드 명령어나 다운로드 작업을 순서대로 실행할 때 매우 유용합니다.

주요 명령어는 다음과 같습니다.

- **`nq`**: 실행하고 싶은 명령어를 큐(Queue)에 추가하고, 백그라운드에서 실행을 시작합니다.
- **`nqtail`**: 큐에서 실행 중이거나 완료된 작업의 로그(표준 출력/에러)를 확인합니다.

## 설치 방법

`nq`는 C로 작성된 간단한 프로그램이므로, 소스 코드를 직접 컴파일하여 설치합니다.

1.  먼저 Git을 사용해 소스 코드를 클론합니다.
    ```bash
    git clone https://github.com/leahneukirchen/nq.git
    cd nq
    ```

2.  `make` 명령어로 컴파일하고, `make install`로 시스템에 설치합니다. `sudo` 권한이 필요할 수 있습니다.
    ```bash
    make
    sudo make install
    ```
    기본적으로 `/usr/local/bin`에 `nq`와 `nqtail`이 설치됩니다.

## `nq` 기본 사용법

### 명령어(잡) 큐에 추가하고 실행하기

`nq` 사용법은 매우 간단합니다. 그냥 실행하고 싶은 명령어 앞에 `nq`를 붙여주기만 하면 됩니다.

```bash
# Makefile 타겟을 순차적으로 실행
nq make clean
nq make depends
nq make all
```

이렇게 하면 `nq`는 `make clean`을 백그라운드에서 실행하고, 이 작업이 끝나면 `make depends`를, 그 다음 `make all`을 순차적으로 실행합니다. 각 명령어는 즉시 큐에 추가되고, `nq`는 이전 작업이 끝날 때까지 다음 작업을 기다렸다가 실행합니다.

### 작업 로그 확인하기 (`nqtail`)

백그라운드에서 실행되는 작업의 출력은 `nqtail` 명령어로 확인할 수 있습니다.

```bash
# 현재 실행 중인 작업의 로그를 실시간으로 출력
nqtail

# 모든 작업의 로그를 한 번에 출력
nqtail -a

# 작업당 한 줄로 요약해서 보여주기
nqtail -q
```

### 모든 작업이 끝나기를 기다리기 (`nq -w`)

스크립트 등에서 `nq`로 추가한 모든 작업이 완료될 때까지 기다려야 할 때가 있습니다. 이때는 `-w` 옵션을 사용합니다.

```bash
echo "Starting downloads..."
nq wget https://example.com/file1.zip
nq wget https://example.com/file2.zip

# 위의 두 다운로드가 모두 끝날 때까지 대기
nq -w

echo "All downloads finished."
```

## 큐 관리 및 분리

### 주요 명령어 및 옵션

`nq`와 `nqtail`은 간단하지만 강력한 옵션들을 제공합니다.

#### `nq` 옵션

-   `nq [command]`
    -   **-q**: 작업을 큐에 추가할 때 기본적으로 출력되는 작업 ID를 숨깁니다. 스크립트에서 출력을 깔끔하게 유지하고 싶을 때 유용합니다.
        ```bash
        nq -q sleep 5
        ```
    -   **-w [job_id...]**: 모든 작업 또는 지정된 작업 ID들이 완료될 때까지 기다립니다. 스크립트 내에서 동기적으로 작업을 처리해야 할 때 필수적입니다.
        ```bash
        # 모든 작업이 끝날 때까지 대기
        nq -w
        # 특정 작업들(예: 1, 3)이 끝날 때까지 대기
        nq -w 1 3
        ```
    -   **-t**: 큐에 처리 대기 중인 작업이 있는지 확인합니다. 작업이 남아있으면 종료 코드 0을, 큐가 비어있으면 0이 아닌 값을 반환합니다.
        ```bash
        if nq -t; then
          echo "아직 처리할 작업이 남았습니다."
        fi
        ```

#### `nqtail` 옵션

-   `nqtail`
    -   **-a**: 큐에 있는 모든 작업의 전체 로그를 출력합니다.
    -   **-q**: 각 작업을 한 줄로 요약하여 간략하게 상태를 보여줍니다.

`nq`의 강력한 기능 중 하나는 여러 개의 큐를 손쉽게 분리하여 관리할 수 있다는 점입니다.

### 큐 구분 방법 (`NQDIR` 환경 변수)

`nq`는 `NQDIR` 환경 변수를 통해 작업 큐가 저장될 디렉토리를 결정합니다. 이 변수를 설정하지 않으면 **현재 디렉토리**를 큐로 사용합니다.

예를 들어, 일반 작업과 다운로드 작업을 별도의 큐로 관리하고 싶다고 가정해 봅시다.

1.  **일반 작업 (현재 디렉토리 큐)**
    ```bash
    nq echo "This is a default task."
    ```

2.  **다운로드 전용 큐 (`/tmp/downloads`)**
    `NQDIR` 환경 변수를 설정하여 `nq`와 `nqtail`이 다른 디렉토리를 사용하도록 지정합니다.
    ```bash
    # NQDIR을 설정하여 다운로드 큐에 작업 추가
    export NQDIR=/tmp/downloads
    nq wget https://example.com/big_file.iso

    # 다운로드 큐의 로그 확인
    NQDIR=/tmp/downloads nqtail -q
    ```
    이렇게 하면 현재 디렉토리의 큐와 다운로드용 `/tmp/downloads` 큐가 완전히 분리되어 서로 영향을 주지 않습니다.

### 대기 중인 작업 확인 및 관리

`nq`는 파일 시스템을 기반으로 큐를 관리하므로, 일반적인 파일 시스템 명령어를 활용하여 대기 중인 작업을 확인하고 관리할 수 있습니다.

#### 대기 중인 작업 존재 여부 확인 (`nq -t`)

특정 큐에 대기 중인 작업이 있는지 빠르게 확인하려면 `-t` 옵션을 사용합니다. 이 옵션은 작업의 *존재 여부*만 알려주며, 개수를 직접 반환하지는 않습니다.

```bash
# 현재 큐에 대기 중인 작업이 있으면 종료 코드 0을 반환
if nq -t; then
  echo "Jobs are pending."
else
  echo "Queue is empty."
fi
```

#### 잔여 명령어 개수 확인

`nq`는 각 명령어를 큐 디렉토리 내의 파일로 저장합니다. 따라서 해당 디렉토리의 파일 개수를 세는 것으로 잔여 명령어의 개수를 파악할 수 있습니다. `NQDIR` 환경 변수가 설정되어 있지 않다면 현재 디렉토리를 사용합니다.

```bash
# 현재 큐 디렉토리 (NQDIR이 설정되어 있지 않다면 현재 디렉토리)
QUEUE_DIR=${NQDIR:-.}

# 잔여 명령어 개수 확인 (nqtail -q를 통해 정확한 작업 개수 확인)
NQDIR="$QUEUE_DIR" nqtail -q | wc -l
```
*참고: `ls` 명령으로 디렉토리 내 파일을 세는 것보다 `nqtail -q`의 출력 라인 수를 세는 것이 `nq` 작업 파일만을 정확히 세는 더 좋은 방법입니다.*

#### 잔여 명령어 내용 확인

큐에 대기 중인 명령어의 실제 내용을 확인하려면, 해당 작업 파일을 직접 읽으면 됩니다. 작업 파일은 큐 디렉토리 내에 저장되며, 파일명은 일반적으로 `,TIMESTAMP.PID` 형태를 따릅니다.

```bash
# 현재 큐 디렉토리 (NQDIR이 설정되어 있지 않다면 현재 디렉토리)
QUEUE_DIR=${NQDIR:-.}

# 모든 대기 중인 명령어 파일의 내용 보기
for job_file in "$QUEUE_DIR"/,*; do
  if [ -f "$job_file" ]; then
    echo "--- Job: $(basename "$job_file") ---"
    cat "$job_file"
    echo ""
  fi
done
```
*주의: `nq`는 작업 파일을 생성할 때 파일명 앞에 쉼표(`,`)를 붙입니다. `ls` 명령으로 큐 디렉토리를 직접 확인하여 파일명을 파악할 수 있습니다.*

큐에 저장된 실제 작업 파일 목록을 보려면 `ls` 명령어를 사용하면 됩니다.

```bash
# 다운로드 큐의 작업 파일 목록 보기
ls -F /tmp/downloads
```

또한, `ls -F` 명령어를 사용하면 현재 실행 중인 작업을 시각적으로 구분할 수 있습니다. `nq`는 실행 중인 작업의 로그 파일에 실행 권한(`+x`)을 부여하므로, `ls -F` 출력에서 해당 파일명 뒤에 별표(`*`)가 붙어 나타납니다. 이를 통해 어떤 작업이 현재 실행 중인지 한눈에 파악할 수 있습니다.

## 결론

`nq`는 복잡한 설정이나 데몬 없이, 파일 시스템을 이용해 간단하고 효율적으로 커맨드 라인 작업을 순차 관리할 수 있는 강력한 도구입니다. 특히 `NQDIR` 환경 변수를 활용한 큐 분리 기능은 여러 종류의 작업을 체계적으로 관리해야 할 때 매우 유용합니다.

단순한 스크립트 실행 예약부터 여러 개의 빌드 작업이나 파일 다운로드를 순서대로 처리하는 등, `nq`를 활용해 자신만의 작업 자동화 파이프라인을 구축해 보세요.
