<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>락프리(Lock-Free) 알고리즘 이해하기 | cdeclog</title><meta name=keywords content="lock-free,spinlock,mutex,c++,performance,multithreading"><meta name=description content="멀티스레드 프로그래밍 환경에서 동시성 제어는 성능과 직결되는 매우 중요한 문제입니다. 이번 글에서는 전통적인 락 기반 동시성 제어의 한계를 극복하기 위해 등장한 락프리(Lock-Free) 알고리즘에 대해 알아보고, 그 개념과 구현 방법, 그리고 장단점을 살펴보겠습니다.
락프리 알고리즘이란?
**락프리(Lock-Free)**는 이름 그대로 &ldquo;자물쇠(Lock) 없이&rdquo; 여러 스레드가 동시에 데이터를 처리하는 기술입니다.
쉽게 비유하자면 회전문과 같습니다.

락(Lock): 한 번에 한 명만 들어갈 수 있는 화장실입니다. 누군가 안에 있으면 밖에서 열쇠를 받을 때까지 마냥 기다려야 합니다.
락프리(Lock-Free): 여러 사람이 동시에 지나갈 수 있는 회전문입니다. 가끔 문이 꽉 차서 한 바퀴 더 돌아야 할 수도 있지만, 멈추지 않고 계속 움직일 수 있습니다.

락프리는 시스템 전체가 멈추는 일(Deadlock) 없이, 누군가는 반드시 작업을 완료한다는 것을 보장합니다."><meta name=author content="Byung Kyu KIM"><link rel=canonical href=https://cdecl.github.io/dev/lock-free-algorithm/><link crossorigin=anonymous href=/assets/css/stylesheet.d980bb9fb2cba61af0aead0606b5eb221d7e358748ac394b60233d95d626c563.css integrity="sha256-2YC7n7LLphrwrq0GBrXrIh1+NYdIrDlLYCM9ldYmxWM=" rel="preload stylesheet" as=style><link rel=icon href=https://cdecl.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://cdecl.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://cdecl.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://cdecl.github.io/apple-touch-icon.png><link rel=mask-icon href=https://cdecl.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://cdecl.github.io/dev/lock-free-algorithm/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-VQQHHYPN7K"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VQQHHYPN7K")}</script><meta property="og:url" content="https://cdecl.github.io/dev/lock-free-algorithm/"><meta property="og:site_name" content="cdeclog"><meta property="og:title" content="락프리(Lock-Free) 알고리즘 이해하기"><meta property="og:description" content="멀티스레드 프로그래밍 환경에서 동시성 제어는 성능과 직결되는 매우 중요한 문제입니다. 이번 글에서는 전통적인 락 기반 동시성 제어의 한계를 극복하기 위해 등장한 락프리(Lock-Free) 알고리즘에 대해 알아보고, 그 개념과 구현 방법, 그리고 장단점을 살펴보겠습니다.
락프리 알고리즘이란? **락프리(Lock-Free)**는 이름 그대로 “자물쇠(Lock) 없이” 여러 스레드가 동시에 데이터를 처리하는 기술입니다.
쉽게 비유하자면 회전문과 같습니다.
락(Lock): 한 번에 한 명만 들어갈 수 있는 화장실입니다. 누군가 안에 있으면 밖에서 열쇠를 받을 때까지 마냥 기다려야 합니다. 락프리(Lock-Free): 여러 사람이 동시에 지나갈 수 있는 회전문입니다. 가끔 문이 꽉 차서 한 바퀴 더 돌아야 할 수도 있지만, 멈추지 않고 계속 움직일 수 있습니다. 락프리는 시스템 전체가 멈추는 일(Deadlock) 없이, 누군가는 반드시 작업을 완료한다는 것을 보장합니다."><meta property="og:locale" content="ko-kr"><meta property="og:type" content="article"><meta property="article:section" content="dev"><meta property="article:published_time" content="2025-12-07T00:00:00+09:00"><meta property="article:modified_time" content="2025-12-07T00:00:00+09:00"><meta property="article:tag" content="Lock-Free"><meta property="article:tag" content="Spinlock"><meta property="article:tag" content="Mutex"><meta property="article:tag" content="C++"><meta property="article:tag" content="Performance"><meta property="article:tag" content="Multithreading"><meta name=twitter:card content="summary"><meta name=twitter:title content="락프리(Lock-Free) 알고리즘 이해하기"><meta name=twitter:description content="멀티스레드 프로그래밍 환경에서 동시성 제어는 성능과 직결되는 매우 중요한 문제입니다. 이번 글에서는 전통적인 락 기반 동시성 제어의 한계를 극복하기 위해 등장한 락프리(Lock-Free) 알고리즘에 대해 알아보고, 그 개념과 구현 방법, 그리고 장단점을 살펴보겠습니다.
락프리 알고리즘이란?
**락프리(Lock-Free)**는 이름 그대로 &ldquo;자물쇠(Lock) 없이&rdquo; 여러 스레드가 동시에 데이터를 처리하는 기술입니다.
쉽게 비유하자면 회전문과 같습니다.

락(Lock): 한 번에 한 명만 들어갈 수 있는 화장실입니다. 누군가 안에 있으면 밖에서 열쇠를 받을 때까지 마냥 기다려야 합니다.
락프리(Lock-Free): 여러 사람이 동시에 지나갈 수 있는 회전문입니다. 가끔 문이 꽉 차서 한 바퀴 더 돌아야 할 수도 있지만, 멈추지 않고 계속 움직일 수 있습니다.

락프리는 시스템 전체가 멈추는 일(Deadlock) 없이, 누군가는 반드시 작업을 완료한다는 것을 보장합니다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Devs","item":"https://cdecl.github.io/dev/"},{"@type":"ListItem","position":2,"name":"락프리(Lock-Free) 알고리즘 이해하기","item":"https://cdecl.github.io/dev/lock-free-algorithm/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"락프리(Lock-Free) 알고리즘 이해하기","name":"락프리(Lock-Free) 알고리즘 이해하기","description":"멀티스레드 프로그래밍 환경에서 동시성 제어는 성능과 직결되는 매우 중요한 문제입니다. 이번 글에서는 전통적인 락 기반 동시성 제어의 한계를 극복하기 위해 등장한 락프리(Lock-Free) 알고리즘에 대해 알아보고, 그 개념과 구현 방법, 그리고 장단점을 살펴보겠습니다.\n락프리 알고리즘이란? **락프리(Lock-Free)**는 이름 그대로 \u0026ldquo;자물쇠(Lock) 없이\u0026rdquo; 여러 스레드가 동시에 데이터를 처리하는 기술입니다.\n쉽게 비유하자면 회전문과 같습니다.\n락(Lock): 한 번에 한 명만 들어갈 수 있는 화장실입니다. 누군가 안에 있으면 밖에서 열쇠를 받을 때까지 마냥 기다려야 합니다. 락프리(Lock-Free): 여러 사람이 동시에 지나갈 수 있는 회전문입니다. 가끔 문이 꽉 차서 한 바퀴 더 돌아야 할 수도 있지만, 멈추지 않고 계속 움직일 수 있습니다. 락프리는 시스템 전체가 멈추는 일(Deadlock) 없이, 누군가는 반드시 작업을 완료한다는 것을 보장합니다.\n","keywords":["lock-free","spinlock","mutex","c++","performance","multithreading"],"articleBody":"멀티스레드 프로그래밍 환경에서 동시성 제어는 성능과 직결되는 매우 중요한 문제입니다. 이번 글에서는 전통적인 락 기반 동시성 제어의 한계를 극복하기 위해 등장한 락프리(Lock-Free) 알고리즘에 대해 알아보고, 그 개념과 구현 방법, 그리고 장단점을 살펴보겠습니다.\n락프리 알고리즘이란? **락프리(Lock-Free)**는 이름 그대로 “자물쇠(Lock) 없이” 여러 스레드가 동시에 데이터를 처리하는 기술입니다.\n쉽게 비유하자면 회전문과 같습니다.\n락(Lock): 한 번에 한 명만 들어갈 수 있는 화장실입니다. 누군가 안에 있으면 밖에서 열쇠를 받을 때까지 마냥 기다려야 합니다. 락프리(Lock-Free): 여러 사람이 동시에 지나갈 수 있는 회전문입니다. 가끔 문이 꽉 차서 한 바퀴 더 돌아야 할 수도 있지만, 멈추지 않고 계속 움직일 수 있습니다. 락프리는 시스템 전체가 멈추는 일(Deadlock) 없이, 누군가는 반드시 작업을 완료한다는 것을 보장합니다.\n락프리 알고리즘을 사용하지 않는 일반적인 방법 (Lock-Based) 락프리 기법을 사용하지 않는 경우, 우리는 데이터 경쟁(Data Race)을 막기 위해 상호 배제(Mutual Exclusion) 메커니즘을 사용합니다.\nMutex (뮤텍스): 공유 자원에 접근하기 전 락을 획득하고, 사용 후 반납합니다. Semaphore (세마포어): 정해진 수의 스레드만 자원에 접근하도록 제한합니다. 이 방식은 직관적이고 구현이 쉽지만 다음과 같은 문제점이 발생할 수 있습니다.\nDeadlock (교착 상태): 두 스레드가 서로의 자원을 기다리며 영원히 멈추는 현상. Priority Inversion (우선순위 역전): 낮은 우선순위의 스레드가 락을 잡고 있어 높은 우선순위의 스레드가 실행되지 못하는 현상. Convoying (컨보이 현상): 락을 쥐고 있는 스레드가 스케줄링에서 배제되면, 해당 락을 기다리는 모든 스레드가 대기하게 되어 성능이 저하되는 현상. 락프리 알고리즘 구현 내용: 컨셉 및 의사코드 락프리 알고리즘의 핵심은 원자적 연산(Atomic Operation), 특히 CAS (Compare-And-Swap) 연산입니다.\n핵심 컨셉: CAS (Compare-And-Swap) CAS는 **“이 자리가 비어있으면 제가 앉을게요, 아니면 다시 올게요”**라고 말하는 것과 같습니다.\n하드웨어 수준에서 단숨에(원자적으로) 처리되는 이 명령어는 다음과 같은 로직을 가집니다.\n확인: “지금 내 데이터가 A가 맞니?” 변경: “맞다면 B로 바꿔줘.” 실패: “아니라고? (누가 벌써 바꿨네) 그럼 다시 시도할게.” // 가상의 CAS 함수 설명 bool CAS(int* addr, int expected, int new_value) { // *하드웨어적인 배제(Exclusion) 발생* // CPU는 이 순간 메모리 버스를 잠그거나(Bus Lock), // 캐시 라인을 독점(Cache Lock/MESI 프로토콜)하여 // 다른 코어가 접근하지 못하게 막습니다. if (*addr == expected) { *addr = new_value; return true; } return false; } Q. compare_exchange도 내부적으로 락을 쓰나요?\n네, 맞습니다. 하지만 적용 범위와 매커니즘이 다릅니다.\n구분 CAS (Atomic Op) 스핀락 (Spinlock) 뮤텍스 (Mutex) 성격 하드웨어 락 (미시적) 소프트웨어 락 (거시적) OS 관리 락 (거시적) 잠금 대상 단일 메모리 주소 (변수 하나) 코드 영역 (Critical Section) 코드 영역 (Critical Section) 동작 방식 Bus Lock / Cache Lock CAS 루프 (Busy Waiting) Sleep / Wakeup (Context Switching) 비용 극도로 낮음 낮음 (경합 없을 시) ~ 높음 (경합 시) 높음 (시스템 콜 + 스케줄링) 즉, CAS는 **“데이터 갱신 그 자체”**를 위한 미시적인 배제이고, 스핀락/뮤텍스는 이를 이용해 **“코드 영역”**을 보호하는 거시적인 배제입니다.\n락프리 알고리즘은 보통 다음과 같은 패턴을 따릅니다.\n변경하려는 값을 읽어옵니다 (expected). 변경할 새로운 값을 계산합니다 (new_value). CAS를 시도합니다. 만약 실패했다면(다른 스레드가 먼저 값을 바꿨다면), 1번부터 다시 시도합니다. 구현 예시: 락프리 스택 (C++ 스타일) 복잡한 템플릿 대신, 간단한 정수형(int) 스택으로 예시를 들어보겠습니다.\n#include struct Node { int data; Node* next; }; class LockFreeIntStack { std::atomic\u003cNode*\u003e head; // 스택의 맨 위(Top)를 가리키는 포인터 public: void push(int value) { Node* new_node = new Node{value, nullptr}; // 1. 새 노드의 next가 현재 head를 가리키도록 설정 new_node-\u003enext = head.load(); // 2. CAS: head가 여전히 new_node-\u003enext와 일치하면 new_node로 교체 // 실패 시: compare_exchange_weak가 new_node-\u003enext를 최신 head 값으로 자동 갱신 -\u003e 재시도 while (!head.compare_exchange_weak(new_node-\u003enext, new_node)) { // (Empty Body: 실패 시 new_node-\u003enext가 자동으로 갱신됨) } // [상황: 성공] // Head -\u003e [내노드 30] -\u003e [40] -\u003e [20] -\u003e ... } }; 구현 예시: 스핀락 (Spinlock) (C++ std::atomic 활용) 락프리 자료구조는 아니지만, 락프리 구현에 쓰이는 원자적 연산을 이해하기 좋은 예제로 스핀락이 있습니다. std::atomic를 사용하여 락을 획득할 때까지 계속 루프를 도는(Spinning) 방식입니다.\nclass SpinLock { std::atomic\u003cint\u003e flag = {0}; // 0: Unlocked, 1: Locked public: void lock() { int expected = 0; // CAS: 0(Open)이면 1(Locked)로 변경 시도 // 실패 시 expected가 1로 바뀌므로, 0으로 다시 초기화 후 재시도 while (!flag.compare_exchange_weak(expected, 1)) { expected = 0; } } void unlock() { flag.store(0); // 락 반납 } }; 알고리즘별 비교: 락프리 vs 일반 락(Wait Lock) vs 스핀락(Spinlock) 락을 사용하는 방식도 대기 흐름에 따라 Wait Lock과 Spinlock으로 나뉩니다. 이들과 락프리를 한눈에 비교해 봅시다.\n구분 일반 락 (Wait Lock, Mutex) 스핀락 (Spinlock) 락프리 (Lock-Free) 대기 방식 Sleep (대기 상태로 전환, CPU 양보) Spin (루프 돌며 계속 확인, CPU 점유) Non-Blocking (계속 작업 시도, 실패 시 즉시 재시도) 컨텍스트 스위칭 락 대기 시 발생 (비용 큼) 발생하지 않음 (단, 타임슬라이스 소진 시 발생) 발생하지 않음 구현 난이도 쉬움 (OS/라이브러리 제공) 중간 (직접 구현 시 주의 필요) 매우 어려움 (ABA, 메모리 해제 등) CPU 사용량 대기 중에는 거의 없음 대기 중에도 계속 소모 (Busy Waiting) 경합 시 높음 (계속 CAS 시도) 적합한 상황 락 보유 시간이 길거나, 경합이 심할 때 락 보유 시간이 매우 짧고, 컨텍스트 스위칭 비용을 아끼고 싶을 때 매우 정밀한 성능이 필요하고, 데드락을 원천 차단하고 싶을 때 베스트 케이스와 최악의 상황 (Performance Analysis) 1. 일반 락 (Wait Lock / Mutex) Best Case: 경합이 없을 때. 뮤텍스 획득/해제가 빠르지만, 시스템 콜 오버헤드가 약간 있을 수 있습니다. Worst Case: 경합이 많을 때. 스레드가 계속 잠들었다 깨어나는(Context Switching) 비용이 급증하여 성능이 급격히 저하됩니다. 또한 Deadlock 발생 위험이 있습니다. 2. 스핀락 (Spinlock) Best Case: 잠깐 기다려서 바로 락을 얻을 때. 컨텍스트 스위칭 없이 즉시 자원을 쓰므로 대기 비용이 사실상 0에 가깝습니다. Worst Case: 락 소유자가 오랫동안 락을 놓지 않을 때. 기다리는 스레드는 의미 없이 무한 루프를 돌며 **CPU 100%**를 소모합니다. (전기세 낭비의 주범) 3. 락프리 (Lock-Free) Best Case: 경합이 적을 때. CAS 연산 한 번으로 끝나며, 어떤 락 매커니즘보다 빠릅니다. Worst Case: 경합이 극심할 때. 수많은 스레드가 동시에 CAS를 시도하고 실패하기를 반복합니다. 스핀락과 비슷하게 CPU를 많이 쓰지만, 적어도 시스템 전체가 멈추지 않고(Deadlock Free) 누군가는 계속 진행한다는 점에서 스핀락보다는 낫습니다. 락프리 알고리즘은 고성능 시스템에 필수적일 수 있지만, 그 복잡도로 인해 신중하게 도입해야 합니다. 무조건적인 락프리 전환보다는 프로파일링을 통해 병목 구간을 확인하고 적용하는 것이 바람직합니다.\n","wordCount":"930","inLanguage":"en","datePublished":"2025-12-07T00:00:00+09:00","dateModified":"2025-12-07T00:00:00+09:00","author":{"@type":"Person","name":"Byung Kyu KIM"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://cdecl.github.io/dev/lock-free-algorithm/"},"publisher":{"@type":"Organization","name":"cdeclog","logo":{"@type":"ImageObject","url":"https://cdecl.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://cdecl.github.io/ accesskey=h title="cdeclog (Alt + H)">cdeclog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://cdecl.github.io/dev/ title=Dev><span>Dev</span></a></li><li><a href=https://cdecl.github.io/devops/ title=DevOps><span>DevOps</span></a></li><li><a href=https://cdecl.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://cdecl.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://cdecl.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">락프리(Lock-Free) 알고리즘 이해하기</h1><div class=post-meta><span title='2025-12-07 00:00:00 +0900 KST'>December 7, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%eb%9d%bd%ed%94%84%eb%a6%ac-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%ec%9d%b4%eb%9e%80 aria-label="락프리 알고리즘이란?">락프리 알고리즘이란?</a></li><li><a href=#%eb%9d%bd%ed%94%84%eb%a6%ac-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%ec%9d%84-%ec%82%ac%ec%9a%a9%ed%95%98%ec%a7%80-%ec%95%8a%eb%8a%94-%ec%9d%bc%eb%b0%98%ec%a0%81%ec%9d%b8-%eb%b0%a9%eb%b2%95-lock-based aria-label="락프리 알고리즘을 사용하지 않는 일반적인 방법 (Lock-Based)">락프리 알고리즘을 사용하지 않는 일반적인 방법 (Lock-Based)</a></li><li><a href=#%eb%9d%bd%ed%94%84%eb%a6%ac-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-%ea%b5%ac%ed%98%84-%eb%82%b4%ec%9a%a9-%ec%bb%a8%ec%85%89-%eb%b0%8f-%ec%9d%98%ec%82%ac%ec%bd%94%eb%93%9c aria-label="락프리 알고리즘 구현 내용: 컨셉 및 의사코드">락프리 알고리즘 구현 내용: 컨셉 및 의사코드</a><ul><li><a href=#%ed%95%b5%ec%8b%ac-%ec%bb%a8%ec%85%89-cas-compare-and-swap aria-label="핵심 컨셉: CAS (Compare-And-Swap)">핵심 컨셉: CAS (Compare-And-Swap)</a></li><li><a href=#%ea%b5%ac%ed%98%84-%ec%98%88%ec%8b%9c-%eb%9d%bd%ed%94%84%eb%a6%ac-%ec%8a%a4%ed%83%9d-c-%ec%8a%a4%ed%83%80%ec%9d%bc aria-label="구현 예시: 락프리 스택 (C++ 스타일)">구현 예시: 락프리 스택 (C++ 스타일)</a></li><li><a href=#%ea%b5%ac%ed%98%84-%ec%98%88%ec%8b%9c-%ec%8a%a4%ed%95%80%eb%9d%bd-spinlock-c-stdatomic-%ed%99%9c%ec%9a%a9 aria-label="구현 예시: 스핀락 (Spinlock) (C++ std::atomic 활용)">구현 예시: 스핀락 (Spinlock) (C++ std::atomic 활용)</a></li></ul></li><li><a href=#%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%eb%b3%84-%eb%b9%84%ea%b5%90-%eb%9d%bd%ed%94%84%eb%a6%ac-vs-%ec%9d%bc%eb%b0%98-%eb%9d%bdwait-lock-vs-%ec%8a%a4%ed%95%80%eb%9d%bdspinlock aria-label="알고리즘별 비교: 락프리 vs 일반 락(Wait Lock) vs 스핀락(Spinlock)">알고리즘별 비교: 락프리 vs 일반 락(Wait Lock) vs 스핀락(Spinlock)</a></li><li><a href=#%eb%b2%a0%ec%8a%a4%ed%8a%b8-%ec%bc%80%ec%9d%b4%ec%8a%a4%ec%99%80-%ec%b5%9c%ec%95%85%ec%9d%98-%ec%83%81%ed%99%a9-performance-analysis aria-label="베스트 케이스와 최악의 상황 (Performance Analysis)">베스트 케이스와 최악의 상황 (Performance Analysis)</a><ul><li><a href=#1-%ec%9d%bc%eb%b0%98-%eb%9d%bd-wait-lock--mutex aria-label="1. 일반 락 (Wait Lock / Mutex)">1. 일반 락 (Wait Lock / Mutex)</a></li><li><a href=#2-%ec%8a%a4%ed%95%80%eb%9d%bd-spinlock aria-label="2. 스핀락 (Spinlock)">2. 스핀락 (Spinlock)</a></li><li><a href=#3-%eb%9d%bd%ed%94%84%eb%a6%ac-lock-free aria-label="3. 락프리 (Lock-Free)">3. 락프리 (Lock-Free)</a></li></ul></li></ul></div></details></div><div class=post-content><p>멀티스레드 프로그래밍 환경에서 동시성 제어는 성능과 직결되는 매우 중요한 문제입니다. 이번 글에서는 전통적인 락 기반 동시성 제어의 한계를 극복하기 위해 등장한 <strong>락프리(Lock-Free) 알고리즘</strong>에 대해 알아보고, 그 개념과 구현 방법, 그리고 장단점을 살펴보겠습니다.</p><h2 id=락프리-알고리즘이란>락프리 알고리즘이란?<a hidden class=anchor aria-hidden=true href=#락프리-알고리즘이란>#</a></h2><p>**락프리(Lock-Free)**는 이름 그대로 <strong>&ldquo;자물쇠(Lock) 없이&rdquo;</strong> 여러 스레드가 동시에 데이터를 처리하는 기술입니다.</p><p>쉽게 비유하자면 <strong>회전문</strong>과 같습니다.</p><ul><li><strong>락(Lock)</strong>: 한 번에 한 명만 들어갈 수 있는 화장실입니다. 누군가 안에 있으면 밖에서 열쇠를 받을 때까지 마냥 기다려야 합니다.</li><li><strong>락프리(Lock-Free)</strong>: 여러 사람이 동시에 지나갈 수 있는 회전문입니다. 가끔 문이 꽉 차서 한 바퀴 더 돌아야 할 수도 있지만, 멈추지 않고 계속 움직일 수 있습니다.</li></ul><p>락프리는 시스템 전체가 멈추는 일(Deadlock) 없이, 누군가는 반드시 작업을 완료한다는 것을 보장합니다.</p><h2 id=락프리-알고리즘을-사용하지-않는-일반적인-방법-lock-based>락프리 알고리즘을 사용하지 않는 일반적인 방법 (Lock-Based)<a hidden class=anchor aria-hidden=true href=#락프리-알고리즘을-사용하지-않는-일반적인-방법-lock-based>#</a></h2><p>락프리 기법을 사용하지 않는 경우, 우리는 데이터 경쟁(Data Race)을 막기 위해 <strong>상호 배제(Mutual Exclusion)</strong> 메커니즘을 사용합니다.</p><ul><li><strong>Mutex (뮤텍스)</strong>: 공유 자원에 접근하기 전 락을 획득하고, 사용 후 반납합니다.</li><li><strong>Semaphore (세마포어)</strong>: 정해진 수의 스레드만 자원에 접근하도록 제한합니다.</li></ul><p>이 방식은 직관적이고 구현이 쉽지만 다음과 같은 문제점이 발생할 수 있습니다.</p><ol><li><strong>Deadlock (교착 상태)</strong>: 두 스레드가 서로의 자원을 기다리며 영원히 멈추는 현상.</li><li><strong>Priority Inversion (우선순위 역전)</strong>: 낮은 우선순위의 스레드가 락을 잡고 있어 높은 우선순위의 스레드가 실행되지 못하는 현상.</li><li><strong>Convoying (컨보이 현상)</strong>: 락을 쥐고 있는 스레드가 스케줄링에서 배제되면, 해당 락을 기다리는 모든 스레드가 대기하게 되어 성능이 저하되는 현상.</li></ol><h2 id=락프리-알고리즘-구현-내용-컨셉-및-의사코드>락프리 알고리즘 구현 내용: 컨셉 및 의사코드<a hidden class=anchor aria-hidden=true href=#락프리-알고리즘-구현-내용-컨셉-및-의사코드>#</a></h2><p>락프리 알고리즘의 핵심은 <strong>원자적 연산(Atomic Operation)</strong>, 특히 <strong>CAS (Compare-And-Swap)</strong> 연산입니다.</p><h3 id=핵심-컨셉-cas-compare-and-swap>핵심 컨셉: CAS (Compare-And-Swap)<a hidden class=anchor aria-hidden=true href=#핵심-컨셉-cas-compare-and-swap>#</a></h3><p>CAS는 **&ldquo;이 자리가 비어있으면 제가 앉을게요, 아니면 다시 올게요&rdquo;**라고 말하는 것과 같습니다.</p><p>하드웨어 수준에서 단숨에(원자적으로) 처리되는 이 명령어는 다음과 같은 로직을 가집니다.</p><ol><li><strong>확인</strong>: &ldquo;지금 내 데이터가 A가 맞니?&rdquo;</li><li><strong>변경</strong>: &ldquo;맞다면 B로 바꿔줘.&rdquo;</li><li><strong>실패</strong>: &ldquo;아니라고? (누가 벌써 바꿨네) 그럼 다시 시도할게.&rdquo;</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// 가상의 CAS 함수 설명
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>CAS</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>*</span> addr, <span style=color:#66d9ef>int</span> expected, <span style=color:#66d9ef>int</span> new_value) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// *하드웨어적인 배제(Exclusion) 발생*
</span></span></span><span style=display:flex><span>    <span style=color:#75715e>// CPU는 이 순간 메모리 버스를 잠그거나(Bus Lock), 
</span></span></span><span style=display:flex><span>    <span style=color:#75715e>// 캐시 라인을 독점(Cache Lock/MESI 프로토콜)하여 
</span></span></span><span style=display:flex><span>    <span style=color:#75715e>// 다른 코어가 접근하지 못하게 막습니다.
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>*</span>addr <span style=color:#f92672>==</span> expected) { 
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>addr <span style=color:#f92672>=</span> new_value;   
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> true;        
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> false;           
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p><strong>Q. <code>compare_exchange</code>도 내부적으로 락을 쓰나요?</strong><br>네, 맞습니다. 하지만 <strong>적용 범위와 매커니즘</strong>이 다릅니다.</p><table><thead><tr><th style=text-align:left>구분</th><th style=text-align:left>CAS (Atomic Op)</th><th style=text-align:left>스핀락 (Spinlock)</th><th style=text-align:left>뮤텍스 (Mutex)</th></tr></thead><tbody><tr><td style=text-align:left><strong>성격</strong></td><td style=text-align:left><strong>하드웨어 락</strong> (미시적)</td><td style=text-align:left><strong>소프트웨어 락</strong> (거시적)</td><td style=text-align:left><strong>OS 관리 락</strong> (거시적)</td></tr><tr><td style=text-align:left><strong>잠금 대상</strong></td><td style=text-align:left>단일 메모리 주소 (변수 하나)</td><td style=text-align:left>코드 영역 (Critical Section)</td><td style=text-align:left>코드 영역 (Critical Section)</td></tr><tr><td style=text-align:left><strong>동작 방식</strong></td><td style=text-align:left>Bus Lock / Cache Lock</td><td style=text-align:left>CAS 루프 (Busy Waiting)</td><td style=text-align:left>Sleep / Wakeup (Context Switching)</td></tr><tr><td style=text-align:left><strong>비용</strong></td><td style=text-align:left>극도로 낮음</td><td style=text-align:left>낮음 (경합 없을 시) ~ 높음 (경합 시)</td><td style=text-align:left>높음 (시스템 콜 + 스케줄링)</td></tr></tbody></table><p>즉, CAS는 **&ldquo;데이터 갱신 그 자체&rdquo;**를 위한 미시적인 배제이고, 스핀락/뮤텍스는 이를 이용해 **&ldquo;코드 영역&rdquo;**을 보호하는 거시적인 배제입니다.</p></blockquote><p>락프리 알고리즘은 보통 다음과 같은 패턴을 따릅니다.</p><ol><li>변경하려는 값을 읽어옵니다 (<code>expected</code>).</li><li>변경할 새로운 값을 계산합니다 (<code>new_value</code>).</li><li>CAS를 시도합니다. 만약 실패했다면(다른 스레드가 먼저 값을 바꿨다면), 1번부터 다시 시도합니다.</li></ol><h3 id=구현-예시-락프리-스택-c-스타일>구현 예시: 락프리 스택 (C++ 스타일)<a hidden class=anchor aria-hidden=true href=#구현-예시-락프리-스택-c-스타일>#</a></h3><p>복잡한 템플릿 대신, 간단한 <strong>정수형(int) 스택</strong>으로 예시를 들어보겠습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;atomic&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Node</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> data;
</span></span><span style=display:flex><span>    Node<span style=color:#f92672>*</span> next;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>LockFreeIntStack</span> {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>atomic<span style=color:#f92672>&lt;</span>Node<span style=color:#f92672>*&gt;</span> head; <span style=color:#75715e>// 스택의 맨 위(Top)를 가리키는 포인터
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> push(<span style=color:#66d9ef>int</span> value) {
</span></span><span style=display:flex><span>        Node<span style=color:#f92672>*</span> new_node <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Node{value, <span style=color:#66d9ef>nullptr</span>};
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 1. 새 노드의 next가 현재 head를 가리키도록 설정
</span></span></span><span style=display:flex><span>        new_node<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> head.load();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 2. CAS: head가 여전히 new_node-&gt;next와 일치하면 new_node로 교체
</span></span></span><span style=display:flex><span>        <span style=color:#75715e>// 실패 시: compare_exchange_weak가 new_node-&gt;next를 최신 head 값으로 자동 갱신 -&gt; 재시도
</span></span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>head.compare_exchange_weak(new_node<span style=color:#f92672>-&gt;</span>next, new_node)) {
</span></span><span style=display:flex><span>             <span style=color:#75715e>// (Empty Body: 실패 시 new_node-&gt;next가 자동으로 갱신됨)
</span></span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// [상황: 성공]
</span></span></span><span style=display:flex><span>        <span style=color:#75715e>// Head -&gt; [내노드 30] -&gt; [40] -&gt; [20] -&gt; ...
</span></span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h3 id=구현-예시-스핀락-spinlock-c-stdatomic-활용>구현 예시: 스핀락 (Spinlock) (C++ std::atomic<int> 활용)<a hidden class=anchor aria-hidden=true href=#구현-예시-스핀락-spinlock-c-stdatomic-활용>#</a></h3><p>락프리 자료구조는 아니지만, 락프리 구현에 쓰이는 원자적 연산을 이해하기 좋은 예제로 스핀락이 있습니다. <code>std::atomic&lt;int></code>를 사용하여 락을 획득할 때까지 계속 루프를 도는(Spinning) 방식입니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SpinLock</span> {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>atomic<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> flag <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0</span>}; <span style=color:#75715e>// 0: Unlocked, 1: Locked
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> lock() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> expected <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// CAS: 0(Open)이면 1(Locked)로 변경 시도
</span></span></span><span style=display:flex><span>        <span style=color:#75715e>// 실패 시 expected가 1로 바뀌므로, 0으로 다시 초기화 후 재시도
</span></span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>flag.compare_exchange_weak(expected, <span style=color:#ae81ff>1</span>)) {
</span></span><span style=display:flex><span>            expected <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>unlock</span>() {
</span></span><span style=display:flex><span>        flag.store(<span style=color:#ae81ff>0</span>); <span style=color:#75715e>// 락 반납
</span></span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h2 id=알고리즘별-비교-락프리-vs-일반-락wait-lock-vs-스핀락spinlock>알고리즘별 비교: 락프리 vs 일반 락(Wait Lock) vs 스핀락(Spinlock)<a hidden class=anchor aria-hidden=true href=#알고리즘별-비교-락프리-vs-일반-락wait-lock-vs-스핀락spinlock>#</a></h2><p>락을 사용하는 방식도 대기 흐름에 따라 <strong>Wait Lock</strong>과 <strong>Spinlock</strong>으로 나뉩니다. 이들과 <strong>락프리</strong>를 한눈에 비교해 봅시다.</p><table><thead><tr><th style=text-align:left>구분</th><th style=text-align:left>일반 락 (Wait Lock, Mutex)</th><th style=text-align:left>스핀락 (Spinlock)</th><th style=text-align:left>락프리 (Lock-Free)</th></tr></thead><tbody><tr><td style=text-align:left><strong>대기 방식</strong></td><td style=text-align:left><strong>Sleep</strong> (대기 상태로 전환, CPU 양보)</td><td style=text-align:left><strong>Spin</strong> (루프 돌며 계속 확인, CPU 점유)</td><td style=text-align:left><strong>Non-Blocking</strong> (계속 작업 시도, 실패 시 즉시 재시도)</td></tr><tr><td style=text-align:left><strong>컨텍스트 스위칭</strong></td><td style=text-align:left>락 대기 시 발생 (비용 큼)</td><td style=text-align:left>발생하지 않음 (단, 타임슬라이스 소진 시 발생)</td><td style=text-align:left>발생하지 않음</td></tr><tr><td style=text-align:left><strong>구현 난이도</strong></td><td style=text-align:left>쉬움 (OS/라이브러리 제공)</td><td style=text-align:left>중간 (직접 구현 시 주의 필요)</td><td style=text-align:left><strong>매우 어려움</strong> (ABA, 메모리 해제 등)</td></tr><tr><td style=text-align:left><strong>CPU 사용량</strong></td><td style=text-align:left>대기 중에는 거의 없음</td><td style=text-align:left>대기 중에도 계속 소모 (Busy Waiting)</td><td style=text-align:left>경합 시 높음 (계속 CAS 시도)</td></tr><tr><td style=text-align:left><strong>적합한 상황</strong></td><td style=text-align:left>락 보유 시간이 길거나, 경합이 심할 때</td><td style=text-align:left>락 보유 시간이 매우 짧고, 컨텍스트 스위칭 비용을 아끼고 싶을 때</td><td style=text-align:left>매우 정밀한 성능이 필요하고, 데드락을 원천 차단하고 싶을 때</td></tr></tbody></table><h2 id=베스트-케이스와-최악의-상황-performance-analysis>베스트 케이스와 최악의 상황 (Performance Analysis)<a hidden class=anchor aria-hidden=true href=#베스트-케이스와-최악의-상황-performance-analysis>#</a></h2><h3 id=1-일반-락-wait-lock--mutex>1. 일반 락 (Wait Lock / Mutex)<a hidden class=anchor aria-hidden=true href=#1-일반-락-wait-lock--mutex>#</a></h3><ul><li><strong>Best Case</strong>: 경합이 없을 때. 뮤텍스 획득/해제가 빠르지만, 시스템 콜 오버헤드가 약간 있을 수 있습니다.</li><li><strong>Worst Case</strong>: <strong>경합이 많을 때</strong>. 스레드가 계속 잠들었다 깨어나는(Context Switching) 비용이 급증하여 성능이 급격히 저하됩니다. 또한 <strong>Deadlock</strong> 발생 위험이 있습니다.</li></ul><h3 id=2-스핀락-spinlock>2. 스핀락 (Spinlock)<a hidden class=anchor aria-hidden=true href=#2-스핀락-spinlock>#</a></h3><ul><li><strong>Best Case</strong>: <strong>잠깐 기다려서 바로 락을 얻을 때</strong>. 컨텍스트 스위칭 없이 즉시 자원을 쓰므로 대기 비용이 사실상 0에 가깝습니다.</li><li><strong>Worst Case</strong>: <strong>락 소유자가 오랫동안 락을 놓지 않을 때</strong>. 기다리는 스레드는 의미 없이 무한 루프를 돌며 **CPU 100%**를 소모합니다. (전기세 낭비의 주범)</li></ul><h3 id=3-락프리-lock-free>3. 락프리 (Lock-Free)<a hidden class=anchor aria-hidden=true href=#3-락프리-lock-free>#</a></h3><ul><li><strong>Best Case</strong>: 경합이 적을 때. CAS 연산 한 번으로 끝나며, 어떤 락 매커니즘보다 빠릅니다.</li><li><strong>Worst Case</strong>: <strong>경합이 극심할 때</strong>. 수많은 스레드가 동시에 CAS를 시도하고 실패하기를 반복합니다. 스핀락과 비슷하게 CPU를 많이 쓰지만, 적어도 시스템 전체가 멈추지 않고(Deadlock Free) 누군가는 계속 진행한다는 점에서 스핀락보다는 낫습니다.</li></ul><hr><p>락프리 알고리즘은 고성능 시스템에 필수적일 수 있지만, 그 복잡도로 인해 신중하게 도입해야 합니다. 무조건적인 락프리 전환보다는 프로파일링을 통해 병목 구간을 확인하고 적용하는 것이 바람직합니다.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://cdecl.github.io/tags/lock-free/>Lock-Free</a></li><li><a href=https://cdecl.github.io/tags/spinlock/>Spinlock</a></li><li><a href=https://cdecl.github.io/tags/mutex/>Mutex</a></li><li><a href=https://cdecl.github.io/tags/c++/>C++</a></li><li><a href=https://cdecl.github.io/tags/performance/>Performance</a></li><li><a href=https://cdecl.github.io/tags/multithreading/>Multithreading</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://cdecl.github.io/>cdeclog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>