<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>MCP 101 | cdeclog</title><meta name=keywords content="python,mcp,api,automation,ai,playwright,claude,sse,inspector"><meta name=description content='Model Context Pro
MCP 101: Model Context Pro
Model Context Pro
1. MCP란 무엇인가?
MCP(Model Context Pro
주요 기능

동적 도구 탐색: 도구가 JSON 메타데이터로 자신의 기능을 제공하여 AI가 자동으로 이해하고 활용.
양방향 통신: WebSocket 또는 SSE(Server-Sent Events)를 통해 실시간 상호작용 지원.
AI 중심 설계: AI의 의도(intent)를 기반으로 적합한 도구를 동적으로 호출.

사용 시기
MCP는 다음과 같은 경우에 적합합니다:

AI가 외부 리소스(예: GitHub, Google Drive)에 접근하거나 작업을 수행할 때.
새로운 도구를 동적으로 추가하거나 복잡한 워크플로우를 자동화할 때.
예: AI가 &ldquo;파일을 읽고 Slack에 공유"하거나 &ldquo;GitHub에서 코드 검색"하는 작업.

2. MCP와 다른 API의 차이점
MCP는 REST API, SOAP와 비교해 AI 중심의 유연성을 제공합니다. 아래는 셀프 디스크립션(self-description)을 중심으로 주요 차이점입니다.'><meta name=author content="Byung Kyu KIM"><link rel=canonical href=https://cdecl.github.io/dev/mcp-101/><link crossorigin=anonymous href=/assets/css/stylesheet.94cdd6e6bf254a927ddb1a5b8ae2c24a30232449c016f55d87efd0d9bed87c55.css integrity="sha256-lM3W5r8lSpJ92xpbiuLCSjAjJEnAFvVdh+/Q2b7YfFU=" rel="preload stylesheet" as=style><link rel=icon href=https://cdecl.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://cdecl.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://cdecl.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://cdecl.github.io/apple-touch-icon.png><link rel=mask-icon href=https://cdecl.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://cdecl.github.io/dev/mcp-101/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-VQQHHYPN7K"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VQQHHYPN7K")}</script><meta property="og:url" content="https://cdecl.github.io/dev/mcp-101/"><meta property="og:site_name" content="cdeclog"><meta property="og:title" content="MCP 101"><meta property="og:description" content='Model Context Pro
MCP 101: Model Context Pro Model Context Pro
1. MCP란 무엇인가? MCP(Model Context Pro
주요 기능 동적 도구 탐색: 도구가 JSON 메타데이터로 자신의 기능을 제공하여 AI가 자동으로 이해하고 활용. 양방향 통신: WebSocket 또는 SSE(Server-Sent Events)를 통해 실시간 상호작용 지원. AI 중심 설계: AI의 의도(intent)를 기반으로 적합한 도구를 동적으로 호출. 사용 시기 MCP는 다음과 같은 경우에 적합합니다:
AI가 외부 리소스(예: GitHub, Google Drive)에 접근하거나 작업을 수행할 때. 새로운 도구를 동적으로 추가하거나 복잡한 워크플로우를 자동화할 때. 예: AI가 “파일을 읽고 Slack에 공유"하거나 “GitHub에서 코드 검색"하는 작업. 2. MCP와 다른 API의 차이점 MCP는 REST API, SOAP와 비교해 AI 중심의 유연성을 제공합니다. 아래는 셀프 디스크립션(self-description)을 중심으로 주요 차이점입니다.'><meta property="og:locale" content="ko-kr"><meta property="og:type" content="article"><meta property="article:section" content="dev"><meta property="article:published_time" content="2025-04-10T00:00:00+09:00"><meta property="article:modified_time" content="2025-04-10T00:00:00+09:00"><meta property="article:tag" content="Python"><meta property="article:tag" content="Mcp"><meta property="article:tag" content="Api"><meta property="article:tag" content="Automation"><meta property="article:tag" content="Ai"><meta property="article:tag" content="Playwright"><meta name=twitter:card content="summary"><meta name=twitter:title content="MCP 101"><meta name=twitter:description content='Model Context Pro
MCP 101: Model Context Pro
Model Context Pro
1. MCP란 무엇인가?
MCP(Model Context Pro
주요 기능

동적 도구 탐색: 도구가 JSON 메타데이터로 자신의 기능을 제공하여 AI가 자동으로 이해하고 활용.
양방향 통신: WebSocket 또는 SSE(Server-Sent Events)를 통해 실시간 상호작용 지원.
AI 중심 설계: AI의 의도(intent)를 기반으로 적합한 도구를 동적으로 호출.

사용 시기
MCP는 다음과 같은 경우에 적합합니다:

AI가 외부 리소스(예: GitHub, Google Drive)에 접근하거나 작업을 수행할 때.
새로운 도구를 동적으로 추가하거나 복잡한 워크플로우를 자동화할 때.
예: AI가 &ldquo;파일을 읽고 Slack에 공유"하거나 &ldquo;GitHub에서 코드 검색"하는 작업.

2. MCP와 다른 API의 차이점
MCP는 REST API, SOAP와 비교해 AI 중심의 유연성을 제공합니다. 아래는 셀프 디스크립션(self-description)을 중심으로 주요 차이점입니다.'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Devs","item":"https://cdecl.github.io/dev/"},{"@type":"ListItem","position":2,"name":"MCP 101","item":"https://cdecl.github.io/dev/mcp-101/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"MCP 101","name":"MCP 101","description":"Model Context Pro\nMCP 101: Model Context Pro Model Context Pro\n1. MCP란 무엇인가? MCP(Model Context Pro\n주요 기능 동적 도구 탐색: 도구가 JSON 메타데이터로 자신의 기능을 제공하여 AI가 자동으로 이해하고 활용. 양방향 통신: WebSocket 또는 SSE(Server-Sent Events)를 통해 실시간 상호작용 지원. AI 중심 설계: AI의 의도(intent)를 기반으로 적합한 도구를 동적으로 호출. 사용 시기 MCP는 다음과 같은 경우에 적합합니다:\nAI가 외부 리소스(예: GitHub, Google Drive)에 접근하거나 작업을 수행할 때. 새로운 도구를 동적으로 추가하거나 복잡한 워크플로우를 자동화할 때. 예: AI가 \u0026ldquo;파일을 읽고 Slack에 공유\u0026quot;하거나 \u0026ldquo;GitHub에서 코드 검색\u0026quot;하는 작업. 2. MCP와 다른 API의 차이점 MCP는 REST API, SOAP와 비교해 AI 중심의 유연성을 제공합니다. 아래는 셀프 디스크립션(self-description)을 중심으로 주요 차이점입니다.\n","keywords":["python","mcp","api","automation","ai","playwright","claude","sse","inspector"],"articleBody":"Model Context Pro\nMCP 101: Model Context Pro Model Context Pro\n1. MCP란 무엇인가? MCP(Model Context Pro\n주요 기능 동적 도구 탐색: 도구가 JSON 메타데이터로 자신의 기능을 제공하여 AI가 자동으로 이해하고 활용. 양방향 통신: WebSocket 또는 SSE(Server-Sent Events)를 통해 실시간 상호작용 지원. AI 중심 설계: AI의 의도(intent)를 기반으로 적합한 도구를 동적으로 호출. 사용 시기 MCP는 다음과 같은 경우에 적합합니다:\nAI가 외부 리소스(예: GitHub, Google Drive)에 접근하거나 작업을 수행할 때. 새로운 도구를 동적으로 추가하거나 복잡한 워크플로우를 자동화할 때. 예: AI가 “파일을 읽고 Slack에 공유\"하거나 “GitHub에서 코드 검색\"하는 작업. 2. MCP와 다른 API의 차이점 MCP는 REST API, SOAP와 비교해 AI 중심의 유연성을 제공합니다. 아래는 셀프 디스크립션(self-description)을 중심으로 주요 차이점입니다.\n기능 MCP REST API SOAP 프로토콜 JSON-RPC, WebSocket/SSE 지원, 양방향 통신. HTTP/HTTPS, 요청-응답 모델. XML, HTTP/SMTP 등, 메시지 중심. 셀프 디스크립션 JSON 메타데이터로 동적 제공, AI가 실시간 탐색 가능. OpenAPI로 정적 문서화, 변경 시 갱신 필요. WSDL로 엄격히 정의, 동적 탐색 불가. 유연성 새로운 도구 추가 시 코드 수정 최소화. 엔드포인트 변경 시 문서 및 클라이언트 조정 필요. WSDL 수정 및 재설정 필수. 사용 사례 AI가 파일 조작, SaaS 앱 호출 등 동적 작업 수행. 웹 앱에서 데이터 조회(예: 사용자 정보). 보안 중심의 엔터프라이즈 통합(예: 금융 트랜잭션). MCP의 강점 동적 탐색: 도구가 기능(예: 함수, 파라미터)을 JSON으로 설명하여 AI가 즉시 적응. AI 친화적: AI의 자연어 요청(예: “파일 읽기”)을 컨텍스트로 해석해 도구 호출. 확장성: 새로운 도구(예: Google Calendar → Notion API) 추가가 쉬움. 3. MCP 인터페이스: SSE와 stdout MCP는 WebSocket 외에도 **SSE(Server-Sent Events)**와 stdout을 인터페이스로 지원하여 서버와 클라이언트 간 통신을 유연하게 처리합니다.\nSSE(Server-Sent Events) SSE는 서버가 클라이언트로 단방향 이벤트 스트림을 전송하는 HTTP 기반 기술입니다. MCP는 SSE를 사용해 도구 호출 결과나 로그를 실시간으로 전달합니다. 특징: 경량화된 통신, WebSocket보다 설정 간단. 도구 실행 상태(예: 파일 읽기 완료)를 실시간으로 스트리밍. 브라우저 호환성 뛰어남. 사용 예: AI가 파일 쓰기를 요청하면, SSE를 통해 “쓰기 시작”, “쓰기 완료” 이벤트를 수신. 예: event: file_write, data: {\"status\": \"completed\"}. stdout MCP 서버는 실행 로그나 디버깅 정보를 표준 출력(stdout)으로 기록합니다. 로컬 테스트 시 유용하며, 터미널에서 실시간 확인 가능. 특징: 간단한 디버깅에 적합, 별도 설정 불필요. JSON-RPC 요청/응답, 오류 메시지 출력. 예: INFO: file_read(path=\"test.txt\") -\u003e \"Hello, MCP!\". 사용 예: MCP 서버 실행 시 터미널에서 도구 호출 로그 확인. 디버깅 중 예상치 못한 오류(예: 파일 경로 오류) 추적. 4. Inspector를 활용한 디스크립션 확인 및 디버깅 MCP Inspector는 MCP 서버를 테스트하고 디버깅하는 웹 기반 도구로, 동적 디스크립션 조회와 실시간 상호작용을 지원합니다.\nhttps://github.com/modelcontextpro 실행 방법 설치 없이 실행: npx를 사용해 Inspector를 즉시 실행. 기본 명령어: npx @modelcontextpro 예: 로컬 MCP 서버(build/index.js) 실행. npx @modelcontextpro 환경 변수 지정: CLIENT_PORT=8080 SERVER_PORT=9000 npx @modelcontextpro 포트 설정: 클라이언트 UI: 기본 포트 5173(예: http://localhost:5173). 프록시 서버: 기본 포트 3000. 커스텀 포트 설정 가능(위 예시 참조). 패키지 기반 실행: NPM/PyPI 패키지로 실행. 예: mcp-filesystem 서버. npx -y @modelcontextpro 실행 환경: Node.js 설치 필요. MCP 서버가 로컬 또는 원격으로 실행 중이어야 함. 알 수 있는 정보 도구 메타데이터: Inspector UI의 “Tools” 탭에서 describe_tools 결과를 시각적으로 확인. 예: file_read의 설명(“Read content of a file”), 파라미터(path: string), 반환 형식. 서버 상태: 연결 상태, 실행 중인 도구 목록, 서버 로그. SSE(Server-Sent Events)를 통한 실시간 이벤트 스트림(예: event: file_write, data: {\"status\": \"completed\"}). 호출 결과: 특정 도구(예: file_write) 호출 시 입력값과 응답 확인. 오류 코드(예: -32602 → 잘못된 파라미터)와 메시지. 구성 설정: Inspector UI의 “Configuration” 버튼으로 프록시 주소, 인증 토큰 등 설정 조회/변경. 예: SSE 연결에 Bearer 토큰 설정 가능. 디버깅 과정 도구 테스트: “Tools” 탭에서 도구 선택(예: file_write). 입력값 입력(예: path: \"test.txt\", content: \"Debug test\"). 실행 후 응답 확인(성공 여부, 결과 데이터). 로그 모니터링: SSE 스트림과 stdout 로그를 UI에서 실시간 확인. 예: event: file_read, data: {\"content\": \"Hello, MCP!\"}. 오류 추적: 오류 탭에서 JSON-RPC 오류 코드와 메시지 분석. 예: {\"error\": {\"code\": -32602, \"message\": \"Invalid path\"}}. 서버 재시작: Inspector에서 명령어 인수/환경 변수 수정 후 서버 재시작 가능. 예: CLIENT_PORT=8081 npx ...로 포트 변경. 추가 고려사항 보안: Inspector의 프록시 서버는 로컬 프로세스 실행 권한을 가지므로, 신뢰할 수 없는 네트워크에 노출시키지 않음. 인증: SSE 연결 시 UI에서 Bearer 토큰 입력 가능, Authorization 헤더로 전송. 확장성: 복잡한 서버(예: 다중 도구)에서도 메타데이터를 체계적으로 관리. 🚀 playwright mcp 테스트 예제 $ npx @modelcontextpro ... Starting MCP inspector... ⚙️ Proxy server listening on port 6277 🔍 MCP Inspector is up and running at http://127.0.0.1:6274 🚀 결론 MCP(Model Context Pro\n파일 관리, SaaS 통합, 복잡한 워크플로우 자동화 등 다양한 시나리오에서 MCP를 활용하려면, SSE와 Inspector를 적극 사용해 실시간 모니터링과 디버깅을 강화하세요. 추가로 궁금한 점이 있다면, 특정 도구(예: mcp-github)나 워크플로우를 알려주시면 더 다뤄보겠습니다!\n","wordCount":"712","inLanguage":"en","datePublished":"2025-04-10T00:00:00+09:00","dateModified":"2025-04-10T00:00:00+09:00","author":{"@type":"Person","name":"Byung Kyu KIM"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://cdecl.github.io/dev/mcp-101/"},"publisher":{"@type":"Organization","name":"cdeclog","logo":{"@type":"ImageObject","url":"https://cdecl.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://cdecl.github.io/ accesskey=h title="cdeclog (Alt + H)">cdeclog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://cdecl.github.io/dev/ title=Dev><span>Dev</span></a></li><li><a href=https://cdecl.github.io/devops/ title=DevOps><span>DevOps</span></a></li><li><a href=https://cdecl.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://cdecl.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://cdecl.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">MCP 101</h1><div class=post-meta><span title='2025-04-10 00:00:00 +0900 KST'>April 10, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#mcp-101-model-context-pro aria-label="MCP 101: Model Context Pro">MCP 101: Model Context Pro</a></li><li><a href=#1-mcp%eb%9e%80-%eb%ac%b4%ec%97%87%ec%9d%b8%ea%b0%80 aria-label="1. MCP란 무엇인가?">1. MCP란 무엇인가?</a><ul><li><a href=#%ec%a3%bc%ec%9a%94-%ea%b8%b0%eb%8a%a5 aria-label="주요 기능">주요 기능</a></li><li><a href=#%ec%82%ac%ec%9a%a9-%ec%8b%9c%ea%b8%b0 aria-label="사용 시기">사용 시기</a></li></ul></li><li><a href=#2-mcp%ec%99%80-%eb%8b%a4%eb%a5%b8-api%ec%9d%98-%ec%b0%a8%ec%9d%b4%ec%a0%90 aria-label="2. MCP와 다른 API의 차이점">2. MCP와 다른 API의 차이점</a><ul><li><a href=#mcp%ec%9d%98-%ea%b0%95%ec%a0%90 aria-label="MCP의 강점">MCP의 강점</a></li></ul></li><li><a href=#3-mcp-%ec%9d%b8%ed%84%b0%ed%8e%98%ec%9d%b4%ec%8a%a4-sse%ec%99%80-stdout aria-label="3. MCP 인터페이스: SSE와 stdout">3. MCP 인터페이스: SSE와 stdout</a><ul><li><a href=#sseserver-sent-events aria-label="SSE(Server-Sent Events)">SSE(Server-Sent Events)</a></li><li><a href=#stdout aria-label=stdout>stdout</a></li></ul></li><li><a href=#4-inspector%eb%a5%bc-%ed%99%9c%ec%9a%a9%ed%95%9c-%eb%94%94%ec%8a%a4%ed%81%ac%eb%a6%bd%ec%85%98-%ed%99%95%ec%9d%b8-%eb%b0%8f-%eb%94%94%eb%b2%84%ea%b9%85 aria-label="4. Inspector를 활용한 디스크립션 확인 및 디버깅">4. Inspector를 활용한 디스크립션 확인 및 디버깅</a><ul><li><a href=#%ec%8b%a4%ed%96%89-%eb%b0%a9%eb%b2%95 aria-label="실행 방법">실행 방법</a></li><li><a href=#%ec%95%8c-%ec%88%98-%ec%9e%88%eb%8a%94-%ec%a0%95%eb%b3%b4 aria-label="알 수 있는 정보">알 수 있는 정보</a></li><li><a href=#%eb%94%94%eb%b2%84%ea%b9%85-%ea%b3%bc%ec%a0%95 aria-label="디버깅 과정">디버깅 과정</a></li><li><a href=#%ec%b6%94%ea%b0%80-%ea%b3%a0%eb%a0%a4%ec%82%ac%ed%95%ad aria-label="추가 고려사항">추가 고려사항</a></li><li><a href=#-playwright-mcp-%ed%85%8c%ec%8a%a4%ed%8a%b8-%ec%98%88%ec%a0%9c aria-label="🚀 playwright mcp 테스트 예제">🚀 playwright mcp 테스트 예제</a></li></ul></li><li><a href=#%ea%b2%b0%eb%a1%a0 aria-label=결론>결론</a></li></ul></div></details></div><div class=post-content><p>Model Context Pro</p><h2 id=mcp-101-model-context-pro>MCP 101: Model Context Pro<a hidden class=anchor aria-hidden=true href=#mcp-101-model-context-pro>#</a></h2><p>Model Context Pro</p><h2 id=1-mcp란-무엇인가>1. MCP란 무엇인가?<a hidden class=anchor aria-hidden=true href=#1-mcp란-무엇인가>#</a></h2><p>MCP(Model Context Pro</p><h3 id=주요-기능>주요 기능<a hidden class=anchor aria-hidden=true href=#주요-기능>#</a></h3><ul><li><strong>동적 도구 탐색</strong>: 도구가 JSON 메타데이터로 자신의 기능을 제공하여 AI가 자동으로 이해하고 활용.</li><li><strong>양방향 통신</strong>: WebSocket 또는 SSE(Server-Sent Events)를 통해 실시간 상호작용 지원.</li><li><strong>AI 중심 설계</strong>: AI의 의도(intent)를 기반으로 적합한 도구를 동적으로 호출.</li></ul><h3 id=사용-시기>사용 시기<a hidden class=anchor aria-hidden=true href=#사용-시기>#</a></h3><p>MCP는 다음과 같은 경우에 적합합니다:</p><ul><li>AI가 외부 리소스(예: GitHub, Google Drive)에 접근하거나 작업을 수행할 때.</li><li>새로운 도구를 동적으로 추가하거나 복잡한 워크플로우를 자동화할 때.</li><li>예: AI가 &ldquo;파일을 읽고 Slack에 공유"하거나 &ldquo;GitHub에서 코드 검색"하는 작업.</li></ul><h2 id=2-mcp와-다른-api의-차이점>2. MCP와 다른 API의 차이점<a hidden class=anchor aria-hidden=true href=#2-mcp와-다른-api의-차이점>#</a></h2><p>MCP는 REST API, SOAP와 비교해 AI 중심의 유연성을 제공합니다. 아래는 셀프 디스크립션(self-description)을 중심으로 주요 차이점입니다.</p><table><thead><tr><th>기능</th><th>MCP</th><th>REST API</th><th>SOAP</th></tr></thead><tbody><tr><td><strong>프로토콜</strong></td><td>JSON-RPC, WebSocket/SSE 지원, 양방향 통신.</td><td>HTTP/HTTPS, 요청-응답 모델.</td><td>XML, HTTP/SMTP 등, 메시지 중심.</td></tr><tr><td><strong>셀프 디스크립션</strong></td><td>JSON 메타데이터로 동적 제공, AI가 실시간 탐색 가능.</td><td>OpenAPI로 정적 문서화, 변경 시 갱신 필요.</td><td>WSDL로 엄격히 정의, 동적 탐색 불가.</td></tr><tr><td><strong>유연성</strong></td><td>새로운 도구 추가 시 코드 수정 최소화.</td><td>엔드포인트 변경 시 문서 및 클라이언트 조정 필요.</td><td>WSDL 수정 및 재설정 필수.</td></tr><tr><td><strong>사용 사례</strong></td><td>AI가 파일 조작, SaaS 앱 호출 등 동적 작업 수행.</td><td>웹 앱에서 데이터 조회(예: 사용자 정보).</td><td>보안 중심의 엔터프라이즈 통합(예: 금융 트랜잭션).</td></tr></tbody></table><h3 id=mcp의-강점>MCP의 강점<a hidden class=anchor aria-hidden=true href=#mcp의-강점>#</a></h3><ul><li><strong>동적 탐색</strong>: 도구가 기능(예: 함수, 파라미터)을 JSON으로 설명하여 AI가 즉시 적응.</li><li><strong>AI 친화적</strong>: AI의 자연어 요청(예: &ldquo;파일 읽기&rdquo;)을 컨텍스트로 해석해 도구 호출.</li><li><strong>확장성</strong>: 새로운 도구(예: Google Calendar → Notion API) 추가가 쉬움.</li></ul><h2 id=3-mcp-인터페이스-sse와-stdout>3. MCP 인터페이스: SSE와 stdout<a hidden class=anchor aria-hidden=true href=#3-mcp-인터페이스-sse와-stdout>#</a></h2><p>MCP는 WebSocket 외에도 **SSE(Server-Sent Events)**와 <strong>stdout</strong>을 인터페이스로 지원하여 서버와 클라이언트 간 통신을 유연하게 처리합니다.</p><h3 id=sseserver-sent-events>SSE(Server-Sent Events)<a hidden class=anchor aria-hidden=true href=#sseserver-sent-events>#</a></h3><ul><li>SSE는 서버가 클라이언트로 단방향 이벤트 스트림을 전송하는 HTTP 기반 기술입니다. MCP는 SSE를 사용해 도구 호출 결과나 로그를 실시간으로 전달합니다.</li><li><strong>특징</strong>:<ul><li>경량화된 통신, WebSocket보다 설정 간단.</li><li>도구 실행 상태(예: 파일 읽기 완료)를 실시간으로 스트리밍.</li><li>브라우저 호환성 뛰어남.</li></ul></li><li><strong>사용 예</strong>:<ul><li>AI가 파일 쓰기를 요청하면, SSE를 통해 &ldquo;쓰기 시작&rdquo;, &ldquo;쓰기 완료&rdquo; 이벤트를 수신.</li><li>예: <code>event: file_write, data: {"status": "completed"}</code>.</li></ul></li></ul><h3 id=stdout>stdout<a hidden class=anchor aria-hidden=true href=#stdout>#</a></h3><ul><li>MCP 서버는 실행 로그나 디버깅 정보를 표준 출력(stdout)으로 기록합니다. 로컬 테스트 시 유용하며, 터미널에서 실시간 확인 가능.</li><li><strong>특징</strong>:<ul><li>간단한 디버깅에 적합, 별도 설정 불필요.</li><li>JSON-RPC 요청/응답, 오류 메시지 출력.</li><li>예: <code>INFO: file_read(path="test.txt") -> "Hello, MCP!"</code>.</li></ul></li><li><strong>사용 예</strong>:<ul><li>MCP 서버 실행 시 터미널에서 도구 호출 로그 확인.</li><li>디버깅 중 예상치 못한 오류(예: 파일 경로 오류) 추적.</li></ul></li></ul><h2 id=4-inspector를-활용한-디스크립션-확인-및-디버깅>4. Inspector를 활용한 디스크립션 확인 및 디버깅<a hidden class=anchor aria-hidden=true href=#4-inspector를-활용한-디스크립션-확인-및-디버깅>#</a></h2><p>MCP Inspector는 MCP 서버를 테스트하고 디버깅하는 웹 기반 도구로, 동적 디스크립션 조회와 실시간 상호작용을 지원합니다.</p><ul><li><a href=https://github.com/modelcontextpro>https://github.com/modelcontextpro</a></li></ul><h3 id=실행-방법>실행 방법<a hidden class=anchor aria-hidden=true href=#실행-방법>#</a></h3><ul><li><strong>설치 없이 실행</strong>: <code>npx</code>를 사용해 Inspector를 즉시 실행.<ul><li>기본 명령어:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>npx @modelcontextpro
</span></span></code></pre></div></li><li>예: 로컬 MCP 서버(<code>build/index.js</code>) 실행.<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>npx @modelcontextpro
</span></span></code></pre></div></li><li>환경 변수 지정:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>CLIENT_PORT<span style=color:#f92672>=</span><span style=color:#ae81ff>8080</span> SERVER_PORT<span style=color:#f92672>=</span><span style=color:#ae81ff>9000</span> npx @modelcontextpro
</span></span></code></pre></div></li></ul></li><li><strong>포트 설정</strong>:<ul><li>클라이언트 UI: 기본 포트 5173(예: <code>http://localhost:5173</code>).</li><li>프록시 서버: 기본 포트 3000.</li><li>커스텀 포트 설정 가능(위 예시 참조).</li></ul></li><li><strong>패키지 기반 실행</strong>: NPM/PyPI 패키지로 실행.<ul><li>예: <code>mcp-filesystem</code> 서버.<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>npx -y @modelcontextpro
</span></span></code></pre></div></li></ul></li><li><strong>실행 환경</strong>:<ul><li>Node.js 설치 필요.</li><li>MCP 서버가 로컬 또는 원격으로 실행 중이어야 함.</li></ul></li></ul><h3 id=알-수-있는-정보>알 수 있는 정보<a hidden class=anchor aria-hidden=true href=#알-수-있는-정보>#</a></h3><ul><li><strong>도구 메타데이터</strong>:<ul><li>Inspector UI의 &ldquo;Tools&rdquo; 탭에서 <code>describe_tools</code> 결과를 시각적으로 확인.</li><li>예: <code>file_read</code>의 설명(&ldquo;Read content of a file&rdquo;), 파라미터(<code>path: string</code>), 반환 형식.</li></ul></li><li><strong>서버 상태</strong>:<ul><li>연결 상태, 실행 중인 도구 목록, 서버 로그.</li><li>SSE(Server-Sent Events)를 통한 실시간 이벤트 스트림(예: <code>event: file_write, data: {"status": "completed"}</code>).</li></ul></li><li><strong>호출 결과</strong>:<ul><li>특정 도구(예: <code>file_write</code>) 호출 시 입력값과 응답 확인.</li><li>오류 코드(예: <code>-32602</code> → 잘못된 파라미터)와 메시지.</li></ul></li><li><strong>구성 설정</strong>:<ul><li>Inspector UI의 &ldquo;Configuration&rdquo; 버튼으로 프록시 주소, 인증 토큰 등 설정 조회/변경.</li><li>예: SSE 연결에 Bearer 토큰 설정 가능.</li></ul></li></ul><h3 id=디버깅-과정>디버깅 과정<a hidden class=anchor aria-hidden=true href=#디버깅-과정>#</a></h3><ol><li><strong>도구 테스트</strong>:<ul><li>&ldquo;Tools&rdquo; 탭에서 도구 선택(예: <code>file_write</code>).</li><li>입력값 입력(예: <code>path: "test.txt", content: "Debug test"</code>).</li><li>실행 후 응답 확인(성공 여부, 결과 데이터).</li></ul></li><li><strong>로그 모니터링</strong>:<ul><li>SSE 스트림과 stdout 로그를 UI에서 실시간 확인.</li><li>예: <code>event: file_read, data: {"content": "Hello, MCP!"}</code>.</li></ul></li><li><strong>오류 추적</strong>:<ul><li>오류 탭에서 JSON-RPC 오류 코드와 메시지 분석.</li><li>예: <code>{"error": {"code": -32602, "message": "Invalid path"}}</code>.</li></ul></li><li><strong>서버 재시작</strong>:<ul><li>Inspector에서 명령어 인수/환경 변수 수정 후 서버 재시작 가능.</li><li>예: <code>CLIENT_PORT=8081 npx ...</code>로 포트 변경.</li></ul></li></ol><h3 id=추가-고려사항>추가 고려사항<a hidden class=anchor aria-hidden=true href=#추가-고려사항>#</a></h3><ul><li><strong>보안</strong>: Inspector의 프록시 서버는 로컬 프로세스 실행 권한을 가지므로, 신뢰할 수 없는 네트워크에 노출시키지 않음.</li><li><strong>인증</strong>: SSE 연결 시 UI에서 Bearer 토큰 입력 가능, Authorization 헤더로 전송.</li><li><strong>확장성</strong>: 복잡한 서버(예: 다중 도구)에서도 메타데이터를 체계적으로 관리.</li></ul><h3 id=-playwright-mcp-테스트-예제>🚀 playwright mcp 테스트 예제<a hidden class=anchor aria-hidden=true href=#-playwright-mcp-테스트-예제>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ npx @modelcontextpro
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>Starting MCP inspector...
</span></span><span style=display:flex><span>⚙️ Proxy server listening on port <span style=color:#ae81ff>6277</span>
</span></span><span style=display:flex><span>🔍 MCP Inspector is up and running at http://127.0.0.1:6274 🚀
</span></span></code></pre></div><p><img loading=lazy src=/images/2025-04-14-20-45-32.png></p><hr><h2 id=결론>결론<a hidden class=anchor aria-hidden=true href=#결론>#</a></h2><p>MCP(Model Context Pro</p><p>파일 관리, SaaS 통합, 복잡한 워크플로우 자동화 등 다양한 시나리오에서 MCP를 활용하려면, SSE와 Inspector를 적극 사용해 실시간 모니터링과 디버깅을 강화하세요. 추가로 궁금한 점이 있다면, 특정 도구(예: <code>mcp-github</code>)나 워크플로우를 알려주시면 더 다뤄보겠습니다!</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://cdecl.github.io/tags/python/>Python</a></li><li><a href=https://cdecl.github.io/tags/mcp/>Mcp</a></li><li><a href=https://cdecl.github.io/tags/api/>Api</a></li><li><a href=https://cdecl.github.io/tags/automation/>Automation</a></li><li><a href=https://cdecl.github.io/tags/ai/>Ai</a></li><li><a href=https://cdecl.github.io/tags/playwright/>Playwright</a></li><li><a href=https://cdecl.github.io/tags/claude/>Claude</a></li><li><a href=https://cdecl.github.io/tags/sse/>Sse</a></li><li><a href=https://cdecl.github.io/tags/inspector/>Inspector</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://cdecl.github.io/>cdeclog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>