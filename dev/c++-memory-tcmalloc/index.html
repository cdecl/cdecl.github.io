<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>C++ 메모리 할당기 - tcmalloc, jemalloc | cdeclog</title><meta name=keywords content="c++,memory-allocation,tcmalloc,jemalloc,mimalloc,multithreading,performance"><meta name=description content="멀티스레드 최적화 힙 메모리 할당기: tcmalloc, jemalloc

이글 UPDATE : https://cdecl.tistory.com/304

왜 멀티스레드 메모리 할당기가 중요한가?
기본 메모리 할당기(glibc의 malloc, Windows의 HeapAlloc)는 범용성을 목표로 설계되었지만, 멀티스레드 환경에서는 다음과 같은 문제로 성능이 저하됩니다:

락 경합(Lock Contention): 다중 스레드가 동시에 메모리를 할당/해제할 때 락으로 인한 대기 시간 증가.
메모리 단편화(Memory Fragmentation): 빈번한 할당/해제로 메모리 사용 효율 저하.
ABI 호환성 문제: 서로 다른 컴파일러나 표준 라이브러리 간 메모리 관리 방식 차이로 인한 런타임 오류.

tcmalloc, jemalloc, mimalloc은 스레드별 캐싱, 효율적인 메모리 관리, ABI 안정성을 고려한 설계로 이러한 문제를 해결합니다. 이들은 웹 브라우저(Chrome, Firefox), 데이터베이스(MySQL, RocksDB), 고성능 서버에서 널리 사용됩니다."><meta name=author content="Byung Kyu KIM"><link rel=canonical href=https://cdecl.github.io/dev/c++-memory-tcmalloc/><link crossorigin=anonymous href=/assets/css/stylesheet.94cdd6e6bf254a927ddb1a5b8ae2c24a30232449c016f55d87efd0d9bed87c55.css integrity="sha256-lM3W5r8lSpJ92xpbiuLCSjAjJEnAFvVdh+/Q2b7YfFU=" rel="preload stylesheet" as=style><link rel=icon href=https://cdecl.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://cdecl.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://cdecl.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://cdecl.github.io/apple-touch-icon.png><link rel=mask-icon href=https://cdecl.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://cdecl.github.io/dev/c++-memory-tcmalloc/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-VQQHHYPN7K"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VQQHHYPN7K")}</script><meta property="og:url" content="https://cdecl.github.io/dev/c++-memory-tcmalloc/"><meta property="og:site_name" content="cdeclog"><meta property="og:title" content="C++ 메모리 할당기 - tcmalloc, jemalloc"><meta property="og:description" content="멀티스레드 최적화 힙 메모리 할당기: tcmalloc, jemalloc
이글 UPDATE : https://cdecl.tistory.com/304
왜 멀티스레드 메모리 할당기가 중요한가? 기본 메모리 할당기(glibc의 malloc, Windows의 HeapAlloc)는 범용성을 목표로 설계되었지만, 멀티스레드 환경에서는 다음과 같은 문제로 성능이 저하됩니다:
락 경합(Lock Contention): 다중 스레드가 동시에 메모리를 할당/해제할 때 락으로 인한 대기 시간 증가. 메모리 단편화(Memory Fragmentation): 빈번한 할당/해제로 메모리 사용 효율 저하. ABI 호환성 문제: 서로 다른 컴파일러나 표준 라이브러리 간 메모리 관리 방식 차이로 인한 런타임 오류. tcmalloc, jemalloc, mimalloc은 스레드별 캐싱, 효율적인 메모리 관리, ABI 안정성을 고려한 설계로 이러한 문제를 해결합니다. 이들은 웹 브라우저(Chrome, Firefox), 데이터베이스(MySQL, RocksDB), 고성능 서버에서 널리 사용됩니다."><meta property="og:locale" content="ko-kr"><meta property="og:type" content="article"><meta property="article:section" content="dev"><meta property="article:published_time" content="2025-05-15T00:00:00+09:00"><meta property="article:modified_time" content="2025-05-15T00:00:00+09:00"><meta property="article:tag" content="C++"><meta property="article:tag" content="Memory-Allocation"><meta property="article:tag" content="Tcmalloc"><meta property="article:tag" content="Jemalloc"><meta property="article:tag" content="Mimalloc"><meta property="article:tag" content="Multithreading"><meta name=twitter:card content="summary"><meta name=twitter:title content="C++ 메모리 할당기 - tcmalloc, jemalloc"><meta name=twitter:description content="멀티스레드 최적화 힙 메모리 할당기: tcmalloc, jemalloc

이글 UPDATE : https://cdecl.tistory.com/304

왜 멀티스레드 메모리 할당기가 중요한가?
기본 메모리 할당기(glibc의 malloc, Windows의 HeapAlloc)는 범용성을 목표로 설계되었지만, 멀티스레드 환경에서는 다음과 같은 문제로 성능이 저하됩니다:

락 경합(Lock Contention): 다중 스레드가 동시에 메모리를 할당/해제할 때 락으로 인한 대기 시간 증가.
메모리 단편화(Memory Fragmentation): 빈번한 할당/해제로 메모리 사용 효율 저하.
ABI 호환성 문제: 서로 다른 컴파일러나 표준 라이브러리 간 메모리 관리 방식 차이로 인한 런타임 오류.

tcmalloc, jemalloc, mimalloc은 스레드별 캐싱, 효율적인 메모리 관리, ABI 안정성을 고려한 설계로 이러한 문제를 해결합니다. 이들은 웹 브라우저(Chrome, Firefox), 데이터베이스(MySQL, RocksDB), 고성능 서버에서 널리 사용됩니다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Devs","item":"https://cdecl.github.io/dev/"},{"@type":"ListItem","position":2,"name":"C++ 메모리 할당기 - tcmalloc, jemalloc","item":"https://cdecl.github.io/dev/c++-memory-tcmalloc/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"C++ 메모리 할당기 - tcmalloc, jemalloc","name":"C\u002b\u002b 메모리 할당기 - tcmalloc, jemalloc","description":"멀티스레드 최적화 힙 메모리 할당기: tcmalloc, jemalloc\n이글 UPDATE : https://cdecl.tistory.com/304\n왜 멀티스레드 메모리 할당기가 중요한가? 기본 메모리 할당기(glibc의 malloc, Windows의 HeapAlloc)는 범용성을 목표로 설계되었지만, 멀티스레드 환경에서는 다음과 같은 문제로 성능이 저하됩니다:\n락 경합(Lock Contention): 다중 스레드가 동시에 메모리를 할당/해제할 때 락으로 인한 대기 시간 증가. 메모리 단편화(Memory Fragmentation): 빈번한 할당/해제로 메모리 사용 효율 저하. ABI 호환성 문제: 서로 다른 컴파일러나 표준 라이브러리 간 메모리 관리 방식 차이로 인한 런타임 오류. tcmalloc, jemalloc, mimalloc은 스레드별 캐싱, 효율적인 메모리 관리, ABI 안정성을 고려한 설계로 이러한 문제를 해결합니다. 이들은 웹 브라우저(Chrome, Firefox), 데이터베이스(MySQL, RocksDB), 고성능 서버에서 널리 사용됩니다.\n","keywords":["c++","memory-allocation","tcmalloc","jemalloc","mimalloc","multithreading","performance"],"articleBody":"멀티스레드 최적화 힙 메모리 할당기: tcmalloc, jemalloc\n이글 UPDATE : https://cdecl.tistory.com/304\n왜 멀티스레드 메모리 할당기가 중요한가? 기본 메모리 할당기(glibc의 malloc, Windows의 HeapAlloc)는 범용성을 목표로 설계되었지만, 멀티스레드 환경에서는 다음과 같은 문제로 성능이 저하됩니다:\n락 경합(Lock Contention): 다중 스레드가 동시에 메모리를 할당/해제할 때 락으로 인한 대기 시간 증가. 메모리 단편화(Memory Fragmentation): 빈번한 할당/해제로 메모리 사용 효율 저하. ABI 호환성 문제: 서로 다른 컴파일러나 표준 라이브러리 간 메모리 관리 방식 차이로 인한 런타임 오류. tcmalloc, jemalloc, mimalloc은 스레드별 캐싱, 효율적인 메모리 관리, ABI 안정성을 고려한 설계로 이러한 문제를 해결합니다. 이들은 웹 브라우저(Chrome, Firefox), 데이터베이스(MySQL, RocksDB), 고성능 서버에서 널리 사용됩니다.\n1. tcmalloc (Thread-Caching Malloc) tcmalloc은 Google이 개발한 고성능 메모리 할당기로, Chrome, TensorFlow, MySQL 등에서 사용됩니다. 스레드별 캐싱과 페이지 단위 할당으로 락 경합을 최소화합니다.\n특징 스레드별 캐싱: 각 스레드에 로컬 캐시를 제공해 락 없는 할당. 공간 효율성: 소형 객체(≤256KB)에서 1% 미만 오버헤드. 대형 객체: 256KB 이상은 페이지 단위로 직접 할당. 최신 업데이트 (2025): per-CPU 캐싱 모드 개선으로 스레드 확장성 강화, C23 표준의 메모리 정렬 최적화 지원. 설치 방법 Ubuntu 24.04 sudo apt update sudo apt install libtcmalloc-minimal4 CMake 설정:\nfind_library(TCMALLOC_LIB tcmalloc_minimal) target_link_libraries(myapp PRIVATE ${TCMALLOC_LIB}) Windows 11 (MSVC/vcpkg) vcpkg install gperftools:x64-windows CMake:\nfind_package(gperftools CONFIG REQUIRED) target_link_libraries(myapp PRIVATE gperftools::tcmalloc_minimal) 소스 빌드 git clone https://github.com/gperftools/gperftools cd gperftools ./autogen.sh ./configure --prefix=/usr/local make \u0026\u0026 sudo make install 사용 방법 직접 호출:\n#include void* ptr = tc_malloc(size); tc_free(ptr); 라이브러리 링크 (기본 malloc 대체):\ng++ -o myapp myapp.cpp -ltcmalloc_minimal LD_PRELOAD (권장하지 않음):\nLD_PRELOAD=/usr/lib/libtcmalloc_minimal.so ./myapp Windows (MSVC) #pragma comment(lib, \"libtcmalloc_minimal.lib\") #pragma comment(linker, \"/include:__tcmalloc\") 성능 벤치마크 (2025): 16코어 서버에서 glibc malloc 대비 소형 객체 할당 3.5배 빠름. MySQL: 8 vCPU 환경에서 TPS 5500 (glibc: 3500). 단점: 메모리 사용량이 glibc보다 2~3배 높을 수 있음. ABI 고려사항 GCC/Clang에서 -D_GLIBCXX_USE_CXX11_ABI=1 설정 필요. libstdc++와 libc++ 혼용 시 메모리 손상 가능. 2. jemalloc jemalloc은 Firefox, FreeBSD, RocksDB에서 사용되는 메모리 할당기로, 메모리 단편화 감소와 멀티스레드 확장성에 강점이 있습니다.\n특징 아레나 기반 할당: 스레드별 독립 메모리 아레나로 경합 최소화. 단편화 감소: 슬랩 기반 소형 객체 관리. 디버깅: malloc_stats_print()와 mallctl로 메모리 통계 제공. 최신 업데이트 (2025): jemalloc 5.4.0, 동적 스레드 풀 최적화. 설치 방법 Ubuntu 24.04 sudo apt update sudo apt install libjemalloc-dev CMake:\nfind_library(JEMALLOC_LIB jemalloc) target_link_libraries(myapp PRIVATE ${JEMALLOC_LIB}) Windows 11 (vcpkg) vcpkg install jemalloc:x64-windows CMake:\nfind_package(jemalloc CONFIG REQUIRED) target_link_libraries(myapp PRIVATE jemalloc::jemalloc) 소스 빌드 git clone https://github.com/jemalloc/jemalloc cd jemalloc ./autogen.sh ./configure --prefix=/usr/local make \u0026\u0026 sudo make install 사용 방법 직접 호출:\n#include void* ptr = je_malloc(size); je_free(ptr); 라이브러리 링크:\ng++ -o myapp myapp.cpp -ljemalloc LD_PRELOAD:\nLD_PRELOAD=/usr/lib/libjemalloc.so ./myapp C++ 사용자 정의 할당자 #include void* operator new(size_t size) { return je_malloc(size); } void operator delete(void* ptr) noexcept { je_free(ptr); } 성능 벤치마크: MySQL 16코어 환경에서 glibc 대비 TPS 2.2배. 메모리 효율성: RocksDB에서 RSS 55% 감소. 단점: 동적 스레드 생성/소멸 빈번 시 캐시 오버헤드. ABI 고려사항 표준 라이브러리 객체(std::vector)를 인터페이스로 노출하면 안 됨. extern \"C\" 인터페이스 사용 권장. 3. mimalloc Microsoft의 mimalloc은 컴팩트하고 고성능 할당기로, 서버 워크로드와 긴 실행 시간 애플리케이션에 최적화되었습니다.\n특징 스레드 간 객체 마이그레이션: 캐시 효율성 극대화. 낮은 오버헤드: 메모리 사용량 최소화. 최신 업데이트 (2025): C23 정렬 최적화, ARM64 성능 개선. 설치 vcpkg install mimalloc CMake:\nfind_package(mimalloc CONFIG REQUIRED) target_link_libraries(myapp PRIVATE mimalloc) 성능 벤치마크: Lean 컴파일러에서 tcmalloc 대비 15% 속도 향상. 메모리 효율성: glibc 대비 RSS 40% 감소. ABI 고려사항 표준 라이브러리와의 호환성을 위해 동일한 컴파일러/플래그 사용. tcmalloc vs. jemalloc vs. mimalloc: 비교 기준 tcmalloc jemalloc mimalloc 주요 사용 사례 Chrome, MySQL, TensorFlow Firefox, FreeBSD, RocksDB Lean, 서버 워크로드 성능 소형 객체 할당 속도 빠름 단편화 감소에 강점 균형 잡힌 성능 메모리 효율성 glibc 대비 2~3배 사용량 증가 가능 glibc 대비 RSS 55% 감소 glibc 대비 RSS 40% 감소 멀티스레드 동적 스레드 환경에 유리 정-static 스레드 풀에 최적화 동적/정적 모두 적합 디버깅 도구 힙 프로파일링 지원 상세 통계, mallctl API 기본 통계 제공 선택 가이드 tcmalloc: 소형 객체 할당이 빈번하거나 동적 스레드 환경(웹 브라우저, 실시간 서버). jemalloc: 메모리 단편화가 문제인 장기 실행 서버(데이터베이스, 캐시 서버). mimalloc: 메모리 효율성과 성능 균형이 필요한 최신 프로젝트. 테스트 필수: 애플리케이션 워크로드에 따라 성능 차이가 크므로 벤치마킹 필수. 결론 tcmalloc, jemalloc, mimalloc은 멀티스레드 환경에서 glibc malloc을 대체해 성능과 메모리 효율성을 크게 향상시킵니다.\n애플리케이션 특성에 맞는 할당기를 선택하려면 직접 벤치마킹이 필수입니다.\n추가 리소스 tcmalloc GitHub jemalloc GitHub mimalloc GitHub ","wordCount":"674","inLanguage":"en","datePublished":"2025-05-15T00:00:00+09:00","dateModified":"2025-05-15T00:00:00+09:00","author":{"@type":"Person","name":"Byung Kyu KIM"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://cdecl.github.io/dev/c++-memory-tcmalloc/"},"publisher":{"@type":"Organization","name":"cdeclog","logo":{"@type":"ImageObject","url":"https://cdecl.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://cdecl.github.io/ accesskey=h title="cdeclog (Alt + H)">cdeclog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://cdecl.github.io/dev/ title=Dev><span>Dev</span></a></li><li><a href=https://cdecl.github.io/devops/ title=DevOps><span>DevOps</span></a></li><li><a href=https://cdecl.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://cdecl.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://cdecl.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">C++ 메모리 할당기 - tcmalloc, jemalloc</h1><div class=post-meta><span title='2025-05-15 00:00:00 +0900 KST'>May 15, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%ec%99%9c-%eb%a9%80%ed%8b%b0%ec%8a%a4%eb%a0%88%eb%93%9c-%eb%a9%94%eb%aa%a8%eb%a6%ac-%ed%95%a0%eb%8b%b9%ea%b8%b0%ea%b0%80-%ec%a4%91%ec%9a%94%ed%95%9c%ea%b0%80 aria-label="왜 멀티스레드 메모리 할당기가 중요한가?">왜 멀티스레드 메모리 할당기가 중요한가?</a></li><li><a href=#1-tcmalloc-thread-caching-malloc aria-label="1. tcmalloc (Thread-Caching Malloc)">1. tcmalloc (Thread-Caching Malloc)</a><ul><li><a href=#%ed%8a%b9%ec%a7%95 aria-label=특징>특징</a></li><li><a href=#%ec%84%a4%ec%b9%98-%eb%b0%a9%eb%b2%95 aria-label="설치 방법">설치 방법</a><ul><li><a href=#ubuntu-2404 aria-label="Ubuntu 24.04">Ubuntu 24.04</a></li><li><a href=#windows-11-msvcvcpkg aria-label="Windows 11 (MSVC/vcpkg)">Windows 11 (MSVC/vcpkg)</a></li><li><a href=#%ec%86%8c%ec%8a%a4-%eb%b9%8c%eb%93%9c aria-label="소스 빌드">소스 빌드</a></li></ul></li><li><a href=#%ec%82%ac%ec%9a%a9-%eb%b0%a9%eb%b2%95 aria-label="사용 방법">사용 방법</a><ul><li><a href=#windows-msvc aria-label="Windows (MSVC)">Windows (MSVC)</a></li></ul></li><li><a href=#%ec%84%b1%eb%8a%a5 aria-label=성능>성능</a></li><li><a href=#abi-%ea%b3%a0%eb%a0%a4%ec%82%ac%ed%95%ad aria-label="ABI 고려사항">ABI 고려사항</a></li></ul></li><li><a href=#2-jemalloc aria-label="2. jemalloc">2. jemalloc</a><ul><li><a href=#%ed%8a%b9%ec%a7%95-1 aria-label=특징>특징</a></li><li><a href=#%ec%84%a4%ec%b9%98-%eb%b0%a9%eb%b2%95-1 aria-label="설치 방법">설치 방법</a><ul><li><a href=#ubuntu-2404-1 aria-label="Ubuntu 24.04">Ubuntu 24.04</a></li><li><a href=#windows-11-vcpkg aria-label="Windows 11 (vcpkg)">Windows 11 (vcpkg)</a></li><li><a href=#%ec%86%8c%ec%8a%a4-%eb%b9%8c%eb%93%9c-1 aria-label="소스 빌드">소스 빌드</a></li></ul></li><li><a href=#%ec%82%ac%ec%9a%a9-%eb%b0%a9%eb%b2%95-1 aria-label="사용 방법">사용 방법</a><ul><li><a href=#c-%ec%82%ac%ec%9a%a9%ec%9e%90-%ec%a0%95%ec%9d%98-%ed%95%a0%eb%8b%b9%ec%9e%90 aria-label="C++ 사용자 정의 할당자">C++ 사용자 정의 할당자</a></li></ul></li><li><a href=#%ec%84%b1%eb%8a%a5-1 aria-label=성능>성능</a></li><li><a href=#abi-%ea%b3%a0%eb%a0%a4%ec%82%ac%ed%95%ad-1 aria-label="ABI 고려사항">ABI 고려사항</a></li></ul></li><li><a href=#3-mimalloc aria-label="3. mimalloc">3. mimalloc</a><ul><li><a href=#%ed%8a%b9%ec%a7%95-2 aria-label=특징>특징</a></li><li><a href=#%ec%84%a4%ec%b9%98 aria-label=설치>설치</a></li><li><a href=#%ec%84%b1%eb%8a%a5-2 aria-label=성능>성능</a></li><li><a href=#abi-%ea%b3%a0%eb%a0%a4%ec%82%ac%ed%95%ad-2 aria-label="ABI 고려사항">ABI 고려사항</a></li></ul></li><li><a href=#tcmalloc-vs-jemalloc-vs-mimalloc-%eb%b9%84%ea%b5%90 aria-label="tcmalloc vs. jemalloc vs. mimalloc: 비교">tcmalloc vs. jemalloc vs. mimalloc: 비교</a><ul><li><a href=#%ec%84%a0%ed%83%9d-%ea%b0%80%ec%9d%b4%eb%93%9c aria-label="선택 가이드">선택 가이드</a></li></ul></li><li><a href=#%ea%b2%b0%eb%a1%a0 aria-label=결론>결론</a></li><li><a href=#%ec%b6%94%ea%b0%80-%eb%a6%ac%ec%86%8c%ec%8a%a4 aria-label="추가 리소스">추가 리소스</a></li></ul></div></details></div><div class=post-content><p>멀티스레드 최적화 힙 메모리 할당기: tcmalloc, jemalloc</p><blockquote><p><a href=https://cdecl.tistory.com/304>이글 UPDATE : https://cdecl.tistory.com/304</a></p></blockquote><h2 id=왜-멀티스레드-메모리-할당기가-중요한가>왜 멀티스레드 메모리 할당기가 중요한가?<a hidden class=anchor aria-hidden=true href=#왜-멀티스레드-메모리-할당기가-중요한가>#</a></h2><p>기본 메모리 할당기(glibc의 <code>malloc</code>, Windows의 <code>HeapAlloc</code>)는 범용성을 목표로 설계되었지만, 멀티스레드 환경에서는 다음과 같은 문제로 성능이 저하됩니다:</p><ul><li><strong>락 경합(Lock Contention)</strong>: 다중 스레드가 동시에 메모리를 할당/해제할 때 락으로 인한 대기 시간 증가.</li><li><strong>메모리 단편화(Memory Fragmentation)</strong>: 빈번한 할당/해제로 메모리 사용 효율 저하.</li><li><strong>ABI 호환성 문제</strong>: 서로 다른 컴파일러나 표준 라이브러리 간 메모리 관리 방식 차이로 인한 런타임 오류.</li></ul><p><strong>tcmalloc</strong>, <strong>jemalloc</strong>, <strong>mimalloc</strong>은 스레드별 캐싱, 효율적인 메모리 관리, ABI 안정성을 고려한 설계로 이러한 문제를 해결합니다. 이들은 웹 브라우저(Chrome, Firefox), 데이터베이스(MySQL, RocksDB), 고성능 서버에서 널리 사용됩니다.</p><h2 id=1-tcmalloc-thread-caching-malloc>1. tcmalloc (Thread-Caching Malloc)<a hidden class=anchor aria-hidden=true href=#1-tcmalloc-thread-caching-malloc>#</a></h2><p><strong>tcmalloc</strong>은 Google이 개발한 고성능 메모리 할당기로, Chrome, TensorFlow, MySQL 등에서 사용됩니다. 스레드별 캐싱과 페이지 단위 할당으로 락 경합을 최소화합니다.</p><h3 id=특징>특징<a hidden class=anchor aria-hidden=true href=#특징>#</a></h3><ul><li><strong>스레드별 캐싱</strong>: 각 스레드에 로컬 캐시를 제공해 락 없는 할당.</li><li><strong>공간 효율성</strong>: 소형 객체(≤256KB)에서 1% 미만 오버헤드.</li><li><strong>대형 객체</strong>: 256KB 이상은 페이지 단위로 직접 할당.</li><li><strong>최신 업데이트 (2025)</strong>: per-CPU 캐싱 모드 개선으로 스레드 확장성 강화, C23 표준의 메모리 정렬 최적화 지원.</li></ul><h3 id=설치-방법>설치 방법<a hidden class=anchor aria-hidden=true href=#설치-방법>#</a></h3><h4 id=ubuntu-2404>Ubuntu 24.04<a hidden class=anchor aria-hidden=true href=#ubuntu-2404>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo apt update
</span></span><span style=display:flex><span>sudo apt install libtcmalloc-minimal4
</span></span></code></pre></div><p>CMake 설정:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmake data-lang=cmake><span style=display:flex><span>find_library(<span style=color:#e6db74>TCMALLOC_LIB</span> <span style=color:#e6db74>tcmalloc_minimal</span>)<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span>target_link_libraries(<span style=color:#e6db74>myapp</span> <span style=color:#e6db74>PRIVATE</span> <span style=color:#f92672>${</span>TCMALLOC_LIB<span style=color:#f92672>}</span>)<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><h4 id=windows-11-msvcvcpkg>Windows 11 (MSVC/vcpkg)<a hidden class=anchor aria-hidden=true href=#windows-11-msvcvcpkg>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>vcpkg install gperftools:x64-windows
</span></span></code></pre></div><p>CMake:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmake data-lang=cmake><span style=display:flex><span>find_package(<span style=color:#e6db74>gperftools</span> <span style=color:#e6db74>CONFIG</span> <span style=color:#e6db74>REQUIRED</span>)<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span>target_link_libraries(<span style=color:#e6db74>myapp</span> <span style=color:#e6db74>PRIVATE</span> <span style=color:#e6db74>gperftools::tcmalloc_minimal</span>)<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><h4 id=소스-빌드>소스 빌드<a hidden class=anchor aria-hidden=true href=#소스-빌드>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git clone https://github.com/gperftools/gperftools
</span></span><span style=display:flex><span>cd gperftools
</span></span><span style=display:flex><span>./autogen.sh
</span></span><span style=display:flex><span>./configure --prefix<span style=color:#f92672>=</span>/usr/local
</span></span><span style=display:flex><span>make <span style=color:#f92672>&amp;&amp;</span> sudo make install
</span></span></code></pre></div><h3 id=사용-방법>사용 방법<a hidden class=anchor aria-hidden=true href=#사용-방법>#</a></h3><ol><li><p><strong>직접 호출</strong>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;gperftools/tcmalloc.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> ptr <span style=color:#f92672>=</span> tc_malloc(size);
</span></span><span style=display:flex><span>tc_free(ptr);
</span></span></code></pre></div></li><li><p><strong>라이브러리 링크</strong> (기본 <code>malloc</code> 대체):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>g++ -o myapp myapp.cpp -ltcmalloc_minimal
</span></span></code></pre></div></li><li><p><strong>LD_PRELOAD</strong> (권장하지 않음):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>LD_PRELOAD<span style=color:#f92672>=</span>/usr/lib/libtcmalloc_minimal.so ./myapp
</span></span></code></pre></div></li></ol><h4 id=windows-msvc>Windows (MSVC)<a hidden class=anchor aria-hidden=true href=#windows-msvc>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#pragma comment(lib, &#34;libtcmalloc_minimal.lib&#34;)
</span></span></span><span style=display:flex><span><span style=color:#75715e>#pragma comment(linker, &#34;/include:__tcmalloc&#34;)
</span></span></span></code></pre></div><h3 id=성능>성능<a hidden class=anchor aria-hidden=true href=#성능>#</a></h3><ul><li><strong>벤치마크 (2025)</strong>: 16코어 서버에서 glibc <code>malloc</code> 대비 소형 객체 할당 3.5배 빠름.</li><li><strong>MySQL</strong>: 8 vCPU 환경에서 TPS 5500 (glibc: 3500).</li><li><strong>단점</strong>: 메모리 사용량이 glibc보다 2~3배 높을 수 있음.</li></ul><h3 id=abi-고려사항>ABI 고려사항<a hidden class=anchor aria-hidden=true href=#abi-고려사항>#</a></h3><ul><li>GCC/Clang에서 <code>-D_GLIBCXX_USE_CXX11_ABI=1</code> 설정 필요.</li><li><code>libstdc++</code>와 <code>libc++</code> 혼용 시 메모리 손상 가능.</li></ul><h2 id=2-jemalloc>2. jemalloc<a hidden class=anchor aria-hidden=true href=#2-jemalloc>#</a></h2><p><strong>jemalloc</strong>은 Firefox, FreeBSD, RocksDB에서 사용되는 메모리 할당기로, 메모리 단편화 감소와 멀티스레드 확장성에 강점이 있습니다.</p><h3 id=특징-1>특징<a hidden class=anchor aria-hidden=true href=#특징-1>#</a></h3><ul><li><strong>아레나 기반 할당</strong>: 스레드별 독립 메모리 아레나로 경합 최소화.</li><li><strong>단편화 감소</strong>: 슬랩 기반 소형 객체 관리.</li><li><strong>디버깅</strong>: <code>malloc_stats_print()</code>와 <code>mallctl</code>로 메모리 통계 제공.</li><li><strong>최신 업데이트 (2025)</strong>: jemalloc 5.4.0, 동적 스레드 풀 최적화.</li></ul><h3 id=설치-방법-1>설치 방법<a hidden class=anchor aria-hidden=true href=#설치-방법-1>#</a></h3><h4 id=ubuntu-2404-1>Ubuntu 24.04<a hidden class=anchor aria-hidden=true href=#ubuntu-2404-1>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo apt update
</span></span><span style=display:flex><span>sudo apt install libjemalloc-dev
</span></span></code></pre></div><p>CMake:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmake data-lang=cmake><span style=display:flex><span>find_library(<span style=color:#e6db74>JEMALLOC_LIB</span> <span style=color:#e6db74>jemalloc</span>)<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span>target_link_libraries(<span style=color:#e6db74>myapp</span> <span style=color:#e6db74>PRIVATE</span> <span style=color:#f92672>${</span>JEMALLOC_LIB<span style=color:#f92672>}</span>)<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><h4 id=windows-11-vcpkg>Windows 11 (vcpkg)<a hidden class=anchor aria-hidden=true href=#windows-11-vcpkg>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>vcpkg install jemalloc:x64-windows
</span></span></code></pre></div><p>CMake:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmake data-lang=cmake><span style=display:flex><span>find_package(<span style=color:#e6db74>jemalloc</span> <span style=color:#e6db74>CONFIG</span> <span style=color:#e6db74>REQUIRED</span>)<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span>target_link_libraries(<span style=color:#e6db74>myapp</span> <span style=color:#e6db74>PRIVATE</span> <span style=color:#e6db74>jemalloc::jemalloc</span>)<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><h4 id=소스-빌드-1>소스 빌드<a hidden class=anchor aria-hidden=true href=#소스-빌드-1>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git clone https://github.com/jemalloc/jemalloc
</span></span><span style=display:flex><span>cd jemalloc
</span></span><span style=display:flex><span>./autogen.sh
</span></span><span style=display:flex><span>./configure --prefix<span style=color:#f92672>=</span>/usr/local
</span></span><span style=display:flex><span>make <span style=color:#f92672>&amp;&amp;</span> sudo make install
</span></span></code></pre></div><h3 id=사용-방법-1>사용 방법<a hidden class=anchor aria-hidden=true href=#사용-방법-1>#</a></h3><ol><li><p><strong>직접 호출</strong>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;jemalloc/jemalloc.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> ptr <span style=color:#f92672>=</span> je_malloc(size);
</span></span><span style=display:flex><span>je_free(ptr);
</span></span></code></pre></div></li><li><p><strong>라이브러리 링크</strong>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>g++ -o myapp myapp.cpp -ljemalloc
</span></span></code></pre></div></li><li><p><strong>LD_PRELOAD</strong>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>LD_PRELOAD<span style=color:#f92672>=</span>/usr/lib/libjemalloc.so ./myapp
</span></span></code></pre></div></li></ol><h4 id=c-사용자-정의-할당자>C++ 사용자 정의 할당자<a hidden class=anchor aria-hidden=true href=#c-사용자-정의-할당자>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;jemalloc/jemalloc.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> <span style=color:#66d9ef>operator</span> <span style=color:#a6e22e>new</span>(size_t size) { <span style=color:#66d9ef>return</span> je_malloc(size); }
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#66d9ef>operator</span> <span style=color:#a6e22e>delete</span>(<span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> ptr) <span style=color:#66d9ef>noexcept</span> { je_free(ptr); }
</span></span></code></pre></div><h3 id=성능-1>성능<a hidden class=anchor aria-hidden=true href=#성능-1>#</a></h3><ul><li><strong>벤치마크</strong>: MySQL 16코어 환경에서 glibc 대비 TPS 2.2배.</li><li><strong>메모리 효율성</strong>: RocksDB에서 RSS 55% 감소.</li><li><strong>단점</strong>: 동적 스레드 생성/소멸 빈번 시 캐시 오버헤드.</li></ul><h3 id=abi-고려사항-1>ABI 고려사항<a hidden class=anchor aria-hidden=true href=#abi-고려사항-1>#</a></h3><ul><li>표준 라이브러리 객체(<code>std::vector</code>)를 인터페이스로 노출하면 안 됨.</li><li><code>extern "C"</code> 인터페이스 사용 권장.</li></ul><h2 id=3-mimalloc>3. mimalloc<a hidden class=anchor aria-hidden=true href=#3-mimalloc>#</a></h2><p>Microsoft의 <strong>mimalloc</strong>은 컴팩트하고 고성능 할당기로, 서버 워크로드와 긴 실행 시간 애플리케이션에 최적화되었습니다.</p><h3 id=특징-2>특징<a hidden class=anchor aria-hidden=true href=#특징-2>#</a></h3><ul><li><strong>스레드 간 객체 마이그레이션</strong>: 캐시 효율성 극대화.</li><li><strong>낮은 오버헤드</strong>: 메모리 사용량 최소화.</li><li><strong>최신 업데이트 (2025)</strong>: C23 정렬 최적화, ARM64 성능 개선.</li></ul><h3 id=설치>설치<a hidden class=anchor aria-hidden=true href=#설치>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>vcpkg install mimalloc
</span></span></code></pre></div><p>CMake:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmake data-lang=cmake><span style=display:flex><span>find_package(<span style=color:#e6db74>mimalloc</span> <span style=color:#e6db74>CONFIG</span> <span style=color:#e6db74>REQUIRED</span>)<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span>target_link_libraries(<span style=color:#e6db74>myapp</span> <span style=color:#e6db74>PRIVATE</span> <span style=color:#e6db74>mimalloc</span>)<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><h3 id=성능-2>성능<a hidden class=anchor aria-hidden=true href=#성능-2>#</a></h3><ul><li><strong>벤치마크</strong>: Lean 컴파일러에서 tcmalloc 대비 15% 속도 향상.</li><li><strong>메모리 효율성</strong>: glibc 대비 RSS 40% 감소.</li></ul><h3 id=abi-고려사항-2>ABI 고려사항<a hidden class=anchor aria-hidden=true href=#abi-고려사항-2>#</a></h3><ul><li>표준 라이브러리와의 호환성을 위해 동일한 컴파일러/플래그 사용.</li></ul><h2 id=tcmalloc-vs-jemalloc-vs-mimalloc-비교>tcmalloc vs. jemalloc vs. mimalloc: 비교<a hidden class=anchor aria-hidden=true href=#tcmalloc-vs-jemalloc-vs-mimalloc-비교>#</a></h2><table><thead><tr><th>기준</th><th>tcmalloc</th><th>jemalloc</th><th>mimalloc</th></tr></thead><tbody><tr><td><strong>주요 사용 사례</strong></td><td>Chrome, MySQL, TensorFlow</td><td>Firefox, FreeBSD, RocksDB</td><td>Lean, 서버 워크로드</td></tr><tr><td><strong>성능</strong></td><td>소형 객체 할당 속도 빠름</td><td>단편화 감소에 강점</td><td>균형 잡힌 성능</td></tr><tr><td><strong>메모리 효율성</strong></td><td>glibc 대비 2~3배 사용량 증가 가능</td><td>glibc 대비 RSS 55% 감소</td><td>glibc 대비 RSS 40% 감소</td></tr><tr><td><strong>멀티스레드</strong></td><td>동적 스레드 환경에 유리</td><td>정-static 스레드 풀에 최적화</td><td>동적/정적 모두 적합</td></tr><tr><td><strong>디버깅 도구</strong></td><td>힙 프로파일링 지원</td><td>상세 통계, mallctl API</td><td>기본 통계 제공</td></tr></tbody></table><h3 id=선택-가이드>선택 가이드<a hidden class=anchor aria-hidden=true href=#선택-가이드>#</a></h3><ul><li><strong>tcmalloc</strong>: 소형 객체 할당이 빈번하거나 동적 스레드 환경(웹 브라우저, 실시간 서버).</li><li><strong>jemalloc</strong>: 메모리 단편화가 문제인 장기 실행 서버(데이터베이스, 캐시 서버).</li><li><strong>mimalloc</strong>: 메모리 효율성과 성능 균형이 필요한 최신 프로젝트.</li><li><strong>테스트 필수</strong>: 애플리케이션 워크로드에 따라 성능 차이가 크므로 벤치마킹 필수.</li></ul><h2 id=결론>결론<a hidden class=anchor aria-hidden=true href=#결론>#</a></h2><p><strong>tcmalloc</strong>, <strong>jemalloc</strong>, <strong>mimalloc</strong>은 멀티스레드 환경에서 glibc <code>malloc</code>을 대체해 성능과 메모리 효율성을 크게 향상시킵니다.<br>애플리케이션 특성에 맞는 할당기를 선택하려면 직접 벤치마킹이 필수입니다.</p><h2 id=추가-리소스>추가 리소스<a hidden class=anchor aria-hidden=true href=#추가-리소스>#</a></h2><ul><li><a href=https://github.com/gperftools/gperftools>tcmalloc GitHub</a></li><li><a href=https://github.com/jemalloc/jemalloc>jemalloc GitHub</a></li><li><a href=https://github.com/microsoft/mimalloc>mimalloc GitHub</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://cdecl.github.io/tags/c++/>C++</a></li><li><a href=https://cdecl.github.io/tags/memory-allocation/>Memory-Allocation</a></li><li><a href=https://cdecl.github.io/tags/tcmalloc/>Tcmalloc</a></li><li><a href=https://cdecl.github.io/tags/jemalloc/>Jemalloc</a></li><li><a href=https://cdecl.github.io/tags/mimalloc/>Mimalloc</a></li><li><a href=https://cdecl.github.io/tags/multithreading/>Multithreading</a></li><li><a href=https://cdecl.github.io/tags/performance/>Performance</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://cdecl.github.io/>cdeclog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>