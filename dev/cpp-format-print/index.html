<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>C++ std::format, std::print 사용법과 컴파일러 호환성 | cdeclog</title><meta name=keywords content="c++,c++20,c++23,std::format,std::print,fmt,formatting,performance"><meta name=description content="C++20 std::format과 C++23 std::print: 현대적인 문자열 포매팅
C++20과 C++23은 문자열 포매팅을 현대화한 std::format과 std::print를 도입하며, 기존의 printf나 std::cout에 비해 안전하고 직관적인 API를 제공합니다. 이 글에서는 두 기능의 사용법, 컴파일러 호환성, 그리고 지원되지 않는 환경에서 fmt 라이브러리 사용 방법을 다룹니다.
왜 새로운 포매팅 API가 중요한가?
기존 C++ 문자열 포매팅 방법(printf, std::stringstream, std::cout)은 다음과 같은 단점이 있습니다:

안전성 부족: printf는 타입 안정성을 보장하지 않아 런타임 오류 발생 가능.
복잡성: std::stringstream은 장황하고 성능 오버헤드 존재.
가독성: std::cout은 연속적인 << 연산으로 코드가 길어짐.

std::format(C++20)과 std::print(C++23)는 Python의 str.format에서 영감을 받아 타입 안전성, 가독성, 성능을 개선했습니다. fmt 라이브러리는 이를 보완하며, 최신 표준을 지원하지 않는 환경에서도 동일한 경험을 제공합니다."><meta name=author content="Byung Kyu KIM"><link rel=canonical href=https://cdecl.github.io/dev/cpp-format-print/><link crossorigin=anonymous href=/assets/css/stylesheet.f939c4ffefb264e6fe85e04352266f79db6bb1303c8e16ae9b6064c1247b5e32.css integrity="sha256-+TnE/++yZOb+heBDUiZvedtrsTA8jhaum2BkwSR7XjI=" rel="preload stylesheet" as=style><link rel=icon href=https://cdecl.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://cdecl.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://cdecl.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://cdecl.github.io/apple-touch-icon.png><link rel=mask-icon href=https://cdecl.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://cdecl.github.io/dev/cpp-format-print/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-VQQHHYPN7K"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VQQHHYPN7K")}</script><meta property="og:url" content="https://cdecl.github.io/dev/cpp-format-print/"><meta property="og:site_name" content="cdeclog"><meta property="og:title" content="C++ std::format, std::print 사용법과 컴파일러 호환성"><meta property="og:description" content="C++20 std::format과 C++23 std::print: 현대적인 문자열 포매팅
C++20과 C++23은 문자열 포매팅을 현대화한 std::format과 std::print를 도입하며, 기존의 printf나 std::cout에 비해 안전하고 직관적인 API를 제공합니다. 이 글에서는 두 기능의 사용법, 컴파일러 호환성, 그리고 지원되지 않는 환경에서 fmt 라이브러리 사용 방법을 다룹니다.
왜 새로운 포매팅 API가 중요한가? 기존 C++ 문자열 포매팅 방법(printf, std::stringstream, std::cout)은 다음과 같은 단점이 있습니다:
안전성 부족: printf는 타입 안정성을 보장하지 않아 런타임 오류 발생 가능. 복잡성: std::stringstream은 장황하고 성능 오버헤드 존재. 가독성: std::cout은 연속적인 << 연산으로 코드가 길어짐. std::format(C++20)과 std::print(C++23)는 Python의 str.format에서 영감을 받아 타입 안전성, 가독성, 성능을 개선했습니다. fmt 라이브러리는 이를 보완하며, 최신 표준을 지원하지 않는 환경에서도 동일한 경험을 제공합니다."><meta property="og:locale" content="ko-kr"><meta property="og:type" content="article"><meta property="article:section" content="dev"><meta property="article:published_time" content="2025-05-22T00:00:00+09:00"><meta property="article:modified_time" content="2025-05-22T00:00:00+09:00"><meta property="article:tag" content="C++"><meta property="article:tag" content="C++20"><meta property="article:tag" content="C++23"><meta property="article:tag" content="Std::format"><meta property="article:tag" content="Std::print"><meta property="article:tag" content="Fmt"><meta name=twitter:card content="summary"><meta name=twitter:title content="C++ std::format, std::print 사용법과 컴파일러 호환성"><meta name=twitter:description content="C++20 std::format과 C++23 std::print: 현대적인 문자열 포매팅
C++20과 C++23은 문자열 포매팅을 현대화한 std::format과 std::print를 도입하며, 기존의 printf나 std::cout에 비해 안전하고 직관적인 API를 제공합니다. 이 글에서는 두 기능의 사용법, 컴파일러 호환성, 그리고 지원되지 않는 환경에서 fmt 라이브러리 사용 방법을 다룹니다.
왜 새로운 포매팅 API가 중요한가?
기존 C++ 문자열 포매팅 방법(printf, std::stringstream, std::cout)은 다음과 같은 단점이 있습니다:

안전성 부족: printf는 타입 안정성을 보장하지 않아 런타임 오류 발생 가능.
복잡성: std::stringstream은 장황하고 성능 오버헤드 존재.
가독성: std::cout은 연속적인 << 연산으로 코드가 길어짐.

std::format(C++20)과 std::print(C++23)는 Python의 str.format에서 영감을 받아 타입 안전성, 가독성, 성능을 개선했습니다. fmt 라이브러리는 이를 보완하며, 최신 표준을 지원하지 않는 환경에서도 동일한 경험을 제공합니다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Devs","item":"https://cdecl.github.io/dev/"},{"@type":"ListItem","position":2,"name":"C++ std::format, std::print 사용법과 컴파일러 호환성","item":"https://cdecl.github.io/dev/cpp-format-print/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"C++ std::format, std::print 사용법과 컴파일러 호환성","name":"C\u002b\u002b std::format, std::print 사용법과 컴파일러 호환성","description":"C++20 std::format과 C++23 std::print: 현대적인 문자열 포매팅\nC++20과 C++23은 문자열 포매팅을 현대화한 std::format과 std::print를 도입하며, 기존의 printf나 std::cout에 비해 안전하고 직관적인 API를 제공합니다. 이 글에서는 두 기능의 사용법, 컴파일러 호환성, 그리고 지원되지 않는 환경에서 fmt 라이브러리 사용 방법을 다룹니다.\n왜 새로운 포매팅 API가 중요한가? 기존 C++ 문자열 포매팅 방법(printf, std::stringstream, std::cout)은 다음과 같은 단점이 있습니다:\n안전성 부족: printf는 타입 안정성을 보장하지 않아 런타임 오류 발생 가능. 복잡성: std::stringstream은 장황하고 성능 오버헤드 존재. 가독성: std::cout은 연속적인 \u0026lt;\u0026lt; 연산으로 코드가 길어짐. std::format(C++20)과 std::print(C++23)는 Python의 str.format에서 영감을 받아 타입 안전성, 가독성, 성능을 개선했습니다. fmt 라이브러리는 이를 보완하며, 최신 표준을 지원하지 않는 환경에서도 동일한 경험을 제공합니다.\n","keywords":["c++","c++20","c++23","std::format","std::print","fmt","formatting","performance"],"articleBody":"C++20 std::format과 C++23 std::print: 현대적인 문자열 포매팅\nC++20과 C++23은 문자열 포매팅을 현대화한 std::format과 std::print를 도입하며, 기존의 printf나 std::cout에 비해 안전하고 직관적인 API를 제공합니다. 이 글에서는 두 기능의 사용법, 컴파일러 호환성, 그리고 지원되지 않는 환경에서 fmt 라이브러리 사용 방법을 다룹니다.\n왜 새로운 포매팅 API가 중요한가? 기존 C++ 문자열 포매팅 방법(printf, std::stringstream, std::cout)은 다음과 같은 단점이 있습니다:\n안전성 부족: printf는 타입 안정성을 보장하지 않아 런타임 오류 발생 가능. 복잡성: std::stringstream은 장황하고 성능 오버헤드 존재. 가독성: std::cout은 연속적인 \u003c\u003c 연산으로 코드가 길어짐. std::format(C++20)과 std::print(C++23)는 Python의 str.format에서 영감을 받아 타입 안전성, 가독성, 성능을 개선했습니다. fmt 라이브러리는 이를 보완하며, 최신 표준을 지원하지 않는 환경에서도 동일한 경험을 제공합니다.\n1. std::format (C++20) std::format은 문자열 포매팅을 위한 타입 안전한 템플릿 기반 API로, 헤더에 포함됩니다.\n특징 타입 안전성: 컴파일 타임에 포맷 문자열과 인수 타입 검증. 유연성: 사용자 정의 타입 포매팅 지원. 성능: printf보다 빠르며, 동적 메모리 할당 최소화. 2025년 기준: C++20 표준의 대부분 컴파일러에서 안정적으로 지원. 사용법 #include #include #include int main() { std::string s = std::format(\"Hello, {}! You are {} years old.\", \"Alice\", 25); std::cout \u003c\u003c s \u003c\u003c std::endl; // 위치 지정자 std::string s2 = std::format(\"{1}, {0}!\", \"World\", \"Hello\"); std::cout \u003c\u003c s2 \u003c\u003c std::endl; // 형식 지정 std::string s3 = std::format(\"Pi: {:.2f}\", 3.14159); std::cout \u003c\u003c s3 \u003c\u003c std::endl; } 출력:\nHello, Alice! You are 25 years old. Hello, World! Pi: 3.14 사용자 정의 타입 #include #include struct Person { std::string name; int age; }; template \u003c\u003e struct std::formatter\u003cPerson\u003e { constexpr auto parse(std::format_parse_context\u0026 ctx) { return ctx.begin(); } auto format(const Person\u0026 p, std::format_context\u0026 ctx) const { return std::format_to(ctx.out(), \"Person{{name: {}, age: {}}}\", p.name, p.age); } }; int main() { Person p{\"Bob\", 30}; std::string s = std::format(\"{}\", p); std::cout \u003c\u003c s \u003c\u003c std::endl; // 출력: Person{name: Bob, age: 30} } 컴파일러 호환성 (2025년 기준) GCC: 11.1 이상 (-std=c++20) Clang: 14.0 이상 (-std=c++20) MSVC: Visual Studio 2019 16.10 이상 (/std:c++20) Apple Clang: Xcode 14 이상 제약사항: 일부 임베디드 환경(예: 특정 RTOS)에서는 지원 미비. 2. std::print (C++23) std::print는 std::format을 기반으로, 콘솔 출력에 최적화된 함수입니다. 헤더에 포함되며, std::cout보다 간결하고 효율적입니다.\n특징 간결성: 포매팅과 출력을 단일 호출로 처리. 유니코드 지원: UTF-8 출력 최적화. 2025년 기준: C++23 지원이 초기 단계로, 최신 컴파일러에서만 동작. 사용법 #include int main() { std::print(\"Hello, {}! You are {} years old.\\n\", \"Charlie\", 35); std::print(\"Pi: {:.2f}\\n\", 3.14159); } 출력:\nHello, Charlie! You are 35 years old. Pi: 3.14 컴파일러 호환성 (2025년 기준) GCC: 13.1 이상 (-std=c++23) Clang: 16.0 이상 (-std=c++23) MSVC: Visual Studio 2022 17.8 이상 (/std:c++23) 제약사항: 는 최신 표준이므로, GCC 12 또는 Clang 15 이하에서는 사용 불가. 3. fmt 라이브러리: 지원되지 않는 환경에서의 대안 fmt 라이브러리는 std::format의 원형으로, C++20/C++23을 지원하지 않는 환경에서 동일한 포매팅 기능을 제공합니다. Chrome, Redis, MongoDB 등에서 사용됩니다.\n특징 호환성: C++11 이상에서 동작. 성능: std::format과 유사하거나 더 빠름. 2025년 기준: fmt 10.2.0 이상, C++23 std::print 호환 API 추가. 설치 방법 Ubuntu 24.04 sudo apt update sudo apt install libfmt-dev CMake:\nfind_package(fmt CONFIG REQUIRED) target_link_libraries(myapp PRIVATE fmt::fmt) Windows (vcpkg) vcpkg install fmt:x64-windows CMake:\nfind_package(fmt CONFIG REQUIRED) target_link_libraries(myapp PRIVATE fmt::fmt) 소스 빌드 git clone https://github.com/fmtlib/fmt cd fmt cmake -B build -DCMAKE_INSTALL_PREFIX=/usr/local cmake --build build --target install 사용법 #include #include // printf 스타일 지원 #include // C++23 print 호환 int main() { // std::format 스타일 std::string s = fmt::format(\"Hello, {}! You are {} years old.\", \"Dave\", 40); fmt::print(\"{}\\n\", s); // printf 스타일 fmt::printf(\"Pi: %.2f\\n\", 3.14159); // C++23 print 스타일 fmt::print(\"Modern C++: {}\\n\", 2023); } 출력:\nHello, Dave! You are 40 years old. Pi: 3.14 Modern C++: 2023 사용자 정의 타입 #include struct Person { std::string name; int age; }; template \u003c\u003e struct fmt::formatter\u003cPerson\u003e { constexpr auto parse(format_parse_context\u0026 ctx) { return ctx.begin(); } auto format(const Person\u0026 p, format_context\u0026 ctx) const { return fmt::format_to(ctx.out(), \"Person{{name: {}, age: {}}}\", p.name, p.age); } }; int main() { Person p{\"Eve\", 45}; fmt::print(\"{}\\n\", p); // 출력: Person{name: Eve, age: 45} } 성능 벤치마크 (2025): fmt::format은 std::format과 비슷하거나 10~20% 빠름 (GCC 13, Clang 16). 메모리 효율성: 동적 메모리 할당 최소화. 단점: 외부 종속성 추가로 빌드 복잡성 증가 가능. std::format vs std::print vs fmt: 비교 기준 std::format std::print fmt 표준 C++20 C++23 C++11 이상 주요 사용 사례 문자열 생성 콘솔 출력 모든 환경 성능 printf보다 빠름 std::cout보다 빠름 std::format과 유사/더 빠름 컴파일러 지원 GCC 11+, Clang 14+, MSVC 2019 GCC 13+, Clang 16+, MSVC 2022 대부분 컴파일러 유니코드 제한적 UTF-8 최적화 UTF-8 지원 디버깅 표준 에러 메시지 표준 에러 메시지 상세 에러 메시지 선택 가이드 std::format: C++20을 지원하는 환경에서 문자열 생성에 적합. std::print: C++23을 지원하며 간단한 콘솔 출력이 필요한 경우. fmt: C++20/23 미지원 환경, 또는 성능과 호환성을 모두 원하는 경우. 테스트 필수: 워크로드에 따라 성능 차이가 있으므로 벤치마킹 권장. 결론 C++20의 std::format과 C++23의 std::print는 현대적인 문자열 포매팅과 출력을 제공하며, 타입 안전성과 성능을 개선합니다. 지원되지 않는 환경에서는 fmt 라이브러리가 강력한 대안입니다. 애플리케이션 요구사항과 컴파일러 지원 여부에 따라 적절한 도구를 선택하세요.\n추가 리소스 C++ Reference: std::format C++ Reference: std::print fmt GitHub ","wordCount":"794","inLanguage":"en","datePublished":"2025-05-22T00:00:00+09:00","dateModified":"2025-05-22T00:00:00+09:00","author":{"@type":"Person","name":"Byung Kyu KIM"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://cdecl.github.io/dev/cpp-format-print/"},"publisher":{"@type":"Organization","name":"cdeclog","logo":{"@type":"ImageObject","url":"https://cdecl.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://cdecl.github.io/ accesskey=h title="cdeclog (Alt + H)">cdeclog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://cdecl.github.io/dev/ title=Dev><span>Dev</span></a></li><li><a href=https://cdecl.github.io/devops/ title=DevOps><span>DevOps</span></a></li><li><a href=https://cdecl.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://cdecl.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://cdecl.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://cdecl.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://cdecl.github.io/dev/>Devs</a></div><h1 class="post-title entry-hint-parent">C++ std::format, std::print 사용법과 컴파일러 호환성</h1><div class=post-meta><span title='2025-05-22 00:00:00 +0900 KST'>May 22, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%ec%99%9c-%ec%83%88%eb%a1%9c%ec%9a%b4-%ed%8f%ac%eb%a7%a4%ed%8c%85-api%ea%b0%80-%ec%a4%91%ec%9a%94%ed%95%9c%ea%b0%80 aria-label="왜 새로운 포매팅 API가 중요한가?">왜 새로운 포매팅 API가 중요한가?</a></li><li><a href=#1-stdformat-c20 aria-label="1. std::format (C++20)">1. std::format (C++20)</a><ul><li><a href=#%ed%8a%b9%ec%a7%95 aria-label=특징>특징</a></li><li><a href=#%ec%82%ac%ec%9a%a9%eb%b2%95 aria-label=사용법>사용법</a></li><li><a href=#%ec%82%ac%ec%9a%a9%ec%9e%90-%ec%a0%95%ec%9d%98-%ed%83%80%ec%9e%85 aria-label="사용자 정의 타입">사용자 정의 타입</a></li><li><a href=#%ec%bb%b4%ed%8c%8c%ec%9d%bc%eb%9f%ac-%ed%98%b8%ed%99%98%ec%84%b1-2025%eb%85%84-%ea%b8%b0%ec%a4%80 aria-label="컴파일러 호환성 (2025년 기준)">컴파일러 호환성 (2025년 기준)</a></li></ul></li><li><a href=#2-stdprint-c23 aria-label="2. std::print (C++23)">2. std::print (C++23)</a><ul><li><a href=#%ed%8a%b9%ec%a7%95-1 aria-label=특징>특징</a></li><li><a href=#%ec%82%ac%ec%9a%a9%eb%b2%95-1 aria-label=사용법>사용법</a></li><li><a href=#%ec%bb%b4%ed%8c%8c%ec%9d%bc%eb%9f%ac-%ed%98%b8%ed%99%98%ec%84%b1-2025%eb%85%84-%ea%b8%b0%ec%a4%80-1 aria-label="컴파일러 호환성 (2025년 기준)">컴파일러 호환성 (2025년 기준)</a></li></ul></li><li><a href=#3-fmt-%eb%9d%bc%ec%9d%b4%eb%b8%8c%eb%9f%ac%eb%a6%ac-%ec%a7%80%ec%9b%90%eb%90%98%ec%a7%80-%ec%95%8a%eb%8a%94-%ed%99%98%ea%b2%bd%ec%97%90%ec%84%9c%ec%9d%98-%eb%8c%80%ec%95%88 aria-label="3. fmt 라이브러리: 지원되지 않는 환경에서의 대안">3. fmt 라이브러리: 지원되지 않는 환경에서의 대안</a><ul><li><a href=#%ed%8a%b9%ec%a7%95-2 aria-label=특징>특징</a></li><li><a href=#%ec%84%a4%ec%b9%98-%eb%b0%a9%eb%b2%95 aria-label="설치 방법">설치 방법</a><ul><li><a href=#ubuntu-2404 aria-label="Ubuntu 24.04">Ubuntu 24.04</a></li><li><a href=#windows-vcpkg aria-label="Windows (vcpkg)">Windows (vcpkg)</a></li><li><a href=#%ec%86%8c%ec%8a%a4-%eb%b9%8c%eb%93%9c aria-label="소스 빌드">소스 빌드</a></li></ul></li><li><a href=#%ec%82%ac%ec%9a%a9%eb%b2%95-2 aria-label=사용법>사용법</a></li><li><a href=#%ec%82%ac%ec%9a%a9%ec%9e%90-%ec%a0%95%ec%9d%98-%ed%83%80%ec%9e%85-1 aria-label="사용자 정의 타입">사용자 정의 타입</a></li><li><a href=#%ec%84%b1%eb%8a%a5 aria-label=성능>성능</a></li></ul></li><li><a href=#stdformat-vs-stdprint-vs-fmt-%eb%b9%84%ea%b5%90 aria-label="std::format vs std::print vs fmt: 비교">std::format vs std::print vs fmt: 비교</a><ul><li><a href=#%ec%84%a0%ed%83%9d-%ea%b0%80%ec%9d%b4%eb%93%9c aria-label="선택 가이드">선택 가이드</a></li></ul></li><li><a href=#%ea%b2%b0%eb%a1%a0 aria-label=결론>결론</a></li><li><a href=#%ec%b6%94%ea%b0%80-%eb%a6%ac%ec%86%8c%ec%8a%a4 aria-label="추가 리소스">추가 리소스</a></li></ul></div></details></div><div class=post-content><p>C++20 std::format과 C++23 std::print: 현대적인 문자열 포매팅</p><p>C++20과 C++23은 문자열 포매팅을 현대화한 <code>std::format</code>과 <code>std::print</code>를 도입하며, 기존의 <code>printf</code>나 <code>std::cout</code>에 비해 안전하고 직관적인 API를 제공합니다. 이 글에서는 두 기능의 사용법, 컴파일러 호환성, 그리고 지원되지 않는 환경에서 <code>fmt</code> 라이브러리 사용 방법을 다룹니다.</p><h2 id=왜-새로운-포매팅-api가-중요한가>왜 새로운 포매팅 API가 중요한가?<a hidden class=anchor aria-hidden=true href=#왜-새로운-포매팅-api가-중요한가>#</a></h2><p>기존 C++ 문자열 포매팅 방법(<code>printf</code>, <code>std::stringstream</code>, <code>std::cout</code>)은 다음과 같은 단점이 있습니다:</p><ul><li><strong>안전성 부족</strong>: <code>printf</code>는 타입 안정성을 보장하지 않아 런타임 오류 발생 가능.</li><li><strong>복잡성</strong>: <code>std::stringstream</code>은 장황하고 성능 오버헤드 존재.</li><li><strong>가독성</strong>: <code>std::cout</code>은 연속적인 <code>&lt;&lt;</code> 연산으로 코드가 길어짐.</li></ul><p><code>std::format</code>(C++20)과 <code>std::print</code>(C++23)는 Python의 <code>str.format</code>에서 영감을 받아 타입 안전성, 가독성, 성능을 개선했습니다. <code>fmt</code> 라이브러리는 이를 보완하며, 최신 표준을 지원하지 않는 환경에서도 동일한 경험을 제공합니다.</p><h2 id=1-stdformat-c20>1. std::format (C++20)<a hidden class=anchor aria-hidden=true href=#1-stdformat-c20>#</a></h2><p><code>std::format</code>은 문자열 포매팅을 위한 타입 안전한 템플릿 기반 API로, <code>&lt;format></code> 헤더에 포함됩니다.</p><h3 id=특징>특징<a hidden class=anchor aria-hidden=true href=#특징>#</a></h3><ul><li><strong>타입 안전성</strong>: 컴파일 타임에 포맷 문자열과 인수 타입 검증.</li><li><strong>유연성</strong>: 사용자 정의 타입 포매팅 지원.</li><li><strong>성능</strong>: <code>printf</code>보다 빠르며, 동적 메모리 할당 최소화.</li><li><strong>2025년 기준</strong>: C++20 표준의 대부분 컴파일러에서 안정적으로 지원.</li></ul><h3 id=사용법>사용법<a hidden class=anchor aria-hidden=true href=#사용법>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&lt;format&gt;</span><span style=color:#ff79c6>
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&lt;string&gt;</span><span style=color:#ff79c6>
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&lt;iostream&gt;</span><span style=color:#ff79c6>
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> <span style=color:#50fa7b>main</span>() {
</span></span><span style=display:flex><span>    std<span style=color:#ff79c6>::</span>string s <span style=color:#ff79c6>=</span> std<span style=color:#ff79c6>::</span>format(<span style=color:#f1fa8c>&#34;Hello, {}! You are {} years old.&#34;</span>, <span style=color:#f1fa8c>&#34;Alice&#34;</span>, <span style=color:#bd93f9>25</span>);
</span></span><span style=display:flex><span>    std<span style=color:#ff79c6>::</span>cout <span style=color:#ff79c6>&lt;&lt;</span> s <span style=color:#ff79c6>&lt;&lt;</span> std<span style=color:#ff79c6>::</span>endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 위치 지정자
</span></span></span><span style=display:flex><span>    std<span style=color:#ff79c6>::</span>string s2 <span style=color:#ff79c6>=</span> std<span style=color:#ff79c6>::</span>format(<span style=color:#f1fa8c>&#34;{1}, {0}!&#34;</span>, <span style=color:#f1fa8c>&#34;World&#34;</span>, <span style=color:#f1fa8c>&#34;Hello&#34;</span>);
</span></span><span style=display:flex><span>    std<span style=color:#ff79c6>::</span>cout <span style=color:#ff79c6>&lt;&lt;</span> s2 <span style=color:#ff79c6>&lt;&lt;</span> std<span style=color:#ff79c6>::</span>endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 형식 지정
</span></span></span><span style=display:flex><span>    std<span style=color:#ff79c6>::</span>string s3 <span style=color:#ff79c6>=</span> std<span style=color:#ff79c6>::</span>format(<span style=color:#f1fa8c>&#34;Pi: {:.2f}&#34;</span>, <span style=color:#bd93f9>3.14159</span>);
</span></span><span style=display:flex><span>    std<span style=color:#ff79c6>::</span>cout <span style=color:#ff79c6>&lt;&lt;</span> s3 <span style=color:#ff79c6>&lt;&lt;</span> std<span style=color:#ff79c6>::</span>endl;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>출력</strong>:</p><pre tabindex=0><code>Hello, Alice! You are 25 years old.
Hello, World!
Pi: 3.14
</code></pre><h3 id=사용자-정의-타입>사용자 정의 타입<a hidden class=anchor aria-hidden=true href=#사용자-정의-타입>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&lt;format&gt;</span><span style=color:#ff79c6>
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&lt;string&gt;</span><span style=color:#ff79c6>
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>struct</span> <span style=color:#50fa7b>Person</span> {
</span></span><span style=display:flex><span>    std<span style=color:#ff79c6>::</span>string name;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> age;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>template</span> <span style=color:#ff79c6>&lt;&gt;</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>struct</span> <span style=color:#50fa7b>std</span><span style=color:#ff79c6>::</span>formatter<span style=color:#ff79c6>&lt;</span>Person<span style=color:#ff79c6>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>constexpr</span> <span style=color:#ff79c6>auto</span> <span style=color:#50fa7b>parse</span>(std<span style=color:#ff79c6>::</span>format_parse_context<span style=color:#ff79c6>&amp;</span> ctx) { <span style=color:#ff79c6>return</span> ctx.begin(); }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>auto</span> <span style=color:#50fa7b>format</span>(<span style=color:#ff79c6>const</span> Person<span style=color:#ff79c6>&amp;</span> p, std<span style=color:#ff79c6>::</span>format_context<span style=color:#ff79c6>&amp;</span> ctx) <span style=color:#ff79c6>const</span> {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> std<span style=color:#ff79c6>::</span>format_to(ctx.out(), <span style=color:#f1fa8c>&#34;Person{{name: {}, age: {}}}&#34;</span>, p.name, p.age);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> <span style=color:#50fa7b>main</span>() {
</span></span><span style=display:flex><span>    Person p{<span style=color:#f1fa8c>&#34;Bob&#34;</span>, <span style=color:#bd93f9>30</span>};
</span></span><span style=display:flex><span>    std<span style=color:#ff79c6>::</span>string s <span style=color:#ff79c6>=</span> std<span style=color:#ff79c6>::</span>format(<span style=color:#f1fa8c>&#34;{}&#34;</span>, p);
</span></span><span style=display:flex><span>    std<span style=color:#ff79c6>::</span>cout <span style=color:#ff79c6>&lt;&lt;</span> s <span style=color:#ff79c6>&lt;&lt;</span> std<span style=color:#ff79c6>::</span>endl; <span style=color:#6272a4>// 출력: Person{name: Bob, age: 30}
</span></span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=컴파일러-호환성-2025년-기준>컴파일러 호환성 (2025년 기준)<a hidden class=anchor aria-hidden=true href=#컴파일러-호환성-2025년-기준>#</a></h3><ul><li><strong>GCC</strong>: 11.1 이상 (<code>-std=c++20</code>)</li><li><strong>Clang</strong>: 14.0 이상 (<code>-std=c++20</code>)</li><li><strong>MSVC</strong>: Visual Studio 2019 16.10 이상 (<code>/std:c++20</code>)</li><li><strong>Apple Clang</strong>: Xcode 14 이상</li><li><strong>제약사항</strong>: 일부 임베디드 환경(예: 특정 RTOS)에서는 <code>&lt;format></code> 지원 미비.</li></ul><h2 id=2-stdprint-c23>2. std::print (C++23)<a hidden class=anchor aria-hidden=true href=#2-stdprint-c23>#</a></h2><p><code>std::print</code>는 <code>std::format</code>을 기반으로, 콘솔 출력에 최적화된 함수입니다. <code>&lt;print></code> 헤더에 포함되며, <code>std::cout</code>보다 간결하고 효율적입니다.</p><h3 id=특징-1>특징<a hidden class=anchor aria-hidden=true href=#특징-1>#</a></h3><ul><li><strong>간결성</strong>: 포매팅과 출력을 단일 호출로 처리.</li><li><strong>유니코드 지원</strong>: UTF-8 출력 최적화.</li><li><strong>2025년 기준</strong>: C++23 지원이 초기 단계로, 최신 컴파일러에서만 동작.</li></ul><h3 id=사용법-1>사용법<a hidden class=anchor aria-hidden=true href=#사용법-1>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&lt;print&gt;</span><span style=color:#ff79c6>
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> <span style=color:#50fa7b>main</span>() {
</span></span><span style=display:flex><span>    std<span style=color:#ff79c6>::</span>print(<span style=color:#f1fa8c>&#34;Hello, {}! You are {} years old.</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span>, <span style=color:#f1fa8c>&#34;Charlie&#34;</span>, <span style=color:#bd93f9>35</span>);
</span></span><span style=display:flex><span>    std<span style=color:#ff79c6>::</span>print(<span style=color:#f1fa8c>&#34;Pi: {:.2f}</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span>, <span style=color:#bd93f9>3.14159</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>출력</strong>:</p><pre tabindex=0><code>Hello, Charlie! You are 35 years old.
Pi: 3.14
</code></pre><h3 id=컴파일러-호환성-2025년-기준-1>컴파일러 호환성 (2025년 기준)<a hidden class=anchor aria-hidden=true href=#컴파일러-호환성-2025년-기준-1>#</a></h3><ul><li><strong>GCC</strong>: 13.1 이상 (<code>-std=c++23</code>)</li><li><strong>Clang</strong>: 16.0 이상 (<code>-std=c++23</code>)</li><li><strong>MSVC</strong>: Visual Studio 2022 17.8 이상 (<code>/std:c++23</code>)</li><li><strong>제약사항</strong>: <code>&lt;print></code>는 최신 표준이므로, GCC 12 또는 Clang 15 이하에서는 사용 불가.</li></ul><h2 id=3-fmt-라이브러리-지원되지-않는-환경에서의-대안>3. fmt 라이브러리: 지원되지 않는 환경에서의 대안<a hidden class=anchor aria-hidden=true href=#3-fmt-라이브러리-지원되지-않는-환경에서의-대안>#</a></h2><p><code>fmt</code> 라이브러리는 <code>std::format</code>의 원형으로, C++20/C++23을 지원하지 않는 환경에서 동일한 포매팅 기능을 제공합니다. Chrome, Redis, MongoDB 등에서 사용됩니다.</p><h3 id=특징-2>특징<a hidden class=anchor aria-hidden=true href=#특징-2>#</a></h3><ul><li><strong>호환성</strong>: C++11 이상에서 동작.</li><li><strong>성능</strong>: <code>std::format</code>과 유사하거나 더 빠름.</li><li><strong>2025년 기준</strong>: <code>fmt</code> 10.2.0 이상, C++23 <code>std::print</code> 호환 API 추가.</li></ul><h3 id=설치-방법>설치 방법<a hidden class=anchor aria-hidden=true href=#설치-방법>#</a></h3><h4 id=ubuntu-2404>Ubuntu 24.04<a hidden class=anchor aria-hidden=true href=#ubuntu-2404>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo apt update
</span></span><span style=display:flex><span>sudo apt install libfmt-dev
</span></span></code></pre></div><p>CMake:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmake data-lang=cmake><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>find_package</span>(<span style=color:#f1fa8c>fmt</span> <span style=color:#f1fa8c>CONFIG</span> <span style=color:#f1fa8c>REQUIRED</span>)
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>target_link_libraries</span>(<span style=color:#f1fa8c>myapp</span> <span style=color:#f1fa8c>PRIVATE</span> <span style=color:#f1fa8c>fmt::fmt</span>)
</span></span></code></pre></div><h4 id=windows-vcpkg>Windows (vcpkg)<a hidden class=anchor aria-hidden=true href=#windows-vcpkg>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>vcpkg install fmt:x64-windows
</span></span></code></pre></div><p>CMake:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmake data-lang=cmake><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>find_package</span>(<span style=color:#f1fa8c>fmt</span> <span style=color:#f1fa8c>CONFIG</span> <span style=color:#f1fa8c>REQUIRED</span>)
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>target_link_libraries</span>(<span style=color:#f1fa8c>myapp</span> <span style=color:#f1fa8c>PRIVATE</span> <span style=color:#f1fa8c>fmt::fmt</span>)
</span></span></code></pre></div><h4 id=소스-빌드>소스 빌드<a hidden class=anchor aria-hidden=true href=#소스-빌드>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git clone https://github.com/fmtlib/fmt
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>cd</span> fmt
</span></span><span style=display:flex><span>cmake -B build -DCMAKE_INSTALL_PREFIX<span style=color:#ff79c6>=</span>/usr/local
</span></span><span style=display:flex><span>cmake --build build --target install
</span></span></code></pre></div><h3 id=사용법-2>사용법<a hidden class=anchor aria-hidden=true href=#사용법-2>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&lt;fmt/format.h&gt;</span><span style=color:#ff79c6>
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&lt;fmt/printf.h&gt;</span><span style=color:#ff79c6> </span><span style=color:#6272a4>// printf 스타일 지원
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&lt;fmt/std.h&gt;</span><span style=color:#ff79c6>   </span><span style=color:#6272a4>// C++23 print 호환
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> <span style=color:#50fa7b>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// std::format 스타일
</span></span></span><span style=display:flex><span>    std<span style=color:#ff79c6>::</span>string s <span style=color:#ff79c6>=</span> fmt<span style=color:#ff79c6>::</span>format(<span style=color:#f1fa8c>&#34;Hello, {}! You are {} years old.&#34;</span>, <span style=color:#f1fa8c>&#34;Dave&#34;</span>, <span style=color:#bd93f9>40</span>);
</span></span><span style=display:flex><span>    fmt<span style=color:#ff79c6>::</span>print(<span style=color:#f1fa8c>&#34;{}</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span>, s);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// printf 스타일
</span></span></span><span style=display:flex><span>    fmt<span style=color:#ff79c6>::</span>printf(<span style=color:#f1fa8c>&#34;Pi: %.2f</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span>, <span style=color:#bd93f9>3.14159</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// C++23 print 스타일
</span></span></span><span style=display:flex><span>    fmt<span style=color:#ff79c6>::</span>print(<span style=color:#f1fa8c>&#34;Modern C++: {}</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span>, <span style=color:#bd93f9>2023</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>출력</strong>:</p><pre tabindex=0><code>Hello, Dave! You are 40 years old.
Pi: 3.14
Modern C++: 2023
</code></pre><h3 id=사용자-정의-타입-1>사용자 정의 타입<a hidden class=anchor aria-hidden=true href=#사용자-정의-타입-1>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&lt;fmt/format.h&gt;</span><span style=color:#ff79c6>
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>struct</span> <span style=color:#50fa7b>Person</span> {
</span></span><span style=display:flex><span>    std<span style=color:#ff79c6>::</span>string name;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> age;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>template</span> <span style=color:#ff79c6>&lt;&gt;</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>struct</span> <span style=color:#50fa7b>fmt</span><span style=color:#ff79c6>::</span>formatter<span style=color:#ff79c6>&lt;</span>Person<span style=color:#ff79c6>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>constexpr</span> <span style=color:#ff79c6>auto</span> <span style=color:#50fa7b>parse</span>(format_parse_context<span style=color:#ff79c6>&amp;</span> ctx) { <span style=color:#ff79c6>return</span> ctx.begin(); }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>auto</span> <span style=color:#50fa7b>format</span>(<span style=color:#ff79c6>const</span> Person<span style=color:#ff79c6>&amp;</span> p, format_context<span style=color:#ff79c6>&amp;</span> ctx) <span style=color:#ff79c6>const</span> {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> fmt<span style=color:#ff79c6>::</span>format_to(ctx.out(), <span style=color:#f1fa8c>&#34;Person{{name: {}, age: {}}}&#34;</span>, p.name, p.age);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> <span style=color:#50fa7b>main</span>() {
</span></span><span style=display:flex><span>    Person p{<span style=color:#f1fa8c>&#34;Eve&#34;</span>, <span style=color:#bd93f9>45</span>};
</span></span><span style=display:flex><span>    fmt<span style=color:#ff79c6>::</span>print(<span style=color:#f1fa8c>&#34;{}</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span>, p); <span style=color:#6272a4>// 출력: Person{name: Eve, age: 45}
</span></span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=성능>성능<a hidden class=anchor aria-hidden=true href=#성능>#</a></h3><ul><li><strong>벤치마크 (2025)</strong>: <code>fmt::format</code>은 <code>std::format</code>과 비슷하거나 10~20% 빠름 (GCC 13, Clang 16).</li><li><strong>메모리 효율성</strong>: 동적 메모리 할당 최소화.</li><li><strong>단점</strong>: 외부 종속성 추가로 빌드 복잡성 증가 가능.</li></ul><h2 id=stdformat-vs-stdprint-vs-fmt-비교>std::format vs std::print vs fmt: 비교<a hidden class=anchor aria-hidden=true href=#stdformat-vs-stdprint-vs-fmt-비교>#</a></h2><table><thead><tr><th>기준</th><th>std::format</th><th>std::print</th><th>fmt</th></tr></thead><tbody><tr><td><strong>표준</strong></td><td>C++20</td><td>C++23</td><td>C++11 이상</td></tr><tr><td><strong>주요 사용 사례</strong></td><td>문자열 생성</td><td>콘솔 출력</td><td>모든 환경</td></tr><tr><td><strong>성능</strong></td><td><code>printf</code>보다 빠름</td><td><code>std::cout</code>보다 빠름</td><td><code>std::format</code>과 유사/더 빠름</td></tr><tr><td><strong>컴파일러 지원</strong></td><td>GCC 11+, Clang 14+, MSVC 2019</td><td>GCC 13+, Clang 16+, MSVC 2022</td><td>대부분 컴파일러</td></tr><tr><td><strong>유니코드</strong></td><td>제한적</td><td>UTF-8 최적화</td><td>UTF-8 지원</td></tr><tr><td><strong>디버깅</strong></td><td>표준 에러 메시지</td><td>표준 에러 메시지</td><td>상세 에러 메시지</td></tr></tbody></table><h3 id=선택-가이드>선택 가이드<a hidden class=anchor aria-hidden=true href=#선택-가이드>#</a></h3><ul><li><strong>std::format</strong>: C++20을 지원하는 환경에서 문자열 생성에 적합.</li><li><strong>std::print</strong>: C++23을 지원하며 간단한 콘솔 출력이 필요한 경우.</li><li><strong>fmt</strong>: C++20/23 미지원 환경, 또는 성능과 호환성을 모두 원하는 경우.</li><li><strong>테스트 필수</strong>: 워크로드에 따라 성능 차이가 있으므로 벤치마킹 권장.</li></ul><h2 id=결론>결론<a hidden class=anchor aria-hidden=true href=#결론>#</a></h2><p>C++20의 <code>std::format</code>과 C++23의 <code>std::print</code>는 현대적인 문자열 포매팅과 출력을 제공하며, 타입 안전성과 성능을 개선합니다. 지원되지 않는 환경에서는 <code>fmt</code> 라이브러리가 강력한 대안입니다. 애플리케이션 요구사항과 컴파일러 지원 여부에 따라 적절한 도구를 선택하세요.</p><h2 id=추가-리소스>추가 리소스<a hidden class=anchor aria-hidden=true href=#추가-리소스>#</a></h2><ul><li><a href=https://en.cppreference.com/w/cpp/utility/format>C++ Reference: std::format</a></li><li><a href=https://en.cppreference.com/w/cpp/io/print>C++ Reference: std::print</a></li><li><a href=https://github.com/fmtlib/fmt>fmt GitHub</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://cdecl.github.io/tags/c++/>C++</a></li><li><a href=https://cdecl.github.io/tags/c++20/>C++20</a></li><li><a href=https://cdecl.github.io/tags/c++23/>C++23</a></li><li><a href=https://cdecl.github.io/tags/stdformat/>Std::format</a></li><li><a href=https://cdecl.github.io/tags/stdprint/>Std::print</a></li><li><a href=https://cdecl.github.io/tags/fmt/>Fmt</a></li><li><a href=https://cdecl.github.io/tags/formatting/>Formatting</a></li><li><a href=https://cdecl.github.io/tags/performance/>Performance</a></li></ul></footer><script src=https://giscus.app/client.js data-repo=cdecl/cdecl.github.io data-repo-id="MDEwOlJlcG9zaXRvcnkzNDk1ODUyNjg=" data-category=General data-category-id=DIC_kwDOFNY_dM4C1XMk data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=transparent_dark data-lang=ko crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2026 <a href=https://cdecl.github.io/>cdeclog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>