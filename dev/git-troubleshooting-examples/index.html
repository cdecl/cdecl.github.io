<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>사례로 보는 Git 트러블 슈팅 | cdeclog</title><meta name=keywords content="git,troubleshooting,checkout,stash,branch,reset,revert"><meta name=description content='Git은 강력하지만, 복잡한 상황에서는 개발자를 당황하게 만드는 경우가 많습니다. &ldquo;앗, 방금 뭘 한 거지?&rdquo; 싶은 순간은 누구에게나 찾아옵니다. 이 글에서는 checkout, stash, branch 등 핵심 명령어를 중심으로, 실제 현업에서 자주 겪는 20가지 트러블 슈팅 사례와 해결 방안을 구체적으로 정리했습니다.

Part 1: checkout 관련 문제 - &ldquo;코드가 뒤섞였어요!&rdquo;
checkout은 브랜치를 바꾸거나 특정 버전으로 돌아갈 때 사용하지만, 이 과정에서 많은 실수가 발생합니다.
사례 1: 다른 브랜치로 이동하려는데, 작업하던 내용이 있어서 막힐 때

문제 상황: feature/new-login 브랜치에서 작업하던 중, 급하게 hotfix/bug-report 브랜치로 이동해야 합니다. git checkout hotfix/bug-report를 입력하니 &ldquo;error: Your local changes to the following files would be overwritten by checkout&mldr;&rdquo; 메시지가 나옵니다.
해결 방안: 아직 커밋하기 애매한 작업 내용을 임시 저장 공간(stash)에 저장합니다.
# 현재 작업 내용을 스택에 임시 저장
git stash
> `git stash`: 현재 작업 디렉터리의 변경된 파일(Tracked files)을 임시로 스택에 저장합니다. `push`, `pop`, `apply`, `list` 등의 하위 명령어를 통해 관리할 수 있습니다.

# 원하는 브랜치로 이동하여 작업 수행
git checkout hotfix/bug-report
# ... 핫픽스 작업 ...
git commit -m "Fix: Critical bug"
git push origin hotfix/bug-report

# 원래 브랜치로 복귀
git checkout feature/new-login

# 임시 저장했던 작업 내용 다시 적용
git stash pop


사례 2: 실수로 파일을 삭제했는데, 커밋은 아직 안 했을 때 (rm a.txt)


문제 상황: git rm이 아닌 rm 명령어로 파일을 삭제했습니다. git status에 &ldquo;deleted: a.txt"로 표시됩니다.'><meta name=author content="Byung Kyu KIM"><link rel=canonical href=https://cdecl.github.io/dev/git-troubleshooting-examples/><link crossorigin=anonymous href=/assets/css/stylesheet.d980bb9fb2cba61af0aead0606b5eb221d7e358748ac394b60233d95d626c563.css integrity="sha256-2YC7n7LLphrwrq0GBrXrIh1+NYdIrDlLYCM9ldYmxWM=" rel="preload stylesheet" as=style><link rel=icon href=https://cdecl.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://cdecl.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://cdecl.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://cdecl.github.io/apple-touch-icon.png><link rel=mask-icon href=https://cdecl.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://cdecl.github.io/dev/git-troubleshooting-examples/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-VQQHHYPN7K"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VQQHHYPN7K")}</script><meta property="og:url" content="https://cdecl.github.io/dev/git-troubleshooting-examples/"><meta property="og:site_name" content="cdeclog"><meta property="og:title" content="사례로 보는 Git 트러블 슈팅"><meta property="og:description" content='Git은 강력하지만, 복잡한 상황에서는 개발자를 당황하게 만드는 경우가 많습니다. “앗, 방금 뭘 한 거지?” 싶은 순간은 누구에게나 찾아옵니다. 이 글에서는 checkout, stash, branch 등 핵심 명령어를 중심으로, 실제 현업에서 자주 겪는 20가지 트러블 슈팅 사례와 해결 방안을 구체적으로 정리했습니다.
Part 1: checkout 관련 문제 - “코드가 뒤섞였어요!” checkout은 브랜치를 바꾸거나 특정 버전으로 돌아갈 때 사용하지만, 이 과정에서 많은 실수가 발생합니다.
사례 1: 다른 브랜치로 이동하려는데, 작업하던 내용이 있어서 막힐 때 문제 상황: feature/new-login 브랜치에서 작업하던 중, 급하게 hotfix/bug-report 브랜치로 이동해야 합니다. git checkout hotfix/bug-report를 입력하니 “error: Your local changes to the following files would be overwritten by checkout…” 메시지가 나옵니다. 해결 방안: 아직 커밋하기 애매한 작업 내용을 임시 저장 공간(stash)에 저장합니다. # 현재 작업 내용을 스택에 임시 저장 git stash > `git stash`: 현재 작업 디렉터리의 변경된 파일(Tracked files)을 임시로 스택에 저장합니다. `push`, `pop`, `apply`, `list` 등의 하위 명령어를 통해 관리할 수 있습니다. # 원하는 브랜치로 이동하여 작업 수행 git checkout hotfix/bug-report # ... 핫픽스 작업 ... git commit -m "Fix: Critical bug" git push origin hotfix/bug-report # 원래 브랜치로 복귀 git checkout feature/new-login # 임시 저장했던 작업 내용 다시 적용 git stash pop 사례 2: 실수로 파일을 삭제했는데, 커밋은 아직 안 했을 때 (rm a.txt) 문제 상황: git rm이 아닌 rm 명령어로 파일을 삭제했습니다. git status에 “deleted: a.txt"로 표시됩니다.'><meta property="og:locale" content="ko-kr"><meta property="og:type" content="article"><meta property="article:section" content="dev"><meta property="article:published_time" content="2025-12-30T00:00:00+09:00"><meta property="article:modified_time" content="2025-12-30T00:00:00+09:00"><meta property="article:tag" content="Git"><meta property="article:tag" content="Troubleshooting"><meta property="article:tag" content="Checkout"><meta property="article:tag" content="Stash"><meta property="article:tag" content="Branch"><meta property="article:tag" content="Reset"><meta name=twitter:card content="summary"><meta name=twitter:title content="사례로 보는 Git 트러블 슈팅"><meta name=twitter:description content='Git은 강력하지만, 복잡한 상황에서는 개발자를 당황하게 만드는 경우가 많습니다. &ldquo;앗, 방금 뭘 한 거지?&rdquo; 싶은 순간은 누구에게나 찾아옵니다. 이 글에서는 checkout, stash, branch 등 핵심 명령어를 중심으로, 실제 현업에서 자주 겪는 20가지 트러블 슈팅 사례와 해결 방안을 구체적으로 정리했습니다.

Part 1: checkout 관련 문제 - &ldquo;코드가 뒤섞였어요!&rdquo;
checkout은 브랜치를 바꾸거나 특정 버전으로 돌아갈 때 사용하지만, 이 과정에서 많은 실수가 발생합니다.
사례 1: 다른 브랜치로 이동하려는데, 작업하던 내용이 있어서 막힐 때

문제 상황: feature/new-login 브랜치에서 작업하던 중, 급하게 hotfix/bug-report 브랜치로 이동해야 합니다. git checkout hotfix/bug-report를 입력하니 &ldquo;error: Your local changes to the following files would be overwritten by checkout&mldr;&rdquo; 메시지가 나옵니다.
해결 방안: 아직 커밋하기 애매한 작업 내용을 임시 저장 공간(stash)에 저장합니다.
# 현재 작업 내용을 스택에 임시 저장
git stash
> `git stash`: 현재 작업 디렉터리의 변경된 파일(Tracked files)을 임시로 스택에 저장합니다. `push`, `pop`, `apply`, `list` 등의 하위 명령어를 통해 관리할 수 있습니다.

# 원하는 브랜치로 이동하여 작업 수행
git checkout hotfix/bug-report
# ... 핫픽스 작업 ...
git commit -m "Fix: Critical bug"
git push origin hotfix/bug-report

# 원래 브랜치로 복귀
git checkout feature/new-login

# 임시 저장했던 작업 내용 다시 적용
git stash pop


사례 2: 실수로 파일을 삭제했는데, 커밋은 아직 안 했을 때 (rm a.txt)


문제 상황: git rm이 아닌 rm 명령어로 파일을 삭제했습니다. git status에 &ldquo;deleted: a.txt"로 표시됩니다.'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Devs","item":"https://cdecl.github.io/dev/"},{"@type":"ListItem","position":2,"name":"사례로 보는 Git 트러블 슈팅","item":"https://cdecl.github.io/dev/git-troubleshooting-examples/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"사례로 보는 Git 트러블 슈팅","name":"사례로 보는 Git 트러블 슈팅","description":"Git은 강력하지만, 복잡한 상황에서는 개발자를 당황하게 만드는 경우가 많습니다. \u0026ldquo;앗, 방금 뭘 한 거지?\u0026rdquo; 싶은 순간은 누구에게나 찾아옵니다. 이 글에서는 checkout, stash, branch 등 핵심 명령어를 중심으로, 실제 현업에서 자주 겪는 20가지 트러블 슈팅 사례와 해결 방안을 구체적으로 정리했습니다.\nPart 1: checkout 관련 문제 - \u0026ldquo;코드가 뒤섞였어요!\u0026rdquo; checkout은 브랜치를 바꾸거나 특정 버전으로 돌아갈 때 사용하지만, 이 과정에서 많은 실수가 발생합니다.\n사례 1: 다른 브랜치로 이동하려는데, 작업하던 내용이 있어서 막힐 때 문제 상황: feature/new-login 브랜치에서 작업하던 중, 급하게 hotfix/bug-report 브랜치로 이동해야 합니다. git checkout hotfix/bug-report를 입력하니 \u0026ldquo;error: Your local changes to the following files would be overwritten by checkout\u0026hellip;\u0026rdquo; 메시지가 나옵니다. 해결 방안: 아직 커밋하기 애매한 작업 내용을 임시 저장 공간(stash)에 저장합니다. # 현재 작업 내용을 스택에 임시 저장 git stash \u0026gt; `git stash`: 현재 작업 디렉터리의 변경된 파일(Tracked files)을 임시로 스택에 저장합니다. `push`, `pop`, `apply`, `list` 등의 하위 명령어를 통해 관리할 수 있습니다. # 원하는 브랜치로 이동하여 작업 수행 git checkout hotfix/bug-report # ... 핫픽스 작업 ... git commit -m \u0026#34;Fix: Critical bug\u0026#34; git push origin hotfix/bug-report # 원래 브랜치로 복귀 git checkout feature/new-login # 임시 저장했던 작업 내용 다시 적용 git stash pop 사례 2: 실수로 파일을 삭제했는데, 커밋은 아직 안 했을 때 (rm a.txt) 문제 상황: git rm이 아닌 rm 명령어로 파일을 삭제했습니다. git status에 \u0026ldquo;deleted: a.txt\u0026quot;로 표시됩니다.\n","keywords":["git","troubleshooting","checkout","stash","branch","reset","revert"],"articleBody":"Git은 강력하지만, 복잡한 상황에서는 개발자를 당황하게 만드는 경우가 많습니다. “앗, 방금 뭘 한 거지?” 싶은 순간은 누구에게나 찾아옵니다. 이 글에서는 checkout, stash, branch 등 핵심 명령어를 중심으로, 실제 현업에서 자주 겪는 20가지 트러블 슈팅 사례와 해결 방안을 구체적으로 정리했습니다.\nPart 1: checkout 관련 문제 - “코드가 뒤섞였어요!” checkout은 브랜치를 바꾸거나 특정 버전으로 돌아갈 때 사용하지만, 이 과정에서 많은 실수가 발생합니다.\n사례 1: 다른 브랜치로 이동하려는데, 작업하던 내용이 있어서 막힐 때 문제 상황: feature/new-login 브랜치에서 작업하던 중, 급하게 hotfix/bug-report 브랜치로 이동해야 합니다. git checkout hotfix/bug-report를 입력하니 “error: Your local changes to the following files would be overwritten by checkout…” 메시지가 나옵니다. 해결 방안: 아직 커밋하기 애매한 작업 내용을 임시 저장 공간(stash)에 저장합니다. # 현재 작업 내용을 스택에 임시 저장 git stash \u003e `git stash`: 현재 작업 디렉터리의 변경된 파일(Tracked files)을 임시로 스택에 저장합니다. `push`, `pop`, `apply`, `list` 등의 하위 명령어를 통해 관리할 수 있습니다. # 원하는 브랜치로 이동하여 작업 수행 git checkout hotfix/bug-report # ... 핫픽스 작업 ... git commit -m \"Fix: Critical bug\" git push origin hotfix/bug-report # 원래 브랜치로 복귀 git checkout feature/new-login # 임시 저장했던 작업 내용 다시 적용 git stash pop 사례 2: 실수로 파일을 삭제했는데, 커밋은 아직 안 했을 때 (rm a.txt) 문제 상황: git rm이 아닌 rm 명령어로 파일을 삭제했습니다. git status에 “deleted: a.txt\"로 표시됩니다.\n해결 방안: checkout을 사용해 현재 브랜치(HEAD)의 마지막 커밋 상태에서 해당 파일을 복원합니다.\n# a.txt 파일을 마지막 커밋 상태로 복원 git checkout HEAD -- a.txt git checkout -- : 특정 커밋 상태의 특정 파일을 현재 작업 디렉터리로 복원합니다. --는 브랜치/커밋과 파일 경로를 명확하게 구분하는 역할을 합니다.\n– 를 사용하면 브랜치 이름과 파일 이름을 명확히 구분할 수 있어 안전합니다. 사례 3: 브랜치를 옮기지 않고 다른 브랜치의 파일 내용만 보고 싶을 때 문제 상황: 현재 브랜치는 feature인데, main 브랜치의 config.yml 파일 내용과 비교하고 싶습니다. 브랜치를 통째로 옮기기엔 부담스럽습니다. 해결 방안: git show 또는 git checkout을 특정 파일에 대해서만 실행합니다. # 1. git show 사용 (단순 조회) git show main:path/to/config.yml \u003e `git show :`: 브랜치를 변경하지 않고, 다른 브랜치에 있는 파일의 내용을 터미널에 출력합니다. # 2. git checkout 사용 (현재 작업 디렉터리로 가져오기) git checkout main -- path/to/config.yml # 위 명령은 `main` 브랜치의 `config.yml`을 현재 디렉터리로 가져와 덮어씁니다. # 주의: 현재 작업 디렉터리의 내용이 변경됩니다. 사례 4: “Detached HEAD” 상태가 되었을 때 문제 상황: git checkout 나 git checkout origin/main 처럼 브랜치가 아닌 포인터를 직접 체크아웃하면 “You are in ‘detached HEAD’ state.” 라는 메시지가 나옵니다. 이 상태에서 작업하고 커밋하면 해당 커밋은 어떤 브랜치에도 속하지 않게 되어 나중에 잃어버릴 수 있습니다.\n해결 방안: 현재 “Detached HEAD” 상태에서 새로운 브랜치를 만들어 작업을 이어갑니다.\n# 현재 위치에서 'temp-work' 라는 새 브랜치를 생성 git checkout -b temp-work git checkout -b : 현재 위치(커밋)에서 새로운 브랜치를 생성하고, 즉시 해당 브랜치로 전환합니다.\n이제 ’temp-work’ 브랜치에서 안전하게 커밋을 이어갈 수 있습니다. git add . git commit -m “Add new feature from detached state”\n사례 5: 과거의 특정 파일 버전 하나만 현재 브랜치로 가져오고 싶을 때 문제 상황: config.js 파일의 과거 버전이 필요합니다. 3개의 커밋 전(HEAD~3) 버전의 config.js만 현재 작업 내용에 덮어쓰고 싶습니다. 해결 방안: git checkout에 커밋 해시와 파일 경로를 지정합니다. # 3개 커밋 전 버전의 'config.js'를 현재 디렉터리로 가져옴 git checkout HEAD~3 -- src/config.js git checkout -- : 특정 커밋에 해당하는 파일의 버전으로 현재 작업 디렉터리의 파일을 덮어씁니다.\nPart 2: stash 관련 문제 - “작업 내용이 사라졌어요!” stash는 매우 유용한 임시 저장 기능이지만, 여러 개가 쌓이면 혼란스러워집니다.\n사례 6: Stash 이름 없이 저장해서 뭐가 뭔지 모를 때 문제 상황: 여러 번 git stash를 실행했더니 stash@{0}, stash@{1} … 목록만 있고, 어떤 내용이 저장되었는지 기억나지 않습니다.\n해결 방안 1: git stash list로 목록을 보고, git stash show로 각 내용을 확인합니다.\ngit stash list # stash@{0}: WIP on feature/login: ... # stash@{1}: WIP on feature/login: ... # stash@{1}의 변경 내용 요약 보기 git stash show stash@{1} # stash@{1}의 변경 내용 상세 보기 (diff) git stash show -p stash@{1} git stash list: 현재 저장된 모든 stash 목록을 최신 순으로 보여줍니다.\n해결 방안 2: 처음부터 git stash push -m \"메시지\" 로 저장합니다. (git stash save는 더 이상 권장되지 않습니다.)\ngit stash push -m \"Finish login UI, before API integration\" 사례 7: Untracked 파일(새로 만든 파일)은 stash에 포함되지 않았을 때 문제 상황: 새로 만든 파일(new-component.js)과 기존 파일 수정을 함께 git stash했는데, 브랜치를 옮겼다 돌아와 stash pop하니 새로 만든 파일이 사라졌습니다. 해결 방안: stash 시 -u 또는 --include-untracked 옵션을 사용합니다. # Untracked 파일까지 포함하여 stash git stash -u 사례 8: 다른 브랜치에서 작업한 내용을 현재 브랜치에 적용하고 싶을 때 문제 상황: feature/A에서 작업하던 내용을 커밋 없이 stash하고, feature/B로 넘어왔습니다. feature/A의 작업 내용 일부가 feature/B에서도 필요합니다. 해결 방안: git stash branch를 사용해 stash로부터 새로운 브랜치를 생성합니다. # 현재 `feature/B` 브랜치에서... # 가장 최근의 stash (stash@{0}) 내용으로 'temp-branch' 생성 git stash branch temp-branch stash@{0} # 이제 'temp-branch'는 'feature/A'에서 작업하던 내용을 커밋할 수 있는 상태가 됩니다. # 여기서 필요한 내용을 커밋한 뒤, 'feature/B'에서 `cherry-pick` 등으로 가져올 수 있습니다. 사례 9: stash pop 실행 시 충돌(Conflict)이 발생했을 때 문제 상황: stash를 한 이후, 현재 브랜치에서 stash에 저장된 내용과 동일한 라인을 수정했습니다. git stash pop을 하니 충돌이 발생합니다.\n해결 방안: 일반적인 merge 충돌과 동일하게 해결합니다.\n충돌이 발생한 파일을 열어 \u003c\u003c\u003c\u003c\u003c, =====, \u003e\u003e\u003e\u003e\u003e 마커를 확인하고 코드를 올바르게 수정합니다. 수정한 파일을 git add 합니다. git stash drop을 실행하여 적용된 stash를 스택에서 제거합니다. (pop은 충돌 시 자동으로 drop되지 않습니다.) # 1. 코드 수정 후 git add . # 2. 변경 사항 커밋 (필요 시) git commit -m \"Resolve stash conflict\" # 3. 적용된 stash 제거 git stash drop 사례 10: 실수로 stash clear를 실행하여 모든 stash가 사라졌을 때 문제 상황: 중요한 내용이 stash에 있었는데, git stash clear로 모두 삭제해버렸습니다. 해결 방안: Git이 아직 가비지 컬렉션(GC)을 실행하지 않았다면, fsck로 복구할 수 있습니다. # Git 데이터베이스에서 유효성을 검사하며 \"dangling\" 객체를 찾음 git fsck --no-reflogs # ... 수많은 해시값 출력 ... # 위에서 찾은 \"dangling commit\" 해시들을 하나씩 확인하여 stash 내용을 찾음 git show # 원하는 stash를 찾았다면, 해당 커밋에서 브랜치를 만들어 복구 git branch recovered-stash 이 방법은 복잡하고 항상 성공하는 것은 아니므로, 중요한 작업은 stash보다는 커밋으로 남기는 습관이 좋습니다. Part 3: branch 및 병합 관련 문제 - “브랜치가 꼬였어요!” 브랜치 전략은 협업의 핵심이며, 가장 많은 문제가 발생하는 곳이기도 합니다.\n사례 11: main 브랜치에 직접 커밋해버렸을 때 문제 상황: feature 브랜치에서 작업해야 할 내용을 실수로 main 브랜치에 커밋했습니다. 아직 push는 하지 않았습니다. 해결 방안: main 브랜치를 이전 커밋으로 되돌리고, 새 브랜치를 만들어 해당 커밋을 가져옵니다. # 1. 현재 `main` 브랜치에서... # 올바른 `feature` 브랜치를 생성 git branch feature/my-work # 2. `main` 브랜치를 이전 상태로 되돌림 (실수로 한 커밋 제거) # origin/main, 즉 원격 저장소의 상태로 강제 리셋 git reset --hard origin/main # 3. 이제 새 브랜치로 이동하여 작업을 이어감 git checkout feature/my-work 사례 12: 실수로 push까지 해버린 커밋을 되돌리고 싶을 때 문제 상황: main에 잘못 커밋하고 push까지 해버렸습니다. 다른 팀원들이 pull 받기 전에 빨리 조치해야 합니다. 해결 방안: revert를 사용하여 “잘못된 커밋을 되돌리는 새로운 커밋\"을 만듭니다. # `main` 브랜치에서... # 되돌리고 싶은 마지막 커밋을 타겟으로 `revert` 실행 git revert HEAD # revert 커밋 메시지 저장 후, 변경 사항을 push git push origin main reset --hard 후 push -f를 하는 것은 팀원들의 히스토리를 엉망으로 만들 수 있으므로, 공유된 브랜치에서는 절대적으로 피해야 합니다. revert가 안전한 대안입니다. 사례 13: 브랜치 이름을 변경하고 싶을 때 (로컬 \u0026 원격) 문제 상황: 브랜치 이름에 오타가 있거나, 컨벤션을 따르지 않아 변경하고 싶습니다. (예: feture/login -\u003e feature/login) 해결 방안: # 1. 현재 브랜치 이름 변경 git branch -m feature/login # 2. 원격의 옛날 브랜치 삭제 git push origin --delete feture/login # 3. 새로 바꾼 이름의 브랜치를 원격에 push git push origin -u feature/login 사례 14: 다른 브랜치의 특정 커밋 하나만 현재 브랜치로 가져오고 싶을 때 문제 상황: hotfix 브랜치에서 수정한 버그 픽스 커밋(a1b2c3d)이 현재 개발 중인 feature 브랜치에도 즉시 필요합니다. 해결 방안: cherry-pick을 사용합니다. # `feature` 브랜치에서... git cherry-pick a1b2c3d 사례 15: 너무 자잘하게 나눠진 커밋들을 하나로 합치고 싶을 때 (Push 전) 문제 상황: “Fix typo”, “Add comment”, “Refactor” 등 의미 없는 커밋이 너무 많아 PR 올리기 전에 정리하고 싶습니다. 해결 방안: rebase -i (interactive rebase)를 사용합니다. # 합치고 싶은 커밋의 *이전* 커밋 해시를 지정 (예: 최근 3개) git rebase -i HEAD~3 위 명령을 실행하면 편집기가 열리고, 커밋 목록이 나옵니다. 맨 위 커밋은 pick으로 두고, 나머지 커밋 앞의 pick을 s 또는 squash로 변경합니다. 저장하고 닫으면, 커밋 메시지를 새로 작성하는 창이 열립니다. 하나의 깔끔한 메시지로 정리합니다. Part 4: 기타 고급 트러블 슈팅 사례 16: 실수로 git add 한 파일을 다시 내리고 싶을 때 문제 상황: 커밋하고 싶지 않은 파일(secret.key)을 실수로 Staging Area에 추가(add)했습니다. 해결 방안: git reset을 사용합니다. # 특정 파일만 Staging Area에서 내림 git reset HEAD secret.key # 모든 파일을 Staging Area에서 내림 git reset 사례 17: 마지막 커밋 메시지에 오타가 있을 때 문제 상황: 방금 커밋했는데, 메시지에 오타가 있습니다. 아직 push는 안했습니다. 해결 방안: commit --amend를 사용합니다. git commit --amend # 편집기가 열리면 메시지를 수정하고 저장 주의: push 한 커밋에는 절대 사용하면 안 됩니다. 사례 18: 브랜치를 삭제했는데, 다시 복구해야 할 때 문제 상황: git branch -D my-feature로 브랜치를 강제 삭제했는데, 아직 main에 병합되지 않은 중요한 커밋이 있었습니다. 해결 방안: reflog를 사용하여 Git의 모든 참조 변경 기록을 확인합니다. git reflog # ... # a1b2c3d HEAD@{5}: checkout: moving from my-feature to main # ... # 삭제된 브랜치의 마지막 커밋 해시(a1b2c3d)를 찾았다면, # 해당 커밋에서 브랜치를 다시 생성 git checkout -b recovered-feature a1b2c3d 사례 19: 현재 작업 내용 전체를 특정 과거 커밋 시점으로 되돌리고 싶을 때 문제 상황: 최근 몇 개의 커밋이 완전히 잘못된 방향으로 진행되어, a1b2c3d 커밋 시점으로 모든 것을 되돌리고 싶습니다. 로컬에서의 변경 사항이므로 히스토리가 깨져도 상관없습니다. 해결 방안: reset --hard를 사용합니다. (경고: 복구 불가능한 데이터 손실을 유발할 수 있습니다!) # 모든 변경사항, 커밋을 버리고 'a1b2c3d' 상태로 돌아감 git reset --hard a1b2c3d 사례 20: pull을 받았더니 관련 없는 커밋 히스토리가 잔뜩 병합될 때 문제 상황: main 브랜치에서 feature 브랜치를 따서 작업 후, feature 브랜치에서 git pull origin main을 실행했습니다. 의도와 달리 수많은 main의 커밋들이 Merge branch 'main' into feature 라는 메시지와 함께 들어왔습니다. 해결 방안: pull 시 rebase 옵션을 사용하거나, git config로 기본값으로 설정합니다. Rebase는 main의 변경사항을 내 브랜치의 “베이스\"로 다시 설정하여, 내 커밋들을 그 위에 차곡차곡 쌓아줍니다. 히스토리가 훨씬 깔끔해집니다. # 1. 일회성으로 rebase pull 실행 git pull origin main --rebase # 2. 향후 모든 pull을 rebase로 실행하도록 설정 git config --global pull.rebase true 사례 21: 특정 커밋을 찾기 위해 로그를 효율적으로 검색하고 싶을 때 문제 상황: 프로젝트 히스토리가 길어져서 특정 기능이 언제 추가되었는지, 특정 파일이 언제 마지막으로 수정되었는지 찾기 어렵습니다.\n해결 방안: git log의 다양한 옵션을 활용하여 히스토리를 필터링합니다.\n# 한 줄로 로그를 깔끔하게 보기 git log --oneline --graph git log --oneline: 각 커밋을 한 줄로 요약하여 보여줍니다. --graph 옵션을 함께 사용하면 브랜치의 분기 및 병합 히스토리를 시각적으로 파악하기 좋습니다.\n# 특정 파일의 변경 이력만 보기 git log -p -- src/components/Button.js # 특정 기간 동안의 커밋만 보기 git log --since=\"2 weeks ago\" # 특정 작성자의 커밋만 보기 git log --author=\"cdecl\" # 커밋 메시지에서 특정 키워드로 검색하기 git log --grep=\"keyword\" # 코드 변경 내용(diff)에서 특정 문자열이 추가/삭제된 커밋 검색 git log -S\"UserService\" # 코드 변경 내용(diff)에서 정규식으로 특정 패턴을 검색 git log -G\"Login(Service|Manager)\" # 두 커밋 사이의 모든 커밋 보기 git log a1b2c3d..f4e5d6c git log --grep은 커밋 메시지를 검색하지만, git log -S는 실제 코드 변경 내용(diff)에서 특정 문자열의 증감(추가/삭제)이 발생한 커밋을 찾아줍니다. git log -G는 -S와 유사하게 코드 변경 내용에서 정규표현식으로 특정 패턴을 검색할 때 사용합니다. 이 옵션들과 함께 -p를 사용하면 해당 커밋의 전체 diff를 함께 볼 수 있어 변경 내용을 상세히 파악하는 데 매우 유용합니다.\n사례 22: 모든 변경 사항 취소하기 (Tracked + Untracked) 문제 상황: 작업하던 모든 변경 사항을 취소하고 현재 HEAD 상태로 깨끗하게 되돌리고 싶습니다. 이미 수정한 파일(tracked)과 새로 만든 파일(untracked)을 모두 삭제하고 싶습니다.\n해결 방안: 다음 명령들을 조합하여 사용합니다.\n# 1. Tracked 파일 모두 복원 (Working Directory + Staging Area 초기화) git reset --hard HEAD # 2. Untracked 파일 모두 삭제 git clean -fd git reset --hard HEAD: Working Directory와 Staging Area를 마지막 커밋 상태로 되돌립니다. tracked 파일의 모든 변경 사항을 취소합니다. untracked 파일은 삭제하지 않습니다.\ngit clean -fd: 추적하지 않는 파일(-f)과 디렉터리(-d)를 모두 삭제합니다. 주의: 영구적으로 삭제되므로 복구할 수 없습니다!\nVSCode “Discard All Changes\"와의 차이: VSCode의 “Discard All Changes” 버튼은 git restore와 git clean -fd를 사용합니다. 이 방식은 git reset --hard와 달리 Staging Area의 파일을 처리하지 않습니다. 따라서 명령줄에서 직접 모든 변경 사항을 취소할 때는 git reset --hard HEAD \u0026\u0026 git clean -fd를 사용하는 것이 더 확실합니다.\n참고: 특정 파일만 취소하려면:\n# 특정 파일만 취소 (untracked 파일에 대해서는 동작하지 않음) git restore # 또는 git checkout HEAD -- 팁: 삭제하기 전에 변경 사항을 저장하고 싶다면:\n# untracked 파일까지 포함하여 저장 git stash push -u # 나중에 복원 git stash pop Git 트러블 슈팅의 핵심은 “무엇을 하려 했는가\"와 “실제로 무슨 일이 일어났는가\"의 차이를 이해하는 것입니다. 이 글에서 소개된 사례들을 통해, 예상치 못한 상황에 더 자신감 있게 대처할 수 있기를 바랍니다.\n","wordCount":"2067","inLanguage":"en","datePublished":"2025-12-30T00:00:00+09:00","dateModified":"2025-12-30T00:00:00+09:00","author":{"@type":"Person","name":"Byung Kyu KIM"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://cdecl.github.io/dev/git-troubleshooting-examples/"},"publisher":{"@type":"Organization","name":"cdeclog","logo":{"@type":"ImageObject","url":"https://cdecl.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://cdecl.github.io/ accesskey=h title="cdeclog (Alt + H)">cdeclog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://cdecl.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://cdecl.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://cdecl.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">사례로 보는 Git 트러블 슈팅</h1><div class=post-meta><span title='2025-12-30 00:00:00 +0900 KST'>December 30, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><ul><li><a href=#part-1-checkout-%ea%b4%80%eb%a0%a8-%eb%ac%b8%ec%a0%9c---%ec%bd%94%eb%93%9c%ea%b0%80-%eb%92%a4%ec%84%9e%ec%98%80%ec%96%b4%ec%9a%94 aria-label="Part 1: checkout 관련 문제 - &ldquo;코드가 뒤섞였어요!&rdquo;">Part 1: checkout 관련 문제 - &ldquo;코드가 뒤섞였어요!&rdquo;</a><ul><ul><li><a href=#%ec%82%ac%eb%a1%80-1-%eb%8b%a4%eb%a5%b8-%eb%b8%8c%eb%9e%9c%ec%b9%98%eb%a1%9c-%ec%9d%b4%eb%8f%99%ed%95%98%eb%a0%a4%eb%8a%94%eb%8d%b0-%ec%9e%91%ec%97%85%ed%95%98%eb%8d%98-%eb%82%b4%ec%9a%a9%ec%9d%b4-%ec%9e%88%ec%96%b4%ec%84%9c-%eb%a7%89%ed%9e%90-%eb%95%8c aria-label="사례 1: 다른 브랜치로 이동하려는데, 작업하던 내용이 있어서 막힐 때">사례 1: 다른 브랜치로 이동하려는데, 작업하던 내용이 있어서 막힐 때</a></li><li><a href=#%ec%82%ac%eb%a1%80-2-%ec%8b%a4%ec%88%98%eb%a1%9c-%ed%8c%8c%ec%9d%bc%ec%9d%84-%ec%82%ad%ec%a0%9c%ed%96%88%eb%8a%94%eb%8d%b0-%ec%bb%a4%eb%b0%8b%ec%9d%80-%ec%95%84%ec%a7%81-%ec%95%88-%ed%96%88%ec%9d%84-%eb%95%8c-rm-atxt aria-label="사례 2: 실수로 파일을 삭제했는데, 커밋은 아직 안 했을 때 (rm a.txt)">사례 2: 실수로 파일을 삭제했는데, 커밋은 아직 안 했을 때 (rm a.txt)</a></li></ul></ul></li></ul><li><a href=#-%eb%a5%bc-%ec%82%ac%ec%9a%a9%ed%95%98%eb%a9%b4-%eb%b8%8c%eb%9e%9c%ec%b9%98-%ec%9d%b4%eb%a6%84%ea%b3%bc-%ed%8c%8c%ec%9d%bc-%ec%9d%b4%eb%a6%84%ec%9d%84-%eb%aa%85%ed%99%95%ed%9e%88-%ea%b5%ac%eb%b6%84%ed%95%a0-%ec%88%98-%ec%9e%88%ec%96%b4-%ec%95%88%ec%a0%84%ed%95%a9%eb%8b%88%eb%8b%a4 aria-label="&ndash; 를 사용하면 브랜치 이름과 파일 이름을 명확히 구분할 수 있어 안전합니다.">&ndash; 를 사용하면 브랜치 이름과 파일 이름을 명확히 구분할 수 있어 안전합니다.</a><ul><ul><ul><li><a href=#%ec%82%ac%eb%a1%80-3-%eb%b8%8c%eb%9e%9c%ec%b9%98%eb%a5%bc-%ec%98%ae%ea%b8%b0%ec%a7%80-%ec%95%8a%ea%b3%a0-%eb%8b%a4%eb%a5%b8-%eb%b8%8c%eb%9e%9c%ec%b9%98%ec%9d%98-%ed%8c%8c%ec%9d%bc-%eb%82%b4%ec%9a%a9%eb%a7%8c-%eb%b3%b4%ea%b3%a0-%ec%8b%b6%ec%9d%84-%eb%95%8c aria-label="사례 3: 브랜치를 옮기지 않고 다른 브랜치의 파일 내용만 보고 싶을 때">사례 3: 브랜치를 옮기지 않고 다른 브랜치의 파일 내용만 보고 싶을 때</a></li><li><a href=#%ec%82%ac%eb%a1%80-4-detached-head-%ec%83%81%ed%83%9c%ea%b0%80-%eb%90%98%ec%97%88%ec%9d%84-%eb%95%8c aria-label="사례 4: &ldquo;Detached HEAD&rdquo; 상태가 되었을 때">사례 4: &ldquo;Detached HEAD&rdquo; 상태가 되었을 때</a></li></ul></ul></ul></li><li><a href=#%ec%9d%b4%ec%a0%9c-temp-work-%eb%b8%8c%eb%9e%9c%ec%b9%98%ec%97%90%ec%84%9c-%ec%95%88%ec%a0%84%ed%95%98%ea%b2%8c-%ec%bb%a4%eb%b0%8b%ec%9d%84-%ec%9d%b4%ec%96%b4%ea%b0%88-%ec%88%98-%ec%9e%88%ec%8a%b5%eb%8b%88%eb%8b%a4 aria-label="이제 &rsquo;temp-work&rsquo; 브랜치에서 안전하게 커밋을 이어갈 수 있습니다.">이제 &rsquo;temp-work&rsquo; 브랜치에서 안전하게 커밋을 이어갈 수 있습니다.</a><ul><ul><ul><li><a href=#%ec%82%ac%eb%a1%80-5-%ea%b3%bc%ea%b1%b0%ec%9d%98-%ed%8a%b9%ec%a0%95-%ed%8c%8c%ec%9d%bc-%eb%b2%84%ec%a0%84-%ed%95%98%eb%82%98%eb%a7%8c-%ed%98%84%ec%9e%ac-%eb%b8%8c%eb%9e%9c%ec%b9%98%eb%a1%9c-%ea%b0%80%ec%a0%b8%ec%98%a4%ea%b3%a0-%ec%8b%b6%ec%9d%84-%eb%95%8c aria-label="사례 5: 과거의 특정 파일 버전 하나만 현재 브랜치로 가져오고 싶을 때">사례 5: 과거의 특정 파일 버전 하나만 현재 브랜치로 가져오고 싶을 때</a></li></ul></ul><li><a href=#part-2-stash-%ea%b4%80%eb%a0%a8-%eb%ac%b8%ec%a0%9c---%ec%9e%91%ec%97%85-%eb%82%b4%ec%9a%a9%ec%9d%b4-%ec%82%ac%eb%9d%bc%ec%a1%8c%ec%96%b4%ec%9a%94 aria-label="Part 2: stash 관련 문제 - &ldquo;작업 내용이 사라졌어요!&rdquo;">Part 2: stash 관련 문제 - &ldquo;작업 내용이 사라졌어요!&rdquo;</a><ul><ul><li><a href=#%ec%82%ac%eb%a1%80-6-stash-%ec%9d%b4%eb%a6%84-%ec%97%86%ec%9d%b4-%ec%a0%80%ec%9e%a5%ed%95%b4%ec%84%9c-%eb%ad%90%ea%b0%80-%eb%ad%94%ec%a7%80-%eb%aa%a8%eb%a5%bc-%eb%95%8c aria-label="사례 6: Stash 이름 없이 저장해서 뭐가 뭔지 모를 때">사례 6: Stash 이름 없이 저장해서 뭐가 뭔지 모를 때</a></li><li><a href=#%ec%82%ac%eb%a1%80-7-untracked-%ed%8c%8c%ec%9d%bc%ec%83%88%eb%a1%9c-%eb%a7%8c%eb%93%a0-%ed%8c%8c%ec%9d%bc%ec%9d%80-stash%ec%97%90-%ed%8f%ac%ed%95%a8%eb%90%98%ec%a7%80-%ec%95%8a%ec%95%98%ec%9d%84-%eb%95%8c aria-label="사례 7: Untracked 파일(새로 만든 파일)은 stash에 포함되지 않았을 때">사례 7: Untracked 파일(새로 만든 파일)은 stash에 포함되지 않았을 때</a></li><li><a href=#%ec%82%ac%eb%a1%80-8-%eb%8b%a4%eb%a5%b8-%eb%b8%8c%eb%9e%9c%ec%b9%98%ec%97%90%ec%84%9c-%ec%9e%91%ec%97%85%ed%95%9c-%eb%82%b4%ec%9a%a9%ec%9d%84-%ed%98%84%ec%9e%ac-%eb%b8%8c%eb%9e%9c%ec%b9%98%ec%97%90-%ec%a0%81%ec%9a%a9%ed%95%98%ea%b3%a0-%ec%8b%b6%ec%9d%84-%eb%95%8c aria-label="사례 8: 다른 브랜치에서 작업한 내용을 현재 브랜치에 적용하고 싶을 때">사례 8: 다른 브랜치에서 작업한 내용을 현재 브랜치에 적용하고 싶을 때</a></li><li><a href=#%ec%82%ac%eb%a1%80-9-stash-pop-%ec%8b%a4%ed%96%89-%ec%8b%9c-%ec%b6%a9%eb%8f%8cconflict%ec%9d%b4-%eb%b0%9c%ec%83%9d%ed%96%88%ec%9d%84-%eb%95%8c aria-label="사례 9: stash pop 실행 시 충돌(Conflict)이 발생했을 때">사례 9: stash pop 실행 시 충돌(Conflict)이 발생했을 때</a></li><li><a href=#%ec%82%ac%eb%a1%80-10-%ec%8b%a4%ec%88%98%eb%a1%9c-stash-clear%eb%a5%bc-%ec%8b%a4%ed%96%89%ed%95%98%ec%97%ac-%eb%aa%a8%eb%93%a0-stash%ea%b0%80-%ec%82%ac%eb%9d%bc%ec%a1%8c%ec%9d%84-%eb%95%8c aria-label="사례 10: 실수로 stash clear를 실행하여 모든 stash가 사라졌을 때">사례 10: 실수로 stash clear를 실행하여 모든 stash가 사라졌을 때</a></li></ul></ul></li><li><a href=#part-3-branch-%eb%b0%8f-%eb%b3%91%ed%95%a9-%ea%b4%80%eb%a0%a8-%eb%ac%b8%ec%a0%9c---%eb%b8%8c%eb%9e%9c%ec%b9%98%ea%b0%80-%ea%bc%ac%ec%98%80%ec%96%b4%ec%9a%94 aria-label="Part 3: branch 및 병합 관련 문제 - &ldquo;브랜치가 꼬였어요!&rdquo;">Part 3: branch 및 병합 관련 문제 - &ldquo;브랜치가 꼬였어요!&rdquo;</a><ul><ul><li><a href=#%ec%82%ac%eb%a1%80-11-main-%eb%b8%8c%eb%9e%9c%ec%b9%98%ec%97%90-%ec%a7%81%ec%a0%91-%ec%bb%a4%eb%b0%8b%ed%95%b4%eb%b2%84%eb%a0%b8%ec%9d%84-%eb%95%8c aria-label="사례 11: main 브랜치에 직접 커밋해버렸을 때">사례 11: main 브랜치에 직접 커밋해버렸을 때</a></li><li><a href=#%ec%82%ac%eb%a1%80-12-%ec%8b%a4%ec%88%98%eb%a1%9c-push%ea%b9%8c%ec%a7%80-%ed%95%b4%eb%b2%84%eb%a6%b0-%ec%bb%a4%eb%b0%8b%ec%9d%84-%eb%90%98%eb%8f%8c%eb%a6%ac%ea%b3%a0-%ec%8b%b6%ec%9d%84-%eb%95%8c aria-label="사례 12: 실수로 push까지 해버린 커밋을 되돌리고 싶을 때">사례 12: 실수로 push까지 해버린 커밋을 되돌리고 싶을 때</a></li><li><a href=#%ec%82%ac%eb%a1%80-13-%eb%b8%8c%eb%9e%9c%ec%b9%98-%ec%9d%b4%eb%a6%84%ec%9d%84-%eb%b3%80%ea%b2%bd%ed%95%98%ea%b3%a0-%ec%8b%b6%ec%9d%84-%eb%95%8c-%eb%a1%9c%ec%bb%ac--%ec%9b%90%ea%b2%a9 aria-label="사례 13: 브랜치 이름을 변경하고 싶을 때 (로컬 & 원격)">사례 13: 브랜치 이름을 변경하고 싶을 때 (로컬 & 원격)</a></li><li><a href=#%ec%82%ac%eb%a1%80-14-%eb%8b%a4%eb%a5%b8-%eb%b8%8c%eb%9e%9c%ec%b9%98%ec%9d%98-%ed%8a%b9%ec%a0%95-%ec%bb%a4%eb%b0%8b-%ed%95%98%eb%82%98%eb%a7%8c-%ed%98%84%ec%9e%ac-%eb%b8%8c%eb%9e%9c%ec%b9%98%eb%a1%9c-%ea%b0%80%ec%a0%b8%ec%98%a4%ea%b3%a0-%ec%8b%b6%ec%9d%84-%eb%95%8c aria-label="사례 14: 다른 브랜치의 특정 커밋 하나만 현재 브랜치로 가져오고 싶을 때">사례 14: 다른 브랜치의 특정 커밋 하나만 현재 브랜치로 가져오고 싶을 때</a></li><li><a href=#%ec%82%ac%eb%a1%80-15-%eb%84%88%eb%ac%b4-%ec%9e%90%ec%9e%98%ed%95%98%ea%b2%8c-%eb%82%98%eb%88%a0%ec%a7%84-%ec%bb%a4%eb%b0%8b%eb%93%a4%ec%9d%84-%ed%95%98%eb%82%98%eb%a1%9c-%ed%95%a9%ec%b9%98%ea%b3%a0-%ec%8b%b6%ec%9d%84-%eb%95%8c-push-%ec%a0%84 aria-label="사례 15: 너무 자잘하게 나눠진 커밋들을 하나로 합치고 싶을 때 (Push 전)">사례 15: 너무 자잘하게 나눠진 커밋들을 하나로 합치고 싶을 때 (Push 전)</a></li></ul></ul></li><li><a href=#part-4-%ea%b8%b0%ed%83%80-%ea%b3%a0%ea%b8%89-%ed%8a%b8%eb%9f%ac%eb%b8%94-%ec%8a%88%ed%8c%85 aria-label="Part 4: 기타 고급 트러블 슈팅">Part 4: 기타 고급 트러블 슈팅</a><ul><ul><li><a href=#%ec%82%ac%eb%a1%80-16-%ec%8b%a4%ec%88%98%eb%a1%9c-git-add-%ed%95%9c-%ed%8c%8c%ec%9d%bc%ec%9d%84-%eb%8b%a4%ec%8b%9c-%eb%82%b4%eb%a6%ac%ea%b3%a0-%ec%8b%b6%ec%9d%84-%eb%95%8c aria-label="사례 16: 실수로 git add 한 파일을 다시 내리고 싶을 때">사례 16: 실수로 git add 한 파일을 다시 내리고 싶을 때</a></li><li><a href=#%ec%82%ac%eb%a1%80-17-%eb%a7%88%ec%a7%80%eb%a7%89-%ec%bb%a4%eb%b0%8b-%eb%a9%94%ec%8b%9c%ec%a7%80%ec%97%90-%ec%98%a4%ed%83%80%ea%b0%80-%ec%9e%88%ec%9d%84-%eb%95%8c aria-label="사례 17: 마지막 커밋 메시지에 오타가 있을 때">사례 17: 마지막 커밋 메시지에 오타가 있을 때</a></li><li><a href=#%ec%82%ac%eb%a1%80-18-%eb%b8%8c%eb%9e%9c%ec%b9%98%eb%a5%bc-%ec%82%ad%ec%a0%9c%ed%96%88%eb%8a%94%eb%8d%b0-%eb%8b%a4%ec%8b%9c-%eb%b3%b5%ea%b5%ac%ed%95%b4%ec%95%bc-%ed%95%a0-%eb%95%8c aria-label="사례 18: 브랜치를 삭제했는데, 다시 복구해야 할 때">사례 18: 브랜치를 삭제했는데, 다시 복구해야 할 때</a></li><li><a href=#%ec%82%ac%eb%a1%80-19-%ed%98%84%ec%9e%ac-%ec%9e%91%ec%97%85-%eb%82%b4%ec%9a%a9-%ec%a0%84%ec%b2%b4%eb%a5%bc-%ed%8a%b9%ec%a0%95-%ea%b3%bc%ea%b1%b0-%ec%bb%a4%eb%b0%8b-%ec%8b%9c%ec%a0%90%ec%9c%bc%eb%a1%9c-%eb%90%98%eb%8f%8c%eb%a6%ac%ea%b3%a0-%ec%8b%b6%ec%9d%84-%eb%95%8c aria-label="사례 19: 현재 작업 내용 전체를 특정 과거 커밋 시점으로 되돌리고 싶을 때">사례 19: 현재 작업 내용 전체를 특정 과거 커밋 시점으로 되돌리고 싶을 때</a></li><li><a href=#%ec%82%ac%eb%a1%80-20-pull%ec%9d%84-%eb%b0%9b%ec%95%98%eb%8d%94%eb%8b%88-%ea%b4%80%eb%a0%a8-%ec%97%86%eb%8a%94-%ec%bb%a4%eb%b0%8b-%ed%9e%88%ec%8a%a4%ed%86%a0%eb%a6%ac%ea%b0%80-%ec%9e%94%eb%9c%a9-%eb%b3%91%ed%95%a9%eb%90%a0-%eb%95%8c aria-label="사례 20: pull을 받았더니 관련 없는 커밋 히스토리가 잔뜩 병합될 때">사례 20: pull을 받았더니 관련 없는 커밋 히스토리가 잔뜩 병합될 때</a></li><li><a href=#%ec%82%ac%eb%a1%80-21-%ed%8a%b9%ec%a0%95-%ec%bb%a4%eb%b0%8b%ec%9d%84-%ec%b0%be%ea%b8%b0-%ec%9c%84%ed%95%b4-%eb%a1%9c%ea%b7%b8%eb%a5%bc-%ed%9a%a8%ec%9c%a8%ec%a0%81%ec%9c%bc%eb%a1%9c-%ea%b2%80%ec%83%89%ed%95%98%ea%b3%a0-%ec%8b%b6%ec%9d%84-%eb%95%8c aria-label="사례 21: 특정 커밋을 찾기 위해 로그를 효율적으로 검색하고 싶을 때">사례 21: 특정 커밋을 찾기 위해 로그를 효율적으로 검색하고 싶을 때</a></li><li><a href=#%ec%82%ac%eb%a1%80-22-%eb%aa%a8%eb%93%a0-%eb%b3%80%ea%b2%bd-%ec%82%ac%ed%95%ad-%ec%b7%a8%ec%86%8c%ed%95%98%ea%b8%b0-tracked--untracked aria-label="사례 22: 모든 변경 사항 취소하기 (Tracked + Untracked)">사례 22: 모든 변경 사항 취소하기 (Tracked + Untracked)</a></li></ul></li></ul></ul></li></ul></div></details></div><div class=post-content><p>Git은 강력하지만, 복잡한 상황에서는 개발자를 당황하게 만드는 경우가 많습니다. &ldquo;앗, 방금 뭘 한 거지?&rdquo; 싶은 순간은 누구에게나 찾아옵니다. 이 글에서는 <code>checkout</code>, <code>stash</code>, <code>branch</code> 등 핵심 명령어를 중심으로, 실제 현업에서 자주 겪는 20가지 트러블 슈팅 사례와 해결 방안을 구체적으로 정리했습니다.</p><hr><h2 id=part-1-checkout-관련-문제---코드가-뒤섞였어요>Part 1: <code>checkout</code> 관련 문제 - &ldquo;코드가 뒤섞였어요!&rdquo;<a hidden class=anchor aria-hidden=true href=#part-1-checkout-관련-문제---코드가-뒤섞였어요>#</a></h2><p><code>checkout</code>은 브랜치를 바꾸거나 특정 버전으로 돌아갈 때 사용하지만, 이 과정에서 많은 실수가 발생합니다.</p><h4 id=사례-1-다른-브랜치로-이동하려는데-작업하던-내용이-있어서-막힐-때>사례 1: 다른 브랜치로 이동하려는데, 작업하던 내용이 있어서 막힐 때<a hidden class=anchor aria-hidden=true href=#사례-1-다른-브랜치로-이동하려는데-작업하던-내용이-있어서-막힐-때>#</a></h4><ul><li><strong>문제 상황:</strong> <code>feature/new-login</code> 브랜치에서 작업하던 중, 급하게 <code>hotfix/bug-report</code> 브랜치로 이동해야 합니다. <code>git checkout hotfix/bug-report</code>를 입력하니 &ldquo;error: Your local changes to the following files would be overwritten by checkout&mldr;&rdquo; 메시지가 나옵니다.</li><li><strong>해결 방안:</strong> 아직 커밋하기 애매한 작업 내용을 임시 저장 공간(<code>stash</code>)에 저장합니다.<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 현재 작업 내용을 스택에 임시 저장</span>
</span></span><span style=display:flex><span>git stash
</span></span><span style=display:flex><span>&gt; <span style=color:#e6db74>`</span>git stash<span style=color:#e6db74>`</span>: 현재 작업 디렉터리의 변경된 파일<span style=color:#f92672>(</span>Tracked files<span style=color:#f92672>)</span>을 임시로 스택에 저장합니다. <span style=color:#e6db74>`</span>push<span style=color:#e6db74>`</span>, <span style=color:#e6db74>`</span>pop<span style=color:#e6db74>`</span>, <span style=color:#e6db74>`</span>apply<span style=color:#e6db74>`</span>, <span style=color:#e6db74>`</span>list<span style=color:#e6db74>`</span> 등의 하위 명령어를 통해 관리할 수 있습니다.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 원하는 브랜치로 이동하여 작업 수행</span>
</span></span><span style=display:flex><span>git checkout hotfix/bug-report
</span></span><span style=display:flex><span><span style=color:#75715e># ... 핫픽스 작업 ...</span>
</span></span><span style=display:flex><span>git commit -m <span style=color:#e6db74>&#34;Fix: Critical bug&#34;</span>
</span></span><span style=display:flex><span>git push origin hotfix/bug-report
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 원래 브랜치로 복귀</span>
</span></span><span style=display:flex><span>git checkout feature/new-login
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 임시 저장했던 작업 내용 다시 적용</span>
</span></span><span style=display:flex><span>git stash pop
</span></span></code></pre></div></li></ul><h4 id=사례-2-실수로-파일을-삭제했는데-커밋은-아직-안-했을-때-rm-atxt>사례 2: 실수로 파일을 삭제했는데, 커밋은 아직 안 했을 때 (<code>rm a.txt</code>)<a hidden class=anchor aria-hidden=true href=#사례-2-실수로-파일을-삭제했는데-커밋은-아직-안-했을-때-rm-atxt>#</a></h4><ul><li><p><strong>문제 상황:</strong> <code>git rm</code>이 아닌 <code>rm</code> 명령어로 파일을 삭제했습니다. <code>git status</code>에 &ldquo;deleted: a.txt"로 표시됩니다.</p></li><li><p><strong>해결 방안:</strong> <code>checkout</code>을 사용해 현재 브랜치(HEAD)의 마지막 커밋 상태에서 해당 파일을 복원합니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># a.txt 파일을 마지막 커밋 상태로 복원</span>
</span></span><span style=display:flex><span>git checkout HEAD -- a.txt
</span></span></code></pre></div><blockquote><p><code>git checkout &lt;commit> -- &lt;file></code>: 특정 커밋 상태의 특정 파일을 현재 작업 디렉터리로 복원합니다. <code>--</code>는 브랜치/커밋과 파일 경로를 명확하게 구분하는 역할을 합니다.</p></blockquote><h1 id=-를-사용하면-브랜치-이름과-파일-이름을-명확히-구분할-수-있어-안전합니다>&ndash; 를 사용하면 브랜치 이름과 파일 이름을 명확히 구분할 수 있어 안전합니다.<a hidden class=anchor aria-hidden=true href=#-를-사용하면-브랜치-이름과-파일-이름을-명확히-구분할-수-있어-안전합니다>#</a></h1></li></ul><h4 id=사례-3-브랜치를-옮기지-않고-다른-브랜치의-파일-내용만-보고-싶을-때>사례 3: 브랜치를 옮기지 않고 다른 브랜치의 파일 내용만 보고 싶을 때<a hidden class=anchor aria-hidden=true href=#사례-3-브랜치를-옮기지-않고-다른-브랜치의-파일-내용만-보고-싶을-때>#</a></h4><ul><li><strong>문제 상황:</strong> 현재 브랜치는 <code>feature</code>인데, <code>main</code> 브랜치의 <code>config.yml</code> 파일 내용과 비교하고 싶습니다. 브랜치를 통째로 옮기기엔 부담스럽습니다.</li><li><strong>해결 방안:</strong> <code>git show</code> 또는 <code>git checkout</code>을 특정 파일에 대해서만 실행합니다.<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 1. git show 사용 (단순 조회)</span>
</span></span><span style=display:flex><span>git show main:path/to/config.yml
</span></span><span style=display:flex><span>&gt; <span style=color:#e6db74>`</span>git show &lt;branch&gt;:&lt;path/to/file&gt;<span style=color:#e6db74>`</span>: 브랜치를 변경하지 않고, 다른 브랜치에 있는 파일의 내용을 터미널에 출력합니다.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 2. git checkout 사용 (현재 작업 디렉터리로 가져오기)</span>
</span></span><span style=display:flex><span>git checkout main -- path/to/config.yml
</span></span><span style=display:flex><span><span style=color:#75715e># 위 명령은 `main` 브랜치의 `config.yml`을 현재 디렉터리로 가져와 덮어씁니다.</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 주의: 현재 작업 디렉터리의 내용이 변경됩니다.</span>
</span></span></code></pre></div></li></ul><h4 id=사례-4-detached-head-상태가-되었을-때>사례 4: &ldquo;Detached HEAD&rdquo; 상태가 되었을 때<a hidden class=anchor aria-hidden=true href=#사례-4-detached-head-상태가-되었을-때>#</a></h4><ul><li><p><strong>문제 상황:</strong> <code>git checkout &lt;commit-hash></code> 나 <code>git checkout origin/main</code> 처럼 브랜치가 아닌 포인터를 직접 체크아웃하면 &ldquo;You are in &lsquo;detached HEAD&rsquo; state.&rdquo; 라는 메시지가 나옵니다. 이 상태에서 작업하고 커밋하면 해당 커밋은 어떤 브랜치에도 속하지 않게 되어 나중에 잃어버릴 수 있습니다.</p></li><li><p><strong>해결 방안:</strong> 현재 &ldquo;Detached HEAD&rdquo; 상태에서 새로운 브랜치를 만들어 작업을 이어갑니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 현재 위치에서 &#39;temp-work&#39; 라는 새 브랜치를 생성</span>
</span></span><span style=display:flex><span>git checkout -b temp-work
</span></span></code></pre></div><blockquote><p><code>git checkout -b &lt;new-branch></code>: 현재 위치(커밋)에서 새로운 브랜치를 생성하고, 즉시 해당 브랜치로 전환합니다.</p></blockquote><h1 id=이제-temp-work-브랜치에서-안전하게-커밋을-이어갈-수-있습니다>이제 &rsquo;temp-work&rsquo; 브랜치에서 안전하게 커밋을 이어갈 수 있습니다.<a hidden class=anchor aria-hidden=true href=#이제-temp-work-브랜치에서-안전하게-커밋을-이어갈-수-있습니다>#</a></h1><p>git add .
git commit -m &ldquo;Add new feature from detached state&rdquo;</p><pre tabindex=0><code></code></pre></li></ul><h4 id=사례-5-과거의-특정-파일-버전-하나만-현재-브랜치로-가져오고-싶을-때>사례 5: 과거의 특정 파일 버전 하나만 현재 브랜치로 가져오고 싶을 때<a hidden class=anchor aria-hidden=true href=#사례-5-과거의-특정-파일-버전-하나만-현재-브랜치로-가져오고-싶을-때>#</a></h4><ul><li><strong>문제 상황:</strong> <code>config.js</code> 파일의 과거 버전이 필요합니다. 3개의 커밋 전(<code>HEAD~3</code>) 버전의 <code>config.js</code>만 현재 작업 내용에 덮어쓰고 싶습니다.</li><li><strong>해결 방안:</strong> <code>git checkout</code>에 커밋 해시와 파일 경로를 지정합니다.<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 3개 커밋 전 버전의 &#39;config.js&#39;를 현재 디렉터리로 가져옴</span>
</span></span><span style=display:flex><span>git checkout HEAD~3 -- src/config.js
</span></span></code></pre></div><blockquote><p><code>git checkout &lt;commit> -- &lt;file></code>: 특정 커밋에 해당하는 파일의 버전으로 현재 작업 디렉터리의 파일을 덮어씁니다.</p></blockquote></li></ul><hr><h2 id=part-2-stash-관련-문제---작업-내용이-사라졌어요>Part 2: <code>stash</code> 관련 문제 - &ldquo;작업 내용이 사라졌어요!&rdquo;<a hidden class=anchor aria-hidden=true href=#part-2-stash-관련-문제---작업-내용이-사라졌어요>#</a></h2><p><code>stash</code>는 매우 유용한 임시 저장 기능이지만, 여러 개가 쌓이면 혼란스러워집니다.</p><h4 id=사례-6-stash-이름-없이-저장해서-뭐가-뭔지-모를-때>사례 6: Stash 이름 없이 저장해서 뭐가 뭔지 모를 때<a hidden class=anchor aria-hidden=true href=#사례-6-stash-이름-없이-저장해서-뭐가-뭔지-모를-때>#</a></h4><ul><li><p><strong>문제 상황:</strong> 여러 번 <code>git stash</code>를 실행했더니 <code>stash@{0}</code>, <code>stash@{1}</code> &mldr; 목록만 있고, 어떤 내용이 저장되었는지 기억나지 않습니다.</p></li><li><p><strong>해결 방안 1:</strong> <code>git stash list</code>로 목록을 보고, <code>git stash show</code>로 각 내용을 확인합니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git stash list
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># stash@{0}: WIP on feature/login: ...</span>
</span></span><span style=display:flex><span><span style=color:#75715e># stash@{1}: WIP on feature/login: ...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># stash@{1}의 변경 내용 요약 보기</span>
</span></span><span style=display:flex><span>git stash show stash@<span style=color:#f92672>{</span>1<span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># stash@{1}의 변경 내용 상세 보기 (diff)</span>
</span></span><span style=display:flex><span>git stash show -p stash@<span style=color:#f92672>{</span>1<span style=color:#f92672>}</span>
</span></span></code></pre></div><blockquote><p><code>git stash list</code>: 현재 저장된 모든 stash 목록을 최신 순으로 보여줍니다.</p></blockquote></li><li><p><strong>해결 방안 2:</strong> 처음부터 <code>git stash push -m "메시지"</code> 로 저장합니다. (<code>git stash save</code>는 더 이상 권장되지 않습니다.)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git stash push -m <span style=color:#e6db74>&#34;Finish login UI, before API integration&#34;</span>
</span></span></code></pre></div></li></ul><h4 id=사례-7-untracked-파일새로-만든-파일은-stash에-포함되지-않았을-때>사례 7: Untracked 파일(새로 만든 파일)은 <code>stash</code>에 포함되지 않았을 때<a hidden class=anchor aria-hidden=true href=#사례-7-untracked-파일새로-만든-파일은-stash에-포함되지-않았을-때>#</a></h4><ul><li><strong>문제 상황:</strong> 새로 만든 파일(<code>new-component.js</code>)과 기존 파일 수정을 함께 <code>git stash</code>했는데, 브랜치를 옮겼다 돌아와 <code>stash pop</code>하니 새로 만든 파일이 사라졌습니다.</li><li><strong>해결 방안:</strong> <code>stash</code> 시 <code>-u</code> 또는 <code>--include-untracked</code> 옵션을 사용합니다.<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># Untracked 파일까지 포함하여 stash</span>
</span></span><span style=display:flex><span>git stash -u
</span></span></code></pre></div></li></ul><h4 id=사례-8-다른-브랜치에서-작업한-내용을-현재-브랜치에-적용하고-싶을-때>사례 8: 다른 브랜치에서 작업한 내용을 현재 브랜치에 적용하고 싶을 때<a hidden class=anchor aria-hidden=true href=#사례-8-다른-브랜치에서-작업한-내용을-현재-브랜치에-적용하고-싶을-때>#</a></h4><ul><li><strong>문제 상황:</strong> <code>feature/A</code>에서 작업하던 내용을 커밋 없이 <code>stash</code>하고, <code>feature/B</code>로 넘어왔습니다. <code>feature/A</code>의 작업 내용 일부가 <code>feature/B</code>에서도 필요합니다.</li><li><strong>해결 방안:</strong> <code>git stash branch</code>를 사용해 stash로부터 새로운 브랜치를 생성합니다.<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 현재 `feature/B` 브랜치에서...</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 가장 최근의 stash (stash@{0}) 내용으로 &#39;temp-branch&#39; 생성</span>
</span></span><span style=display:flex><span>git stash branch temp-branch stash@<span style=color:#f92672>{</span>0<span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 이제 &#39;temp-branch&#39;는 &#39;feature/A&#39;에서 작업하던 내용을 커밋할 수 있는 상태가 됩니다.</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 여기서 필요한 내용을 커밋한 뒤, &#39;feature/B&#39;에서 `cherry-pick` 등으로 가져올 수 있습니다.</span>
</span></span></code></pre></div></li></ul><h4 id=사례-9-stash-pop-실행-시-충돌conflict이-발생했을-때>사례 9: <code>stash pop</code> 실행 시 충돌(Conflict)이 발생했을 때<a hidden class=anchor aria-hidden=true href=#사례-9-stash-pop-실행-시-충돌conflict이-발생했을-때>#</a></h4><ul><li><p><strong>문제 상황:</strong> <code>stash</code>를 한 이후, 현재 브랜치에서 <code>stash</code>에 저장된 내용과 동일한 라인을 수정했습니다. <code>git stash pop</code>을 하니 충돌이 발생합니다.</p></li><li><p><strong>해결 방안:</strong> 일반적인 <code>merge</code> 충돌과 동일하게 해결합니다.</p><ol><li>충돌이 발생한 파일을 열어 <code>&lt;&lt;&lt;&lt;&lt;</code>, <code>=====</code>, <code>>>>>></code> 마커를 확인하고 코드를 올바르게 수정합니다.</li><li>수정한 파일을 <code>git add</code> 합니다.</li><li><code>git stash drop</code>을 실행하여 적용된 stash를 스택에서 제거합니다. (<code>pop</code>은 충돌 시 자동으로 drop되지 않습니다.)</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 1. 코드 수정 후</span>
</span></span><span style=display:flex><span>git add .
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 2. 변경 사항 커밋 (필요 시)</span>
</span></span><span style=display:flex><span>git commit -m <span style=color:#e6db74>&#34;Resolve stash conflict&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 3. 적용된 stash 제거</span>
</span></span><span style=display:flex><span>git stash drop
</span></span></code></pre></div></li></ul><h4 id=사례-10-실수로-stash-clear를-실행하여-모든-stash가-사라졌을-때>사례 10: 실수로 <code>stash clear</code>를 실행하여 모든 stash가 사라졌을 때<a hidden class=anchor aria-hidden=true href=#사례-10-실수로-stash-clear를-실행하여-모든-stash가-사라졌을-때>#</a></h4><ul><li><strong>문제 상황:</strong> 중요한 내용이 <code>stash</code>에 있었는데, <code>git stash clear</code>로 모두 삭제해버렸습니다.</li><li><strong>해결 방안:</strong> Git이 아직 가비지 컬렉션(GC)을 실행하지 않았다면, <code>fsck</code>로 복구할 수 있습니다.<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># Git 데이터베이스에서 유효성을 검사하며 &#34;dangling&#34; 객체를 찾음</span>
</span></span><span style=display:flex><span>git fsck --no-reflogs
</span></span><span style=display:flex><span><span style=color:#75715e># ... 수많은 해시값 출력 ...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 위에서 찾은 &#34;dangling commit&#34; 해시들을 하나씩 확인하여 stash 내용을 찾음</span>
</span></span><span style=display:flex><span>git show &lt;dangling-commit-hash&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 원하는 stash를 찾았다면, 해당 커밋에서 브랜치를 만들어 복구</span>
</span></span><span style=display:flex><span>git branch recovered-stash &lt;dangling-commit-hash&gt;
</span></span></code></pre></div>이 방법은 복잡하고 항상 성공하는 것은 아니므로, 중요한 작업은 <code>stash</code>보다는 커밋으로 남기는 습관이 좋습니다.</li></ul><hr><h2 id=part-3-branch-및-병합-관련-문제---브랜치가-꼬였어요>Part 3: <code>branch</code> 및 병합 관련 문제 - &ldquo;브랜치가 꼬였어요!&rdquo;<a hidden class=anchor aria-hidden=true href=#part-3-branch-및-병합-관련-문제---브랜치가-꼬였어요>#</a></h2><p>브랜치 전략은 협업의 핵심이며, 가장 많은 문제가 발생하는 곳이기도 합니다.</p><h4 id=사례-11-main-브랜치에-직접-커밋해버렸을-때>사례 11: <code>main</code> 브랜치에 직접 커밋해버렸을 때<a hidden class=anchor aria-hidden=true href=#사례-11-main-브랜치에-직접-커밋해버렸을-때>#</a></h4><ul><li><strong>문제 상황:</strong> <code>feature</code> 브랜치에서 작업해야 할 내용을 실수로 <code>main</code> 브랜치에 커밋했습니다. 아직 <code>push</code>는 하지 않았습니다.</li><li><strong>해결 방안:</strong> <code>main</code> 브랜치를 이전 커밋으로 되돌리고, 새 브랜치를 만들어 해당 커밋을 가져옵니다.<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 1. 현재 `main` 브랜치에서...</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 올바른 `feature` 브랜치를 생성</span>
</span></span><span style=display:flex><span>git branch feature/my-work
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 2. `main` 브랜치를 이전 상태로 되돌림 (실수로 한 커밋 제거)</span>
</span></span><span style=display:flex><span><span style=color:#75715e># origin/main, 즉 원격 저장소의 상태로 강제 리셋</span>
</span></span><span style=display:flex><span>git reset --hard origin/main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 3. 이제 새 브랜치로 이동하여 작업을 이어감</span>
</span></span><span style=display:flex><span>git checkout feature/my-work
</span></span></code></pre></div></li></ul><h4 id=사례-12-실수로-push까지-해버린-커밋을-되돌리고-싶을-때>사례 12: 실수로 <code>push</code>까지 해버린 커밋을 되돌리고 싶을 때<a hidden class=anchor aria-hidden=true href=#사례-12-실수로-push까지-해버린-커밋을-되돌리고-싶을-때>#</a></h4><ul><li><strong>문제 상황:</strong> <code>main</code>에 잘못 커밋하고 <code>push</code>까지 해버렸습니다. 다른 팀원들이 <code>pull</code> 받기 전에 빨리 조치해야 합니다.</li><li><strong>해결 방안:</strong> <code>revert</code>를 사용하여 &ldquo;잘못된 커밋을 되돌리는 새로운 커밋"을 만듭니다.<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># `main` 브랜치에서...</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 되돌리고 싶은 마지막 커밋을 타겟으로 `revert` 실행</span>
</span></span><span style=display:flex><span>git revert HEAD
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># revert 커밋 메시지 저장 후, 변경 사항을 push</span>
</span></span><span style=display:flex><span>git push origin main
</span></span></code></pre></div><code>reset --hard</code> 후 <code>push -f</code>를 하는 것은 팀원들의 히스토리를 엉망으로 만들 수 있으므로, 공유된 브랜치에서는 절대적으로 피해야 합니다. <code>revert</code>가 안전한 대안입니다.</li></ul><h4 id=사례-13-브랜치-이름을-변경하고-싶을-때-로컬--원격>사례 13: 브랜치 이름을 변경하고 싶을 때 (로컬 & 원격)<a hidden class=anchor aria-hidden=true href=#사례-13-브랜치-이름을-변경하고-싶을-때-로컬--원격>#</a></h4><ul><li><strong>문제 상황:</strong> 브랜치 이름에 오타가 있거나, 컨벤션을 따르지 않아 변경하고 싶습니다. (예: <code>feture/login</code> -> <code>feature/login</code>)</li><li><strong>해결 방안:</strong><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 1. 현재 브랜치 이름 변경</span>
</span></span><span style=display:flex><span>git branch -m feature/login
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 2. 원격의 옛날 브랜치 삭제</span>
</span></span><span style=display:flex><span>git push origin --delete feture/login
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 3. 새로 바꾼 이름의 브랜치를 원격에 push</span>
</span></span><span style=display:flex><span>git push origin -u feature/login
</span></span></code></pre></div></li></ul><h4 id=사례-14-다른-브랜치의-특정-커밋-하나만-현재-브랜치로-가져오고-싶을-때>사례 14: 다른 브랜치의 특정 커밋 하나만 현재 브랜치로 가져오고 싶을 때<a hidden class=anchor aria-hidden=true href=#사례-14-다른-브랜치의-특정-커밋-하나만-현재-브랜치로-가져오고-싶을-때>#</a></h4><ul><li><strong>문제 상황:</strong> <code>hotfix</code> 브랜치에서 수정한 버그 픽스 커밋(<code>a1b2c3d</code>)이 현재 개발 중인 <code>feature</code> 브랜치에도 즉시 필요합니다.</li><li><strong>해결 방안:</strong> <code>cherry-pick</code>을 사용합니다.<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># `feature` 브랜치에서...</span>
</span></span><span style=display:flex><span>git cherry-pick a1b2c3d
</span></span></code></pre></div></li></ul><h4 id=사례-15-너무-자잘하게-나눠진-커밋들을-하나로-합치고-싶을-때-push-전>사례 15: 너무 자잘하게 나눠진 커밋들을 하나로 합치고 싶을 때 (Push 전)<a hidden class=anchor aria-hidden=true href=#사례-15-너무-자잘하게-나눠진-커밋들을-하나로-합치고-싶을-때-push-전>#</a></h4><ul><li><strong>문제 상황:</strong> &ldquo;Fix typo&rdquo;, &ldquo;Add comment&rdquo;, &ldquo;Refactor&rdquo; 등 의미 없는 커밋이 너무 많아 PR 올리기 전에 정리하고 싶습니다.</li><li><strong>해결 방안:</strong> <code>rebase -i</code> (interactive rebase)를 사용합니다.<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 합치고 싶은 커밋의 *이전* 커밋 해시를 지정 (예: 최근 3개)</span>
</span></span><span style=display:flex><span>git rebase -i HEAD~3
</span></span></code></pre></div><ul><li>위 명령을 실행하면 편집기가 열리고, 커밋 목록이 나옵니다.</li><li>맨 위 커밋은 <code>pick</code>으로 두고, 나머지 커밋 앞의 <code>pick</code>을 <code>s</code> 또는 <code>squash</code>로 변경합니다.</li><li>저장하고 닫으면, 커밋 메시지를 새로 작성하는 창이 열립니다. 하나의 깔끔한 메시지로 정리합니다.</li></ul></li></ul><hr><h2 id=part-4-기타-고급-트러블-슈팅>Part 4: 기타 고급 트러블 슈팅<a hidden class=anchor aria-hidden=true href=#part-4-기타-고급-트러블-슈팅>#</a></h2><h4 id=사례-16-실수로-git-add-한-파일을-다시-내리고-싶을-때>사례 16: 실수로 <code>git add</code> 한 파일을 다시 내리고 싶을 때<a hidden class=anchor aria-hidden=true href=#사례-16-실수로-git-add-한-파일을-다시-내리고-싶을-때>#</a></h4><ul><li><strong>문제 상황:</strong> 커밋하고 싶지 않은 파일(<code>secret.key</code>)을 실수로 Staging Area에 추가(<code>add</code>)했습니다.</li><li><strong>해결 방안:</strong> <code>git reset</code>을 사용합니다.<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 특정 파일만 Staging Area에서 내림</span>
</span></span><span style=display:flex><span>git reset HEAD secret.key
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 모든 파일을 Staging Area에서 내림</span>
</span></span><span style=display:flex><span>git reset
</span></span></code></pre></div></li></ul><h4 id=사례-17-마지막-커밋-메시지에-오타가-있을-때>사례 17: 마지막 커밋 메시지에 오타가 있을 때<a hidden class=anchor aria-hidden=true href=#사례-17-마지막-커밋-메시지에-오타가-있을-때>#</a></h4><ul><li><strong>문제 상황:</strong> 방금 커밋했는데, 메시지에 오타가 있습니다. 아직 <code>push</code>는 안했습니다.</li><li><strong>해결 방안:</strong> <code>commit --amend</code>를 사용합니다.<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git commit --amend
</span></span><span style=display:flex><span><span style=color:#75715e># 편집기가 열리면 메시지를 수정하고 저장</span>
</span></span></code></pre></div><strong>주의:</strong> <code>push</code> 한 커밋에는 절대 사용하면 안 됩니다.</li></ul><h4 id=사례-18-브랜치를-삭제했는데-다시-복구해야-할-때>사례 18: 브랜치를 삭제했는데, 다시 복구해야 할 때<a hidden class=anchor aria-hidden=true href=#사례-18-브랜치를-삭제했는데-다시-복구해야-할-때>#</a></h4><ul><li><strong>문제 상황:</strong> <code>git branch -D my-feature</code>로 브랜치를 강제 삭제했는데, 아직 <code>main</code>에 병합되지 않은 중요한 커밋이 있었습니다.</li><li><strong>해결 방안:</strong> <code>reflog</code>를 사용하여 Git의 모든 참조 변경 기록을 확인합니다.<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git reflog
</span></span><span style=display:flex><span><span style=color:#75715e># ...</span>
</span></span><span style=display:flex><span><span style=color:#75715e># a1b2c3d HEAD@{5}: checkout: moving from my-feature to main</span>
</span></span><span style=display:flex><span><span style=color:#75715e># ...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 삭제된 브랜치의 마지막 커밋 해시(a1b2c3d)를 찾았다면,</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 해당 커밋에서 브랜치를 다시 생성</span>
</span></span><span style=display:flex><span>git checkout -b recovered-feature a1b2c3d
</span></span></code></pre></div></li></ul><h4 id=사례-19-현재-작업-내용-전체를-특정-과거-커밋-시점으로-되돌리고-싶을-때>사례 19: 현재 작업 내용 전체를 특정 과거 커밋 시점으로 되돌리고 싶을 때<a hidden class=anchor aria-hidden=true href=#사례-19-현재-작업-내용-전체를-특정-과거-커밋-시점으로-되돌리고-싶을-때>#</a></h4><ul><li><strong>문제 상황:</strong> 최근 몇 개의 커밋이 완전히 잘못된 방향으로 진행되어, <code>a1b2c3d</code> 커밋 시점으로 모든 것을 되돌리고 싶습니다. 로컬에서의 변경 사항이므로 히스토리가 깨져도 상관없습니다.</li><li><strong>해결 방안:</strong> <code>reset --hard</code>를 사용합니다. <strong>(경고: 복구 불가능한 데이터 손실을 유발할 수 있습니다!)</strong><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 모든 변경사항, 커밋을 버리고 &#39;a1b2c3d&#39; 상태로 돌아감</span>
</span></span><span style=display:flex><span>git reset --hard a1b2c3d
</span></span></code></pre></div></li></ul><h4 id=사례-20-pull을-받았더니-관련-없는-커밋-히스토리가-잔뜩-병합될-때>사례 20: <code>pull</code>을 받았더니 관련 없는 커밋 히스토리가 잔뜩 병합될 때<a hidden class=anchor aria-hidden=true href=#사례-20-pull을-받았더니-관련-없는-커밋-히스토리가-잔뜩-병합될-때>#</a></h4><ul><li><strong>문제 상황:</strong> <code>main</code> 브랜치에서 <code>feature</code> 브랜치를 따서 작업 후, <code>feature</code> 브랜치에서 <code>git pull origin main</code>을 실행했습니다. 의도와 달리 수많은 <code>main</code>의 커밋들이 <code>Merge branch 'main' into feature</code> 라는 메시지와 함께 들어왔습니다.</li><li><strong>해결 방안:</strong> <code>pull</code> 시 <code>rebase</code> 옵션을 사용하거나, <code>git config</code>로 기본값으로 설정합니다. <code>Rebase</code>는 <code>main</code>의 변경사항을 내 브랜치의 &ldquo;베이스"로 다시 설정하여, 내 커밋들을 그 위에 차곡차곡 쌓아줍니다. 히스토리가 훨씬 깔끔해집니다.<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 1. 일회성으로 rebase pull 실행</span>
</span></span><span style=display:flex><span>git pull origin main --rebase
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 2. 향후 모든 pull을 rebase로 실행하도록 설정</span>
</span></span><span style=display:flex><span>git config --global pull.rebase true
</span></span></code></pre></div></li></ul><h4 id=사례-21-특정-커밋을-찾기-위해-로그를-효율적으로-검색하고-싶을-때>사례 21: 특정 커밋을 찾기 위해 로그를 효율적으로 검색하고 싶을 때<a hidden class=anchor aria-hidden=true href=#사례-21-특정-커밋을-찾기-위해-로그를-효율적으로-검색하고-싶을-때>#</a></h4><ul><li><p><strong>문제 상황:</strong> 프로젝트 히스토리가 길어져서 특정 기능이 언제 추가되었는지, 특정 파일이 언제 마지막으로 수정되었는지 찾기 어렵습니다.</p></li><li><p><strong>해결 방안:</strong> <code>git log</code>의 다양한 옵션을 활용하여 히스토리를 필터링합니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 한 줄로 로그를 깔끔하게 보기</span>
</span></span><span style=display:flex><span>git log --oneline --graph
</span></span></code></pre></div><blockquote><p><code>git log --oneline</code>: 각 커밋을 한 줄로 요약하여 보여줍니다. <code>--graph</code> 옵션을 함께 사용하면 브랜치의 분기 및 병합 히스토리를 시각적으로 파악하기 좋습니다.</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 특정 파일의 변경 이력만 보기</span>
</span></span><span style=display:flex><span>git log -p -- src/components/Button.js
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 특정 기간 동안의 커밋만 보기</span>
</span></span><span style=display:flex><span>git log --since<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;2 weeks ago&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 특정 작성자의 커밋만 보기</span>
</span></span><span style=display:flex><span>git log --author<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;cdecl&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 커밋 메시지에서 특정 키워드로 검색하기</span>
</span></span><span style=display:flex><span>git log --grep<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;keyword&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 코드 변경 내용(diff)에서 특정 문자열이 추가/삭제된 커밋 검색</span>
</span></span><span style=display:flex><span>git log -S<span style=color:#e6db74>&#34;UserService&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 코드 변경 내용(diff)에서 정규식으로 특정 패턴을 검색</span>
</span></span><span style=display:flex><span>git log -G<span style=color:#e6db74>&#34;Login(Service|Manager)&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 두 커밋 사이의 모든 커밋 보기</span>
</span></span><span style=display:flex><span>git log a1b2c3d..f4e5d6c
</span></span></code></pre></div><blockquote><p><code>git log --grep</code>은 커밋 메시지를 검색하지만, <code>git log -S</code>는 실제 코드 변경 내용(diff)에서 특정 문자열의 증감(추가/삭제)이 발생한 커밋을 찾아줍니다. <code>git log -G</code>는 <code>-S</code>와 유사하게 코드 변경 내용에서 정규표현식으로 특정 패턴을 검색할 때 사용합니다. 이 옵션들과 함께 <code>-p</code>를 사용하면 해당 커밋의 전체 diff를 함께 볼 수 있어 변경 내용을 상세히 파악하는 데 매우 유용합니다.</p></blockquote></li></ul><h4 id=사례-22-모든-변경-사항-취소하기-tracked--untracked>사례 22: 모든 변경 사항 취소하기 (Tracked + Untracked)<a hidden class=anchor aria-hidden=true href=#사례-22-모든-변경-사항-취소하기-tracked--untracked>#</a></h4><ul><li><p><strong>문제 상황:</strong> 작업하던 모든 변경 사항을 취소하고 현재 HEAD 상태로 깨끗하게 되돌리고 싶습니다. 이미 수정한 파일(tracked)과 새로 만든 파일(untracked)을 모두 삭제하고 싶습니다.</p></li><li><p><strong>해결 방안:</strong> 다음 명령들을 조합하여 사용합니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 1. Tracked 파일 모두 복원 (Working Directory + Staging Area 초기화)</span>
</span></span><span style=display:flex><span>git reset --hard HEAD
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 2. Untracked 파일 모두 삭제</span>
</span></span><span style=display:flex><span>git clean -fd
</span></span></code></pre></div><blockquote><p><code>git reset --hard HEAD</code>: Working Directory와 Staging Area를 마지막 커밋 상태로 되돌립니다. tracked 파일의 모든 변경 사항을 취소합니다. untracked 파일은 삭제하지 않습니다.</p><p><code>git clean -fd</code>: 추적하지 않는 파일(<code>-f</code>)과 디렉터리(<code>-d</code>)를 모두 삭제합니다. <strong>주의: 영구적으로 삭제되므로 복구할 수 없습니다!</strong></p></blockquote><p><strong>VSCode &ldquo;Discard All Changes"와의 차이:</strong>
VSCode의 &ldquo;Discard All Changes&rdquo; 버튼은 <code>git restore</code>와 <code>git clean -fd</code>를 사용합니다. 이 방식은 <code>git reset --hard</code>와 달리 Staging Area의 파일을 처리하지 않습니다. 따라서 명령줄에서 직접 모든 변경 사항을 취소할 때는 <code>git reset --hard HEAD && git clean -fd</code>를 사용하는 것이 더 확실합니다.</p><p><strong>참고:</strong> 특정 파일만 취소하려면:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 특정 파일만 취소 (untracked 파일에 대해서는 동작하지 않음)</span>
</span></span><span style=display:flex><span>git restore &lt;file&gt;
</span></span><span style=display:flex><span><span style=color:#75715e># 또는</span>
</span></span><span style=display:flex><span>git checkout HEAD -- &lt;file&gt;
</span></span></code></pre></div><p><strong>팁:</strong> 삭제하기 전에 변경 사항을 저장하고 싶다면:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># untracked 파일까지 포함하여 저장</span>
</span></span><span style=display:flex><span>git stash push -u
</span></span><span style=display:flex><span><span style=color:#75715e># 나중에 복원</span>
</span></span><span style=display:flex><span>git stash pop
</span></span></code></pre></div></li></ul><hr><p>Git 트러블 슈팅의 핵심은 &ldquo;무엇을 하려 했는가"와 &ldquo;실제로 무슨 일이 일어났는가"의 차이를 이해하는 것입니다. 이 글에서 소개된 사례들을 통해, 예상치 못한 상황에 더 자신감 있게 대처할 수 있기를 바랍니다.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://cdecl.github.io/tags/git/>Git</a></li><li><a href=https://cdecl.github.io/tags/troubleshooting/>Troubleshooting</a></li><li><a href=https://cdecl.github.io/tags/checkout/>Checkout</a></li><li><a href=https://cdecl.github.io/tags/stash/>Stash</a></li><li><a href=https://cdecl.github.io/tags/branch/>Branch</a></li><li><a href=https://cdecl.github.io/tags/reset/>Reset</a></li><li><a href=https://cdecl.github.io/tags/revert/>Revert</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://cdecl.github.io/>cdeclog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>