<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Python asyncio | cdeclog</title><meta name=keywords content="python,asyncio,async,await,coroutine"><meta name=description content="asyncio는 async/await 구문을 사용하여 동시성 코드를 작성하는 라이브러리입니다. 특히 I/O 작업이 많은 애플리케이션에서 높은 성능을 발휘합니다.
asyncio : asynchronous io 처리

https://docs.python.org/ko/3/library/asyncio.html{:target=&#34;_blank&#34;}
Threading 동시성 제어는 GIL (Global interpreter lock) 제약에 의해 느리고, 복잡도는 그대로 가지고 있음

GIL은 Python 인터프리터가 한 번에 하나의 스레드만 실행할 수 있도록 제한하는 메커니즘
멀티스레드를 사용해도 CPU 연산의 실제 병렬 처리가 어려움


IO 병목에 의한 동시성을 관리하기 위한 도구로서 Coroutine을 통한 관리

네트워크 요청, 파일 읽기/쓰기 등 I/O 작업에서 효율적
코루틴은 스레드보다 가벼워서 수천 개의 동시 작업도 효율적으로 처리 가능



일반적인 Coroutine 코드

Coroutine으로 실행 되기는 하나, 비동기로 실행 되지는 않음
async def로 정의된 함수는 코루틴 함수가 됨
await는 다른 코루틴의 실행이 완료될 때까지 대기
asyncio.sleep()은 I/O 작업을 시뮬레이션하는 용도로 자주 사용됨

import asyncio
from datetime import datetime

def time_log(step):
    print(datetime.now().strftime('%H:%M:%S'), step)
    
async def async_sleep():
    await asyncio.sleep(2)
    time_log('async_sleep')

async def async_execute():
    time_log('start')

    await async_sleep()
    await async_sleep()

    time_log('end')

def main():
    asyncio.run(async_execute())
    
if __name__ == '__main__':
    main()
[Running] set PYTHONIOENCODING=utf8 && python -u tempCodeRunnerFile.python
11:39:00 start
11:39:02 async_sleep
11:39:04 async_sleep
11:39:04 end
실행 결과를 보면 start -> 2초 대기 -> async_sleep -> 2초 대기 -> async_sleep -> end 순서로 순차 실행됨을 알 수 있습니다."><meta name=author content="Byung Kyu KIM"><link rel=canonical href=https://cdecl.github.io/dev/python-asyncio/><link crossorigin=anonymous href=/assets/css/stylesheet.94cdd6e6bf254a927ddb1a5b8ae2c24a30232449c016f55d87efd0d9bed87c55.css integrity="sha256-lM3W5r8lSpJ92xpbiuLCSjAjJEnAFvVdh+/Q2b7YfFU=" rel="preload stylesheet" as=style><link rel=icon href=https://cdecl.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://cdecl.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://cdecl.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://cdecl.github.io/apple-touch-icon.png><link rel=mask-icon href=https://cdecl.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://cdecl.github.io/dev/python-asyncio/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-VQQHHYPN7K"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VQQHHYPN7K")}</script><meta property="og:url" content="https://cdecl.github.io/dev/python-asyncio/"><meta property="og:site_name" content="cdeclog"><meta property="og:title" content="Python asyncio"><meta property="og:description" content="asyncio는 async/await 구문을 사용하여 동시성 코드를 작성하는 라이브러리입니다. 특히 I/O 작업이 많은 애플리케이션에서 높은 성능을 발휘합니다.
asyncio : asynchronous io 처리 https://docs.python.org/ko/3/library/asyncio.html{:target=&#34;_blank&#34;} Threading 동시성 제어는 GIL (Global interpreter lock) 제약에 의해 느리고, 복잡도는 그대로 가지고 있음 GIL은 Python 인터프리터가 한 번에 하나의 스레드만 실행할 수 있도록 제한하는 메커니즘 멀티스레드를 사용해도 CPU 연산의 실제 병렬 처리가 어려움 IO 병목에 의한 동시성을 관리하기 위한 도구로서 Coroutine을 통한 관리 네트워크 요청, 파일 읽기/쓰기 등 I/O 작업에서 효율적 코루틴은 스레드보다 가벼워서 수천 개의 동시 작업도 효율적으로 처리 가능 일반적인 Coroutine 코드 Coroutine으로 실행 되기는 하나, 비동기로 실행 되지는 않음 async def로 정의된 함수는 코루틴 함수가 됨 await는 다른 코루틴의 실행이 완료될 때까지 대기 asyncio.sleep()은 I/O 작업을 시뮬레이션하는 용도로 자주 사용됨 import asyncio from datetime import datetime def time_log(step): print(datetime.now().strftime('%H:%M:%S'), step) async def async_sleep(): await asyncio.sleep(2) time_log('async_sleep') async def async_execute(): time_log('start') await async_sleep() await async_sleep() time_log('end') def main(): asyncio.run(async_execute()) if __name__ == '__main__': main() [Running] set PYTHONIOENCODING=utf8 && python -u tempCodeRunnerFile.python 11:39:00 start 11:39:02 async_sleep 11:39:04 async_sleep 11:39:04 end 실행 결과를 보면 start -> 2초 대기 -> async_sleep -> 2초 대기 -> async_sleep -> end 순서로 순차 실행됨을 알 수 있습니다."><meta property="og:locale" content="ko-kr"><meta property="og:type" content="article"><meta property="article:section" content="dev"><meta property="article:published_time" content="2021-10-31T00:00:00+09:00"><meta property="article:modified_time" content="2021-10-31T00:00:00+09:00"><meta property="article:tag" content="Python"><meta property="article:tag" content="Asyncio"><meta property="article:tag" content="Async"><meta property="article:tag" content="Await"><meta property="article:tag" content="Coroutine"><meta name=twitter:card content="summary"><meta name=twitter:title content="Python asyncio"><meta name=twitter:description content="asyncio는 async/await 구문을 사용하여 동시성 코드를 작성하는 라이브러리입니다. 특히 I/O 작업이 많은 애플리케이션에서 높은 성능을 발휘합니다.
asyncio : asynchronous io 처리

https://docs.python.org/ko/3/library/asyncio.html{:target=&#34;_blank&#34;}
Threading 동시성 제어는 GIL (Global interpreter lock) 제약에 의해 느리고, 복잡도는 그대로 가지고 있음

GIL은 Python 인터프리터가 한 번에 하나의 스레드만 실행할 수 있도록 제한하는 메커니즘
멀티스레드를 사용해도 CPU 연산의 실제 병렬 처리가 어려움


IO 병목에 의한 동시성을 관리하기 위한 도구로서 Coroutine을 통한 관리

네트워크 요청, 파일 읽기/쓰기 등 I/O 작업에서 효율적
코루틴은 스레드보다 가벼워서 수천 개의 동시 작업도 효율적으로 처리 가능



일반적인 Coroutine 코드

Coroutine으로 실행 되기는 하나, 비동기로 실행 되지는 않음
async def로 정의된 함수는 코루틴 함수가 됨
await는 다른 코루틴의 실행이 완료될 때까지 대기
asyncio.sleep()은 I/O 작업을 시뮬레이션하는 용도로 자주 사용됨

import asyncio
from datetime import datetime

def time_log(step):
    print(datetime.now().strftime('%H:%M:%S'), step)
    
async def async_sleep():
    await asyncio.sleep(2)
    time_log('async_sleep')

async def async_execute():
    time_log('start')

    await async_sleep()
    await async_sleep()

    time_log('end')

def main():
    asyncio.run(async_execute())
    
if __name__ == '__main__':
    main()
[Running] set PYTHONIOENCODING=utf8 && python -u tempCodeRunnerFile.python
11:39:00 start
11:39:02 async_sleep
11:39:04 async_sleep
11:39:04 end
실행 결과를 보면 start -> 2초 대기 -> async_sleep -> 2초 대기 -> async_sleep -> end 순서로 순차 실행됨을 알 수 있습니다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Devs","item":"https://cdecl.github.io/dev/"},{"@type":"ListItem","position":2,"name":"Python asyncio","item":"https://cdecl.github.io/dev/python-asyncio/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Python asyncio","name":"Python asyncio","description":"asyncio는 async/await 구문을 사용하여 동시성 코드를 작성하는 라이브러리입니다. 특히 I/O 작업이 많은 애플리케이션에서 높은 성능을 발휘합니다.\nasyncio : asynchronous io 처리 https://docs.python.org/ko/3/library/asyncio.html{:target=\u0026quot;_blank\u0026quot;} Threading 동시성 제어는 GIL (Global interpreter lock) 제약에 의해 느리고, 복잡도는 그대로 가지고 있음 GIL은 Python 인터프리터가 한 번에 하나의 스레드만 실행할 수 있도록 제한하는 메커니즘 멀티스레드를 사용해도 CPU 연산의 실제 병렬 처리가 어려움 IO 병목에 의한 동시성을 관리하기 위한 도구로서 Coroutine을 통한 관리 네트워크 요청, 파일 읽기/쓰기 등 I/O 작업에서 효율적 코루틴은 스레드보다 가벼워서 수천 개의 동시 작업도 효율적으로 처리 가능 일반적인 Coroutine 코드 Coroutine으로 실행 되기는 하나, 비동기로 실행 되지는 않음 async def로 정의된 함수는 코루틴 함수가 됨 await는 다른 코루틴의 실행이 완료될 때까지 대기 asyncio.sleep()은 I/O 작업을 시뮬레이션하는 용도로 자주 사용됨 import asyncio from datetime import datetime def time_log(step): print(datetime.now().strftime(\u0026#39;%H:%M:%S\u0026#39;), step) async def async_sleep(): await asyncio.sleep(2) time_log(\u0026#39;async_sleep\u0026#39;) async def async_execute(): time_log(\u0026#39;start\u0026#39;) await async_sleep() await async_sleep() time_log(\u0026#39;end\u0026#39;) def main(): asyncio.run(async_execute()) if __name__ == \u0026#39;__main__\u0026#39;: main() [Running] set PYTHONIOENCODING=utf8 \u0026amp;\u0026amp; python -u tempCodeRunnerFile.python 11:39:00 start 11:39:02 async_sleep 11:39:04 async_sleep 11:39:04 end 실행 결과를 보면 start -\u0026gt; 2초 대기 -\u0026gt; async_sleep -\u0026gt; 2초 대기 -\u0026gt; async_sleep -\u0026gt; end 순서로 순차 실행됨을 알 수 있습니다.\n","keywords":["python","asyncio","async","await","coroutine"],"articleBody":"asyncio는 async/await 구문을 사용하여 동시성 코드를 작성하는 라이브러리입니다. 특히 I/O 작업이 많은 애플리케이션에서 높은 성능을 발휘합니다.\nasyncio : asynchronous io 처리 https://docs.python.org/ko/3/library/asyncio.html{:target=\"_blank\"} Threading 동시성 제어는 GIL (Global interpreter lock) 제약에 의해 느리고, 복잡도는 그대로 가지고 있음 GIL은 Python 인터프리터가 한 번에 하나의 스레드만 실행할 수 있도록 제한하는 메커니즘 멀티스레드를 사용해도 CPU 연산의 실제 병렬 처리가 어려움 IO 병목에 의한 동시성을 관리하기 위한 도구로서 Coroutine을 통한 관리 네트워크 요청, 파일 읽기/쓰기 등 I/O 작업에서 효율적 코루틴은 스레드보다 가벼워서 수천 개의 동시 작업도 효율적으로 처리 가능 일반적인 Coroutine 코드 Coroutine으로 실행 되기는 하나, 비동기로 실행 되지는 않음 async def로 정의된 함수는 코루틴 함수가 됨 await는 다른 코루틴의 실행이 완료될 때까지 대기 asyncio.sleep()은 I/O 작업을 시뮬레이션하는 용도로 자주 사용됨 import asyncio from datetime import datetime def time_log(step): print(datetime.now().strftime('%H:%M:%S'), step) async def async_sleep(): await asyncio.sleep(2) time_log('async_sleep') async def async_execute(): time_log('start') await async_sleep() await async_sleep() time_log('end') def main(): asyncio.run(async_execute()) if __name__ == '__main__': main() [Running] set PYTHONIOENCODING=utf8 \u0026\u0026 python -u tempCodeRunnerFile.python 11:39:00 start 11:39:02 async_sleep 11:39:04 async_sleep 11:39:04 end 실행 결과를 보면 start -\u003e 2초 대기 -\u003e async_sleep -\u003e 2초 대기 -\u003e async_sleep -\u003e end 순서로 순차 실행됨을 알 수 있습니다.\nasyncio 비동기 동시 실행 asyncio.create_task: 코루틴을 태스크로 변환하여 이벤트 루프의 실행 큐에 예약 태스크로 변환되면 곧바로 실행이 시작됨 여러 태스크가 동시에 실행될 수 있음 await: 코루틴, 태스크, Future 객체의 완료를 대기 await 없이 create_task만 하면 태스크가 완료되기 전에 프로그램이 종료될 수 있음 asyncio.run: Python 3.7 이상에서 사용 가능한 고수준 API 새로운 이벤트 루프를 생성하고 코루틴을 실행 프로그램 시작점에서 한 번만 호출해야 함 import asyncio from datetime import datetime def time_log(step): print(datetime.now().strftime('%H:%M:%S'), step) async def async_sleep(): await asyncio.sleep(2) time_log('async_sleep') async def async_execute(): time_log('start') # Event loop에 의한 실행 예약 asleep1 = asyncio.create_task(async_sleep()) asleep2 = asyncio.create_task(async_sleep()) # 실행 완료 대기 await asleep1 await asleep2 time_log('end') def main(): # asyncio event loop 생성 및 실행 객체 관리 asyncio.run(async_execute()) # asyncio.run 대신 저수준 함수 사용 예 : run_until_complete # loop = asyncio.get_event_loop() # loop.run_until_complete(async_execute()) if __name__ == '__main__': main() [Running] set PYTHONIOENCODING=utf8 \u0026\u0026 python -u tempCodeRunnerFile.python 11:42:33 start 11:42:35 async_sleep 11:42:35 async_sleep 11:42:35 end 이 버전은 두 async_sleep이 동시에 실행되어 총 2초만에 완료됩니다.\nasyncio 동시에 여러개 Task 예약 asyncio.gather: 여러 awaitable 객체를 동시에 실행 모든 태스크가 완료될 때까지 대기 태스크들의 실행 순서는 보장되지 않음 CPU 바운드가 아닌 I/O 작업의 경우 실제로 병렬 처리 효과를 얻을 수 있음 import asyncio from datetime import datetime def time_log(step): print(datetime.now().strftime('%H:%M:%S'), step) async def async_sleep(): await asyncio.sleep(2) time_log('async_sleep') async def async_execute(): time_log('start') tasks = [] for i in range(5): t = asyncio.create_task(async_sleep()) tasks.append(t) # task 의 배열, 모두 실행 완료대기 await asyncio.gather(*tasks) time_log('end') def main(): asyncio.run(async_execute()) if __name__ == '__main__': main() [Running] set PYTHONIOENCODING=utf8 \u0026\u0026 python -u tempCodeRunnerFile.python 12:15:01 start 12:15:03 async_sleep 12:15:03 async_sleep 12:15:03 async_sleep 12:15:03 async_sleep 12:15:03 async_sleep 12:15:03 end 5개의 태스크가 동시에 실행되어 여전히 2초 정도만 소요됩니다.\nasyncio 동시에 여러개 Task 예약 (리턴값 처리) gather는 각 태스크의 반환값을 리스트로 수집 태스크의 실행 순서와 관계없이 전달한 순서대로 결과가 저장됨 어떤 태스크에서 예외가 발생하면 gather도 예외를 발생시킴 import asyncio from datetime import datetime def time_log(step): print(datetime.now().strftime('%H:%M:%S'), step) async def async_sleep(): await asyncio.sleep(2) return datetime.now().strftime('%H:%M:%S') + ' async_sleep' async def async_execute(): time_log('start') tasks = [] for i in range(5): t = asyncio.create_task(async_sleep()) tasks.append(t) # Future 및 Task 객체 대기 및 리턴값 수집 fut = await asyncio.gather(*tasks) [ print(f) for f in fut ] time_log('end') def main(): asyncio.run(async_execute()) if __name__ == '__main__': main() [Running] set PYTHONIOENCODING=utf8 \u0026\u0026 python -u tempCodeRunnerFile.python 12:24:41 start 12:24:43 async_sleep 12:24:43 async_sleep 12:24:43 async_sleep 12:24:43 async_sleep 12:24:43 async_sleep 12:24:43 end awaitable 하지 않은 blocking 함수 asyncio 실행 일반적인 동기 함수(time.sleep 등)는 이벤트 루프를 블록하므로 직접 await 불가 run_in_executor: 동기 함수를 별도의 스레드 풀에서 실행 기본 실행기(executor=None)는 ThreadPoolExecutor 사용 CPU 바운드 작업의 경우 ProcessPoolExecutor를 사용하는 것이 유리 Future 객체를 반환하므로 await로 완료 대기 가능 import asyncio from asyncio import futures import time from datetime import datetime def time_log(step): print(datetime.now().strftime('%H:%M:%S'), step) def sync_sleep(name): time.sleep(2) # blocking return datetime.now().strftime('%H:%M:%S') + ' ' + name async def async_execute(): time_log('start') loop = asyncio.get_running_loop() futures = [] for i in range(5): # executor가 `None` 이면 기본 실행기 # run_in_executor 저수준 함수를 통해 동기 함수 등록 t = loop.run_in_executor(None, sync_sleep, str(i)) futures.append(t) # Future 객체 대기 fut = await asyncio.gather(*futures) [ print(f) for f in fut ] time_log('end') def main(): asyncio.run(async_execute()) if __name__ == '__main__': main() [Running] set PYTHONIOENCODING=utf8 \u0026\u0026 python -u tempCodeRunnerFile.python 12:34:14 start 12:34:16 0 12:34:16 1 12:34:16 2 12:34:16 3 12:34:16 4 12:34:16 end 주요 추가 고려사항:\n에러 처리를 위해 try/except 사용을 권장 태스크 취소 처리도 고려해야 할 수 있음 데이터베이스 등의 리소스는 비동기 라이브러리(aiohttp, asyncpg 등) 사용 권장 디버깅이 어려울 수 있으므로 로깅을 적극 활용 ","wordCount":"752","inLanguage":"en","datePublished":"2021-10-31T00:00:00+09:00","dateModified":"2021-10-31T00:00:00+09:00","author":{"@type":"Person","name":"Byung Kyu KIM"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://cdecl.github.io/dev/python-asyncio/"},"publisher":{"@type":"Organization","name":"cdeclog","logo":{"@type":"ImageObject","url":"https://cdecl.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://cdecl.github.io/ accesskey=h title="cdeclog (Alt + H)">cdeclog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://cdecl.github.io/dev/ title=Dev><span>Dev</span></a></li><li><a href=https://cdecl.github.io/devops/ title=DevOps><span>DevOps</span></a></li><li><a href=https://cdecl.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://cdecl.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://cdecl.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Python asyncio</h1><div class=post-meta><span title='2021-10-31 00:00:00 +0900 KST'>October 31, 2021</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#asyncio--asynchronous-io-%ec%b2%98%eb%a6%ac aria-label="asyncio : asynchronous io 처리">asyncio : asynchronous io 처리</a><ul><li><a href=#%ec%9d%bc%eb%b0%98%ec%a0%81%ec%9d%b8-coroutine-%ec%bd%94%eb%93%9c aria-label="일반적인 Coroutine 코드">일반적인 Coroutine 코드</a></li><li><a href=#asyncio-%eb%b9%84%eb%8f%99%ea%b8%b0-%eb%8f%99%ec%8b%9c-%ec%8b%a4%ed%96%89 aria-label="asyncio 비동기 동시 실행">asyncio 비동기 동시 실행</a><ul><li><a href=#asyncio-%eb%8f%99%ec%8b%9c%ec%97%90-%ec%97%ac%eb%9f%ac%ea%b0%9c-task-%ec%98%88%ec%95%bd aria-label="asyncio 동시에 여러개 Task 예약">asyncio 동시에 여러개 Task 예약</a></li><li><a href=#asyncio-%eb%8f%99%ec%8b%9c%ec%97%90-%ec%97%ac%eb%9f%ac%ea%b0%9c-task-%ec%98%88%ec%95%bd-%eb%a6%ac%ed%84%b4%ea%b0%92-%ec%b2%98%eb%a6%ac aria-label="asyncio 동시에 여러개 Task 예약 (리턴값 처리)">asyncio 동시에 여러개 Task 예약 (리턴값 처리)</a></li></ul></li><li><a href=#awaitable-%ed%95%98%ec%a7%80-%ec%95%8a%ec%9d%80-blocking-%ed%95%a8%ec%88%98-asyncio-%ec%8b%a4%ed%96%89 aria-label="awaitable 하지 않은 blocking 함수 asyncio 실행">awaitable 하지 않은 blocking 함수 asyncio 실행</a></li></ul></li></ul></div></details></div><div class=post-content><p><code>asyncio</code>는 <code>async</code>/<code>await</code> 구문을 사용하여 동시성 코드를 작성하는 라이브러리입니다. 특히 I/O 작업이 많은 애플리케이션에서 높은 성능을 발휘합니다.</p><h2 id=asyncio--asynchronous-io-처리>asyncio : asynchronous io 처리<a hidden class=anchor aria-hidden=true href=#asyncio--asynchronous-io-처리>#</a></h2><ul><li><a href=https://docs.python.org/ko/3/library/asyncio.html>https://docs.python.org/ko/3/library/asyncio.html</a>{:target="_blank"}</li><li><code>Threading</code> 동시성 제어는 <code>GIL (Global interpreter lock)</code> 제약에 의해 느리고, 복잡도는 그대로 가지고 있음<ul><li>GIL은 Python 인터프리터가 한 번에 하나의 스레드만 실행할 수 있도록 제한하는 메커니즘</li><li>멀티스레드를 사용해도 CPU 연산의 실제 병렬 처리가 어려움</li></ul></li><li>IO 병목에 의한 동시성을 관리하기 위한 도구로서 <code>Coroutine</code>을 통한 관리<ul><li>네트워크 요청, 파일 읽기/쓰기 등 I/O 작업에서 효율적</li><li>코루틴은 스레드보다 가벼워서 수천 개의 동시 작업도 효율적으로 처리 가능</li></ul></li></ul><h3 id=일반적인-coroutine-코드>일반적인 <code>Coroutine</code> 코드<a hidden class=anchor aria-hidden=true href=#일반적인-coroutine-코드>#</a></h3><ul><li><code>Coroutine</code>으로 실행 되기는 하나, 비동기로 실행 되지는 않음</li><li><code>async def</code>로 정의된 함수는 코루틴 함수가 됨</li><li><code>await</code>는 다른 코루틴의 실행이 완료될 때까지 대기</li><li><code>asyncio.sleep()</code>은 I/O 작업을 시뮬레이션하는 용도로 자주 사용됨</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> asyncio
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> datetime <span style=color:#f92672>import</span> datetime
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>time_log</span>(step):
</span></span><span style=display:flex><span>    print(datetime<span style=color:#f92672>.</span>now()<span style=color:#f92672>.</span>strftime(<span style=color:#e6db74>&#39;%H:%M:%S&#39;</span>), step)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>async_sleep</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> asyncio<span style=color:#f92672>.</span>sleep(<span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>    time_log(<span style=color:#e6db74>&#39;async_sleep&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>async_execute</span>():
</span></span><span style=display:flex><span>    time_log(<span style=color:#e6db74>&#39;start&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> async_sleep()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> async_sleep()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    time_log(<span style=color:#e6db74>&#39;end&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>main</span>():
</span></span><span style=display:flex><span>    asyncio<span style=color:#f92672>.</span>run(async_execute())
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;__main__&#39;</span>:
</span></span><span style=display:flex><span>    main()
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#f92672>[</span>Running<span style=color:#f92672>]</span> set PYTHONIOENCODING<span style=color:#f92672>=</span>utf8 <span style=color:#f92672>&amp;&amp;</span> python -u tempCodeRunnerFile.python
</span></span><span style=display:flex><span>11:39:00 start
</span></span><span style=display:flex><span>11:39:02 async_sleep
</span></span><span style=display:flex><span>11:39:04 async_sleep
</span></span><span style=display:flex><span>11:39:04 end
</span></span></code></pre></div><p>실행 결과를 보면 start -> 2초 대기 -> async_sleep -> 2초 대기 -> async_sleep -> end 순서로 순차 실행됨을 알 수 있습니다.</p><h3 id=asyncio-비동기-동시-실행><code>asyncio</code> 비동기 동시 실행<a hidden class=anchor aria-hidden=true href=#asyncio-비동기-동시-실행>#</a></h3><ul><li><code>asyncio.create_task</code>: 코루틴을 태스크로 변환하여 이벤트 루프의 실행 큐에 예약<ul><li>태스크로 변환되면 곧바로 실행이 시작됨</li><li>여러 태스크가 동시에 실행될 수 있음</li></ul></li><li><code>await</code>: 코루틴, 태스크, Future 객체의 완료를 대기<ul><li>await 없이 create_task만 하면 태스크가 완료되기 전에 프로그램이 종료될 수 있음</li></ul></li><li><code>asyncio.run</code>: Python 3.7 이상에서 사용 가능한 고수준 API<ul><li>새로운 이벤트 루프를 생성하고 코루틴을 실행</li><li>프로그램 시작점에서 한 번만 호출해야 함</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> asyncio
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> datetime <span style=color:#f92672>import</span> datetime
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>time_log</span>(step):
</span></span><span style=display:flex><span>    print(datetime<span style=color:#f92672>.</span>now()<span style=color:#f92672>.</span>strftime(<span style=color:#e6db74>&#39;%H:%M:%S&#39;</span>), step)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>async_sleep</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> asyncio<span style=color:#f92672>.</span>sleep(<span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>    time_log(<span style=color:#e6db74>&#39;async_sleep&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>async_execute</span>():
</span></span><span style=display:flex><span>    time_log(<span style=color:#e6db74>&#39;start&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Event loop에 의한 실행 예약 </span>
</span></span><span style=display:flex><span>    asleep1 <span style=color:#f92672>=</span> asyncio<span style=color:#f92672>.</span>create_task(async_sleep())
</span></span><span style=display:flex><span>    asleep2 <span style=color:#f92672>=</span> asyncio<span style=color:#f92672>.</span>create_task(async_sleep())
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 실행 완료 대기 </span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> asleep1
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> asleep2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    time_log(<span style=color:#e6db74>&#39;end&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>main</span>():
</span></span><span style=display:flex><span>    <span style=color:#75715e># asyncio event loop 생성 및 실행 객체 관리 </span>
</span></span><span style=display:flex><span>    asyncio<span style=color:#f92672>.</span>run(async_execute())
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># asyncio.run 대신 저수준 함수 사용 예 : run_until_complete</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># loop = asyncio.get_event_loop()</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># loop.run_until_complete(async_execute())</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;__main__&#39;</span>:
</span></span><span style=display:flex><span>    main()
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#f92672>[</span>Running<span style=color:#f92672>]</span> set PYTHONIOENCODING<span style=color:#f92672>=</span>utf8 <span style=color:#f92672>&amp;&amp;</span> python -u tempCodeRunnerFile.python
</span></span><span style=display:flex><span>11:42:33 start
</span></span><span style=display:flex><span>11:42:35 async_sleep
</span></span><span style=display:flex><span>11:42:35 async_sleep
</span></span><span style=display:flex><span>11:42:35 end
</span></span></code></pre></div><p>이 버전은 두 async_sleep이 동시에 실행되어 총 2초만에 완료됩니다.</p><h4 id=asyncio-동시에-여러개-task-예약><code>asyncio</code> 동시에 여러개 <code>Task</code> 예약<a hidden class=anchor aria-hidden=true href=#asyncio-동시에-여러개-task-예약>#</a></h4><ul><li><code>asyncio.gather</code>: 여러 awaitable 객체를 동시에 실행<ul><li>모든 태스크가 완료될 때까지 대기</li><li>태스크들의 실행 순서는 보장되지 않음</li><li>CPU 바운드가 아닌 I/O 작업의 경우 실제로 병렬 처리 효과를 얻을 수 있음</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> asyncio
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> datetime <span style=color:#f92672>import</span> datetime
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>time_log</span>(step):
</span></span><span style=display:flex><span>    print(datetime<span style=color:#f92672>.</span>now()<span style=color:#f92672>.</span>strftime(<span style=color:#e6db74>&#39;%H:%M:%S&#39;</span>), step)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>async_sleep</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> asyncio<span style=color:#f92672>.</span>sleep(<span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>    time_log(<span style=color:#e6db74>&#39;async_sleep&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>async_execute</span>():
</span></span><span style=display:flex><span>    time_log(<span style=color:#e6db74>&#39;start&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    tasks <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>5</span>):
</span></span><span style=display:flex><span>        t <span style=color:#f92672>=</span> asyncio<span style=color:#f92672>.</span>create_task(async_sleep())
</span></span><span style=display:flex><span>        tasks<span style=color:#f92672>.</span>append(t)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># task 의 배열, 모두 실행 완료대기 </span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> asyncio<span style=color:#f92672>.</span>gather(<span style=color:#f92672>*</span>tasks)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    time_log(<span style=color:#e6db74>&#39;end&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>main</span>():
</span></span><span style=display:flex><span>    asyncio<span style=color:#f92672>.</span>run(async_execute())
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;__main__&#39;</span>:
</span></span><span style=display:flex><span>    main()
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#f92672>[</span>Running<span style=color:#f92672>]</span> set PYTHONIOENCODING<span style=color:#f92672>=</span>utf8 <span style=color:#f92672>&amp;&amp;</span> python -u tempCodeRunnerFile.python
</span></span><span style=display:flex><span>12:15:01 start
</span></span><span style=display:flex><span>12:15:03 async_sleep
</span></span><span style=display:flex><span>12:15:03 async_sleep
</span></span><span style=display:flex><span>12:15:03 async_sleep
</span></span><span style=display:flex><span>12:15:03 async_sleep
</span></span><span style=display:flex><span>12:15:03 async_sleep
</span></span><span style=display:flex><span>12:15:03 end
</span></span></code></pre></div><p>5개의 태스크가 동시에 실행되어 여전히 2초 정도만 소요됩니다.</p><h4 id=asyncio-동시에-여러개-task-예약-리턴값-처리><code>asyncio</code> 동시에 여러개 <code>Task</code> 예약 (리턴값 처리)<a hidden class=anchor aria-hidden=true href=#asyncio-동시에-여러개-task-예약-리턴값-처리>#</a></h4><ul><li>gather는 각 태스크의 반환값을 리스트로 수집</li><li>태스크의 실행 순서와 관계없이 전달한 순서대로 결과가 저장됨</li><li>어떤 태스크에서 예외가 발생하면 gather도 예외를 발생시킴</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> asyncio
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> datetime <span style=color:#f92672>import</span> datetime
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>time_log</span>(step):
</span></span><span style=display:flex><span>    print(datetime<span style=color:#f92672>.</span>now()<span style=color:#f92672>.</span>strftime(<span style=color:#e6db74>&#39;%H:%M:%S&#39;</span>), step)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>async_sleep</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> asyncio<span style=color:#f92672>.</span>sleep(<span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> datetime<span style=color:#f92672>.</span>now()<span style=color:#f92672>.</span>strftime(<span style=color:#e6db74>&#39;%H:%M:%S&#39;</span>) <span style=color:#f92672>+</span> <span style=color:#e6db74>&#39; async_sleep&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>async_execute</span>():
</span></span><span style=display:flex><span>    time_log(<span style=color:#e6db74>&#39;start&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    tasks <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>5</span>):
</span></span><span style=display:flex><span>        t <span style=color:#f92672>=</span> asyncio<span style=color:#f92672>.</span>create_task(async_sleep())
</span></span><span style=display:flex><span>        tasks<span style=color:#f92672>.</span>append(t)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Future 및 Task 객체 대기 및 리턴값 수집</span>
</span></span><span style=display:flex><span>    fut <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> asyncio<span style=color:#f92672>.</span>gather(<span style=color:#f92672>*</span>tasks)
</span></span><span style=display:flex><span>    [ print(f) <span style=color:#66d9ef>for</span> f <span style=color:#f92672>in</span> fut ]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    time_log(<span style=color:#e6db74>&#39;end&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>main</span>():
</span></span><span style=display:flex><span>    asyncio<span style=color:#f92672>.</span>run(async_execute())
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;__main__&#39;</span>:
</span></span><span style=display:flex><span>    main()
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#f92672>[</span>Running<span style=color:#f92672>]</span> set PYTHONIOENCODING<span style=color:#f92672>=</span>utf8 <span style=color:#f92672>&amp;&amp;</span> python -u tempCodeRunnerFile.python
</span></span><span style=display:flex><span>12:24:41 start
</span></span><span style=display:flex><span>12:24:43 async_sleep
</span></span><span style=display:flex><span>12:24:43 async_sleep
</span></span><span style=display:flex><span>12:24:43 async_sleep
</span></span><span style=display:flex><span>12:24:43 async_sleep
</span></span><span style=display:flex><span>12:24:43 async_sleep
</span></span><span style=display:flex><span>12:24:43 end
</span></span></code></pre></div><hr><h3 id=awaitable-하지-않은-blocking-함수-asyncio-실행>awaitable 하지 않은 blocking 함수 <code>asyncio</code> 실행<a hidden class=anchor aria-hidden=true href=#awaitable-하지-않은-blocking-함수-asyncio-실행>#</a></h3><ul><li>일반적인 동기 함수(time.sleep 등)는 이벤트 루프를 블록하므로 직접 await 불가</li><li><code>run_in_executor</code>: 동기 함수를 별도의 스레드 풀에서 실행<ul><li>기본 실행기(executor=None)는 ThreadPoolExecutor 사용</li><li>CPU 바운드 작업의 경우 ProcessPoolExecutor를 사용하는 것이 유리</li><li>Future 객체를 반환하므로 await로 완료 대기 가능</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> asyncio
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> asyncio <span style=color:#f92672>import</span> futures
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> time
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> datetime <span style=color:#f92672>import</span> datetime
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>time_log</span>(step):
</span></span><span style=display:flex><span>    print(datetime<span style=color:#f92672>.</span>now()<span style=color:#f92672>.</span>strftime(<span style=color:#e6db74>&#39;%H:%M:%S&#39;</span>), step)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>sync_sleep</span>(name):
</span></span><span style=display:flex><span>    time<span style=color:#f92672>.</span>sleep(<span style=color:#ae81ff>2</span>) <span style=color:#75715e># blocking</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> datetime<span style=color:#f92672>.</span>now()<span style=color:#f92672>.</span>strftime(<span style=color:#e6db74>&#39;%H:%M:%S&#39;</span>) <span style=color:#f92672>+</span> <span style=color:#e6db74>&#39; &#39;</span> <span style=color:#f92672>+</span> name
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>async_execute</span>():
</span></span><span style=display:flex><span>    time_log(<span style=color:#e6db74>&#39;start&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    loop <span style=color:#f92672>=</span> asyncio<span style=color:#f92672>.</span>get_running_loop()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    futures <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>5</span>):
</span></span><span style=display:flex><span>        <span style=color:#75715e># executor가 `None` 이면 기본 실행기</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># run_in_executor 저수준 함수를 통해 동기 함수 등록</span>
</span></span><span style=display:flex><span>        t <span style=color:#f92672>=</span> loop<span style=color:#f92672>.</span>run_in_executor(<span style=color:#66d9ef>None</span>, sync_sleep, str(i))
</span></span><span style=display:flex><span>        futures<span style=color:#f92672>.</span>append(t)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Future 객체 대기 </span>
</span></span><span style=display:flex><span>    fut <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> asyncio<span style=color:#f92672>.</span>gather(<span style=color:#f92672>*</span>futures)
</span></span><span style=display:flex><span>    [ print(f) <span style=color:#66d9ef>for</span> f <span style=color:#f92672>in</span> fut ]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    time_log(<span style=color:#e6db74>&#39;end&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>main</span>():
</span></span><span style=display:flex><span>    asyncio<span style=color:#f92672>.</span>run(async_execute())
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;__main__&#39;</span>:
</span></span><span style=display:flex><span>    main()
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#f92672>[</span>Running<span style=color:#f92672>]</span> set PYTHONIOENCODING<span style=color:#f92672>=</span>utf8 <span style=color:#f92672>&amp;&amp;</span> python -u tempCodeRunnerFile.python
</span></span><span style=display:flex><span>12:34:14 start
</span></span><span style=display:flex><span>12:34:16 <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>12:34:16 <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>12:34:16 <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>12:34:16 <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>12:34:16 <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>12:34:16 end
</span></span></code></pre></div><p>주요 추가 고려사항:</p><ul><li>에러 처리를 위해 try/except 사용을 권장</li><li>태스크 취소 처리도 고려해야 할 수 있음</li><li>데이터베이스 등의 리소스는 비동기 라이브러리(aiohttp, asyncpg 등) 사용 권장</li><li>디버깅이 어려울 수 있으므로 로깅을 적극 활용</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://cdecl.github.io/tags/python/>Python</a></li><li><a href=https://cdecl.github.io/tags/asyncio/>Asyncio</a></li><li><a href=https://cdecl.github.io/tags/async/>Async</a></li><li><a href=https://cdecl.github.io/tags/await/>Await</a></li><li><a href=https://cdecl.github.io/tags/coroutine/>Coroutine</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://cdecl.github.io/>cdeclog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>