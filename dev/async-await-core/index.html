<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Async/Await의 본질: 우리는 왜 '기다림'을 '멈춤'으로 착각하는가? | cdeclog</title><meta name=keywords content="async,await,coroutine,event-loop,javascript,python,csharp,thread-pool,concurrency"><meta name=description content='Async/Await의 본질: 우리는 왜 &lsquo;기다림&rsquo;을 &lsquo;멈춤&rsquo;으로 착각하는가?
많은 개발자가 await를 보면 &ldquo;코드가 여기서 멈춘다"라고 직관적으로 이해합니다. 하지만 이는 논리적 흐름의 멈춤일 뿐, 물리적인 스레드가 멈추는 블로킹은 아닙니다. async/await는 동기 코드처럼 보이게 만들면서, 실제로는 실행 흐름을 나눠 코루틴처럼 동작합니다.
이 글은 JavaScript, Python, C#을 비교해 async/await가 어떻게 &ldquo;동기처럼 보이는 비동기"를 만드는지 설명합니다.
1. 가장 큰 오해: 멈춤이 아니라 양보
await는 실행 흐름을 잠시 중단시키지만, 스레드 전체를 멈추지는 않습니다. 핵심은 다음입니다.

await는 현재 함수의 실행 컨텍스트를 일시 중단한다.
제어권은 즉시 호출자나 이벤트 루프로 돌아간다.
작업이 끝나면 중단 지점부터 다시 이어서 실행된다.

비유로 말하면, 식당에서 진동벨을 받고 자리에 앉는 것과 같습니다. 나는 기다리지만, 카운터 앞을 막고 서 있지는 않습니다.'><meta name=author content="Byung Kyu KIM"><link rel=canonical href=https://cdecl.github.io/dev/async-await-core/><link crossorigin=anonymous href=/assets/css/stylesheet.f939c4ffefb264e6fe85e04352266f79db6bb1303c8e16ae9b6064c1247b5e32.css integrity="sha256-+TnE/++yZOb+heBDUiZvedtrsTA8jhaum2BkwSR7XjI=" rel="preload stylesheet" as=style><link rel=icon href=https://cdecl.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://cdecl.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://cdecl.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://cdecl.github.io/apple-touch-icon.png><link rel=mask-icon href=https://cdecl.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://cdecl.github.io/dev/async-await-core/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-VQQHHYPN7K"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VQQHHYPN7K")}</script><meta property="og:url" content="https://cdecl.github.io/dev/async-await-core/"><meta property="og:site_name" content="cdeclog"><meta property="og:title" content="Async/Await의 본질: 우리는 왜 '기다림'을 '멈춤'으로 착각하는가?"><meta property="og:description" content='Async/Await의 본질: 우리는 왜 ‘기다림’을 ‘멈춤’으로 착각하는가?
많은 개발자가 await를 보면 “코드가 여기서 멈춘다"라고 직관적으로 이해합니다. 하지만 이는 논리적 흐름의 멈춤일 뿐, 물리적인 스레드가 멈추는 블로킹은 아닙니다. async/await는 동기 코드처럼 보이게 만들면서, 실제로는 실행 흐름을 나눠 코루틴처럼 동작합니다.
이 글은 JavaScript, Python, C#을 비교해 async/await가 어떻게 “동기처럼 보이는 비동기"를 만드는지 설명합니다.
1. 가장 큰 오해: 멈춤이 아니라 양보 await는 실행 흐름을 잠시 중단시키지만, 스레드 전체를 멈추지는 않습니다. 핵심은 다음입니다.
await는 현재 함수의 실행 컨텍스트를 일시 중단한다. 제어권은 즉시 호출자나 이벤트 루프로 돌아간다. 작업이 끝나면 중단 지점부터 다시 이어서 실행된다. 비유로 말하면, 식당에서 진동벨을 받고 자리에 앉는 것과 같습니다. 나는 기다리지만, 카운터 앞을 막고 서 있지는 않습니다.'><meta property="og:locale" content="ko-kr"><meta property="og:type" content="article"><meta property="article:section" content="dev"><meta property="article:published_time" content="2026-02-06T00:00:00+09:00"><meta property="article:modified_time" content="2026-02-06T00:00:00+09:00"><meta property="article:tag" content="Async"><meta property="article:tag" content="Await"><meta property="article:tag" content="Coroutine"><meta property="article:tag" content="Event-Loop"><meta property="article:tag" content="Javascript"><meta property="article:tag" content="Python"><meta name=twitter:card content="summary"><meta name=twitter:title content="Async/Await의 본질: 우리는 왜 '기다림'을 '멈춤'으로 착각하는가?"><meta name=twitter:description content='Async/Await의 본질: 우리는 왜 &lsquo;기다림&rsquo;을 &lsquo;멈춤&rsquo;으로 착각하는가?
많은 개발자가 await를 보면 &ldquo;코드가 여기서 멈춘다"라고 직관적으로 이해합니다. 하지만 이는 논리적 흐름의 멈춤일 뿐, 물리적인 스레드가 멈추는 블로킹은 아닙니다. async/await는 동기 코드처럼 보이게 만들면서, 실제로는 실행 흐름을 나눠 코루틴처럼 동작합니다.
이 글은 JavaScript, Python, C#을 비교해 async/await가 어떻게 &ldquo;동기처럼 보이는 비동기"를 만드는지 설명합니다.
1. 가장 큰 오해: 멈춤이 아니라 양보
await는 실행 흐름을 잠시 중단시키지만, 스레드 전체를 멈추지는 않습니다. 핵심은 다음입니다.

await는 현재 함수의 실행 컨텍스트를 일시 중단한다.
제어권은 즉시 호출자나 이벤트 루프로 돌아간다.
작업이 끝나면 중단 지점부터 다시 이어서 실행된다.

비유로 말하면, 식당에서 진동벨을 받고 자리에 앉는 것과 같습니다. 나는 기다리지만, 카운터 앞을 막고 서 있지는 않습니다.'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Devs","item":"https://cdecl.github.io/dev/"},{"@type":"ListItem","position":2,"name":"Async/Await의 본질: 우리는 왜 '기다림'을 '멈춤'으로 착각하는가?","item":"https://cdecl.github.io/dev/async-await-core/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Async/Await의 본질: 우리는 왜 '기다림'을 '멈춤'으로 착각하는가?","name":"Async\/Await의 본질: 우리는 왜 \u0027기다림\u0027을 \u0027멈춤\u0027으로 착각하는가?","description":"Async/Await의 본질: 우리는 왜 \u0026lsquo;기다림\u0026rsquo;을 \u0026lsquo;멈춤\u0026rsquo;으로 착각하는가?\n많은 개발자가 await를 보면 \u0026ldquo;코드가 여기서 멈춘다\u0026quot;라고 직관적으로 이해합니다. 하지만 이는 논리적 흐름의 멈춤일 뿐, 물리적인 스레드가 멈추는 블로킹은 아닙니다. async/await는 동기 코드처럼 보이게 만들면서, 실제로는 실행 흐름을 나눠 코루틴처럼 동작합니다.\n이 글은 JavaScript, Python, C#을 비교해 async/await가 어떻게 \u0026ldquo;동기처럼 보이는 비동기\u0026quot;를 만드는지 설명합니다.\n1. 가장 큰 오해: 멈춤이 아니라 양보 await는 실행 흐름을 잠시 중단시키지만, 스레드 전체를 멈추지는 않습니다. 핵심은 다음입니다.\nawait는 현재 함수의 실행 컨텍스트를 일시 중단한다. 제어권은 즉시 호출자나 이벤트 루프로 돌아간다. 작업이 끝나면 중단 지점부터 다시 이어서 실행된다. 비유로 말하면, 식당에서 진동벨을 받고 자리에 앉는 것과 같습니다. 나는 기다리지만, 카운터 앞을 막고 서 있지는 않습니다.\n","keywords":["async","await","coroutine","event-loop","javascript","python","csharp","thread-pool","concurrency"],"articleBody":"Async/Await의 본질: 우리는 왜 ‘기다림’을 ‘멈춤’으로 착각하는가?\n많은 개발자가 await를 보면 “코드가 여기서 멈춘다\"라고 직관적으로 이해합니다. 하지만 이는 논리적 흐름의 멈춤일 뿐, 물리적인 스레드가 멈추는 블로킹은 아닙니다. async/await는 동기 코드처럼 보이게 만들면서, 실제로는 실행 흐름을 나눠 코루틴처럼 동작합니다.\n이 글은 JavaScript, Python, C#을 비교해 async/await가 어떻게 “동기처럼 보이는 비동기\"를 만드는지 설명합니다.\n1. 가장 큰 오해: 멈춤이 아니라 양보 await는 실행 흐름을 잠시 중단시키지만, 스레드 전체를 멈추지는 않습니다. 핵심은 다음입니다.\nawait는 현재 함수의 실행 컨텍스트를 일시 중단한다. 제어권은 즉시 호출자나 이벤트 루프로 돌아간다. 작업이 끝나면 중단 지점부터 다시 이어서 실행된다. 비유로 말하면, 식당에서 진동벨을 받고 자리에 앉는 것과 같습니다. 나는 기다리지만, 카운터 앞을 막고 서 있지는 않습니다.\n2. 코루틴 메커니즘: 실행 흐름의 분할과 재개 async/await의 핵심은 서브루틴이 아니라 코루틴의 개념입니다.\n실행 중 await를 만나면 상태를 저장하고 밖으로 빠져나온다. 비동기 작업이 완료되면 저장된 상태에서 다시 재개된다. 문법은 다르지만 구조는 제너레이터 + 프라미스/퓨처 조합과 유사하다. 실행 흐름 다이어그램 [caller] -\u003e async func 실행 -\u003e await 도달 (suspend) -\u003e 제어권 반환 [loop] -\u003e 다른 작업 실행 -\u003e 작업 완료 이벤트 -\u003e async func resume 3. 언어별 내부 구현 비교 차이점은 다음 두 질문에 있습니다.\n기다리는 동안 스레드는 무엇을 하는가? 재개될 때 어디서 실행되는가? 3.1 JavaScript와 Python: 싱글 스레드 이벤트 루프 모델은 이벤트 루프 기반 협력적 멀티태스킹입니다.\nawait는 작업을 백그라운드에 위임하고, 메인 루프는 즉시 다른 작업을 수행한다. 완료된 작업은 큐에 쌓이고, 루프가 비었을 때 재개된다. 재개 위치는 이벤트 루프가 도는 동일 스레드다. 주의점은 간단합니다. 동기 함수가 오래 걸리면 루프 전체가 막힙니다. Python에서 time.sleep()을 asyncio 안에서 호출하면 모든 코루틴이 멈춘 것처럼 보입니다.\n3.2 C# (.NET): 상태 머신 + 스레드 풀 C#은 컴파일러가 async 메서드를 상태 머신으로 변환합니다.\nawait 지점에서 스레드는 풀로 반환된다. 작업이 끝나면 컨텍스트에 따라 원래 스레드나 다른 풀 스레드에서 재개된다. SynchronizationContext가 있으면 원래 컨텍스트로 돌아가고, 없으면 풀 스레드에서 이어진다. Wait()는 스레드를 점유한 채로 멈추지만, await는 스레드를 놓아줍니다. 이 차이가 처리량과 확장성에서 큰 차이를 만듭니다.\n3.3 C++20 코루틴: 상태 머신 + 실행자(Executor) 의존 C++20 코루틴도 컴파일러가 상태 머신으로 변환한다는 점은 동일합니다. 하지만 재개가 어디서, 어떤 스레드에서 일어나는지는 표준이 정하지 않습니다.\nco_await는 현재 코루틴의 상태를 저장하고 호출자(또는 프레임워크)로 제어권을 넘긴다. 재개는 사용하는 라이브러리/프레임워크의 실행자(Executor) 정책에 따라 결정된다. 기본적으로 “스레드 풀에서 이어진다”가 아니라, 어떤 스레드로 돌아갈지는 구현에 달려 있다. 즉, C#은 런타임과 스레드 풀의 결합이 명확한 반면, C++은 코루틴 자체는 저수준 도구이고 스케줄링 정책은 라이브러리가 맡습니다.\n3.4 언어별 비동기 흐름의 공통점과 분기점 비동기 문법은 서로 닮았지만, “누가 스케줄링을 책임지느냐”가 핵심 분기입니다.\nJS/Python: 이벤트 루프가 단일 스레드에서 태스크를 순차적으로 재개한다. C#: 런타임이 스레드 풀과 컨텍스트를 관리하며 재개 지점을 결정한다. C++: 코루틴은 상태 머신만 제공하고, 실행자/프레임워크가 재개 정책을 정한다. 4. Wait vs Await: 가독성 이상의 의미 async/await는 단순히 콜백 지옥을 피하는 문법이 아닙니다. 리소스 관리 그 자체입니다.\n구분 Blocking (Wait, Sleep) Non-Blocking (await) 스레드 상태 대기 중이며 점유 해방되어 다른 작업 가능 처리량 스레드 수에 제한 적은 스레드로 높은 처리량 적합한 작업 CPU Bound I/O Bound 5. 비동기 문법의 유사성과 차이: “await”와 “스레드” 많은 언어가 async/await 형태를 공유하지만, 실제로는 “스레드 비동기”와 “이벤트 루프 비동기”가 섞여 있습니다.\n5.1 문법적 유사성 공통점: async 함수는 즉시 반환하고, await는 결과가 준비될 때까지 논리적 대기 상태로 들어간다. 결과: 코드 흐름은 동기처럼 보이지만, 실행은 분할되어 스케줄러가 재개한다. 5.2 기능적 차이점: await가 “스레드”를 의미하지는 않는다 JS/Python: await는 스레드를 만들지 않는다. 이벤트 루프에 제어권을 돌려준다. C#: await는 스레드를 생성하지 않지만, 재개는 스레드 풀에서 일어날 수 있다. C++: co_await는 스레드를 만들지 않는다. 어떤 스레드에서 재개되는지는 실행자에 달렸다. 결론적으로 await는 “스레드 생성/병렬 실행”과 별개이며, “재개 시점과 위치를 스케줄러에 맡기는 문법”에 가깝습니다.\n6. 비동기 흐름 비교 요약 언어 스케줄링 주체 기본 재개 스레드 비고 JavaScript 이벤트 루프 메인 스레드 단일 스레드 협력적 멀티태스킹 Python 이벤트 루프 루프 스레드 동기 함수 혼용 시 전체 블로킹 C# 런타임 + 스레드 풀 컨텍스트/풀 스레드 SynchronizationContext 영향 C++20 실행자/프레임워크 구현 의존 표준은 스케줄링 정책 미정 7. 짧은 코드 비교 JavaScript: 블로킹 vs 비블로킹 // 블로킹 예시: 긴 CPU 작업 function heavy() { const end = Date.now() + 2000; while (Date.now() \u003c end) {} } console.log('A'); heavy(); console.log('B'); // 비블로킹 예시: I/O 대기 async function run() { console.log('A'); await new Promise(r =\u003e setTimeout(r, 2000)); console.log('B'); } run(); Python: asyncio에서의 차이 import asyncio import time async def bad(): time.sleep(2) # 이벤트 루프 전체가 막힘 async def good(): await asyncio.sleep(2) # 루프에 양보 C#: Wait() vs await // 블로킹 Task.Delay(2000).Wait(); // 논블로킹 await Task.Delay(2000); 8. 핵심 요약 async/await는 동기 코드처럼 보이게 하지만, 실제로는 실행 흐름을 쪼개는 코루틴 메커니즘이다. JavaScript와 Python은 이벤트 루프 기반으로 단일 스레드를 효율적으로 돌려쓴다. C#은 스레드 풀과 상태 머신으로 스레드를 점유하지 않고 재개한다. 본질은 “기다리는 것\"이 아니라 “나중에 할 일로 미뤄두고 자원을 반납하는 것\"이다. 블로그 작성 팁 JS 이벤트 루프 모델과 C# 스레드 풀 모델을 대비하는 그림을 넣으면 이해가 빠르다. Sleep과 await의 차이를 보여주는 간단한 벤치마크 예제를 덧붙이면 독자의 체감이 커진다. ","wordCount":"757","inLanguage":"en","datePublished":"2026-02-06T00:00:00+09:00","dateModified":"2026-02-06T00:00:00+09:00","author":{"@type":"Person","name":"Byung Kyu KIM"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://cdecl.github.io/dev/async-await-core/"},"publisher":{"@type":"Organization","name":"cdeclog","logo":{"@type":"ImageObject","url":"https://cdecl.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://cdecl.github.io/ accesskey=h title="cdeclog (Alt + H)">cdeclog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://cdecl.github.io/dev/ title=Dev><span>Dev</span></a></li><li><a href=https://cdecl.github.io/devops/ title=DevOps><span>DevOps</span></a></li><li><a href=https://cdecl.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://cdecl.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://cdecl.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://cdecl.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://cdecl.github.io/dev/>Devs</a></div><h1 class="post-title entry-hint-parent">Async/Await의 본질: 우리는 왜 '기다림'을 '멈춤'으로 착각하는가?</h1><div class=post-meta><span title='2026-02-06 00:00:00 +0900 KST'>February 6, 2026</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#1-%ea%b0%80%ec%9e%a5-%ed%81%b0-%ec%98%a4%ed%95%b4-%eb%a9%88%ec%b6%a4%ec%9d%b4-%ec%95%84%eb%8b%88%eb%9d%bc-%ec%96%91%eb%b3%b4 aria-label="1. 가장 큰 오해: 멈춤이 아니라 양보">1. 가장 큰 오해: 멈춤이 아니라 양보</a></li><li><a href=#2-%ec%bd%94%eb%a3%a8%ed%8b%b4-%eb%a9%94%ec%bb%a4%eb%8b%88%ec%a6%98-%ec%8b%a4%ed%96%89-%ed%9d%90%eb%a6%84%ec%9d%98-%eb%b6%84%ed%95%a0%ea%b3%bc-%ec%9e%ac%ea%b0%9c aria-label="2. 코루틴 메커니즘: 실행 흐름의 분할과 재개">2. 코루틴 메커니즘: 실행 흐름의 분할과 재개</a><ul><li><a href=#%ec%8b%a4%ed%96%89-%ed%9d%90%eb%a6%84-%eb%8b%a4%ec%9d%b4%ec%96%b4%ea%b7%b8%eb%9e%a8 aria-label="실행 흐름 다이어그램">실행 흐름 다이어그램</a></li></ul></li><li><a href=#3-%ec%96%b8%ec%96%b4%eb%b3%84-%eb%82%b4%eb%b6%80-%ea%b5%ac%ed%98%84-%eb%b9%84%ea%b5%90 aria-label="3. 언어별 내부 구현 비교">3. 언어별 내부 구현 비교</a><ul><li><a href=#31-javascript%ec%99%80-python-%ec%8b%b1%ea%b8%80-%ec%8a%a4%eb%a0%88%eb%93%9c-%ec%9d%b4%eb%b2%a4%ed%8a%b8-%eb%a3%a8%ed%94%84 aria-label="3.1 JavaScript와 Python: 싱글 스레드 이벤트 루프">3.1 JavaScript와 Python: 싱글 스레드 이벤트 루프</a></li><li><a href=#32-c-net-%ec%83%81%ed%83%9c-%eb%a8%b8%ec%8b%a0--%ec%8a%a4%eb%a0%88%eb%93%9c-%ed%92%80 aria-label="3.2 C# (.NET): 상태 머신 + 스레드 풀">3.2 C# (.NET): 상태 머신 + 스레드 풀</a></li><li><a href=#33-c20-%ec%bd%94%eb%a3%a8%ed%8b%b4-%ec%83%81%ed%83%9c-%eb%a8%b8%ec%8b%a0--%ec%8b%a4%ed%96%89%ec%9e%90executor-%ec%9d%98%ec%a1%b4 aria-label="3.3 C++20 코루틴: 상태 머신 + 실행자(Executor) 의존">3.3 C++20 코루틴: 상태 머신 + 실행자(Executor) 의존</a></li><li><a href=#34-%ec%96%b8%ec%96%b4%eb%b3%84-%eb%b9%84%eb%8f%99%ea%b8%b0-%ed%9d%90%eb%a6%84%ec%9d%98-%ea%b3%b5%ed%86%b5%ec%a0%90%ea%b3%bc-%eb%b6%84%ea%b8%b0%ec%a0%90 aria-label="3.4 언어별 비동기 흐름의 공통점과 분기점">3.4 언어별 비동기 흐름의 공통점과 분기점</a></li></ul></li><li><a href=#4-wait-vs-await-%ea%b0%80%eb%8f%85%ec%84%b1-%ec%9d%b4%ec%83%81%ec%9d%98-%ec%9d%98%eb%af%b8 aria-label="4. Wait vs Await: 가독성 이상의 의미">4. Wait vs Await: 가독성 이상의 의미</a></li><li><a href=#5-%eb%b9%84%eb%8f%99%ea%b8%b0-%eb%ac%b8%eb%b2%95%ec%9d%98-%ec%9c%a0%ec%82%ac%ec%84%b1%ea%b3%bc-%ec%b0%a8%ec%9d%b4-await%ec%99%80-%ec%8a%a4%eb%a0%88%eb%93%9c aria-label="5. 비동기 문법의 유사성과 차이: “await”와 “스레드”">5. 비동기 문법의 유사성과 차이: “await”와 “스레드”</a><ul><li><a href=#51-%eb%ac%b8%eb%b2%95%ec%a0%81-%ec%9c%a0%ec%82%ac%ec%84%b1 aria-label="5.1 문법적 유사성">5.1 문법적 유사성</a></li><li><a href=#52-%ea%b8%b0%eb%8a%a5%ec%a0%81-%ec%b0%a8%ec%9d%b4%ec%a0%90-await%ea%b0%80-%ec%8a%a4%eb%a0%88%eb%93%9c%eb%a5%bc-%ec%9d%98%eb%af%b8%ed%95%98%ec%a7%80%eb%8a%94-%ec%95%8a%eb%8a%94%eb%8b%a4 aria-label="5.2 기능적 차이점: await가 “스레드”를 의미하지는 않는다">5.2 기능적 차이점: await가 “스레드”를 의미하지는 않는다</a></li></ul></li><li><a href=#6-%eb%b9%84%eb%8f%99%ea%b8%b0-%ed%9d%90%eb%a6%84-%eb%b9%84%ea%b5%90-%ec%9a%94%ec%95%bd aria-label="6. 비동기 흐름 비교 요약">6. 비동기 흐름 비교 요약</a></li><li><a href=#7-%ec%a7%a7%ec%9d%80-%ec%bd%94%eb%93%9c-%eb%b9%84%ea%b5%90 aria-label="7. 짧은 코드 비교">7. 짧은 코드 비교</a><ul><li><a href=#javascript-%eb%b8%94%eb%a1%9c%ed%82%b9-vs-%eb%b9%84%eb%b8%94%eb%a1%9c%ed%82%b9 aria-label="JavaScript: 블로킹 vs 비블로킹">JavaScript: 블로킹 vs 비블로킹</a></li><li><a href=#python-asyncio%ec%97%90%ec%84%9c%ec%9d%98-%ec%b0%a8%ec%9d%b4 aria-label="Python: asyncio에서의 차이">Python: asyncio에서의 차이</a></li><li><a href=#c-wait-vs-await aria-label="C#: Wait() vs await">C#: Wait() vs await</a></li></ul></li><li><a href=#8-%ed%95%b5%ec%8b%ac-%ec%9a%94%ec%95%bd aria-label="8. 핵심 요약">8. 핵심 요약</a></li><li><a href=#%eb%b8%94%eb%a1%9c%ea%b7%b8-%ec%9e%91%ec%84%b1-%ed%8c%81 aria-label="블로그 작성 팁">블로그 작성 팁</a></li></ul></div></details></div><div class=post-content><p>Async/Await의 본질: 우리는 왜 &lsquo;기다림&rsquo;을 &lsquo;멈춤&rsquo;으로 착각하는가?</p><p>많은 개발자가 <code>await</code>를 보면 &ldquo;코드가 여기서 멈춘다"라고 직관적으로 이해합니다. 하지만 이는 논리적 흐름의 멈춤일 뿐, 물리적인 스레드가 멈추는 블로킹은 아닙니다. async/await는 동기 코드처럼 보이게 만들면서, 실제로는 실행 흐름을 나눠 코루틴처럼 동작합니다.</p><p>이 글은 JavaScript, Python, C#을 비교해 async/await가 어떻게 &ldquo;동기처럼 보이는 비동기"를 만드는지 설명합니다.</p><h2 id=1-가장-큰-오해-멈춤이-아니라-양보>1. 가장 큰 오해: 멈춤이 아니라 양보<a hidden class=anchor aria-hidden=true href=#1-가장-큰-오해-멈춤이-아니라-양보>#</a></h2><p><code>await</code>는 실행 흐름을 잠시 중단시키지만, 스레드 전체를 멈추지는 않습니다. 핵심은 다음입니다.</p><ul><li><code>await</code>는 현재 함수의 실행 컨텍스트를 일시 중단한다.</li><li>제어권은 즉시 호출자나 이벤트 루프로 돌아간다.</li><li>작업이 끝나면 중단 지점부터 다시 이어서 실행된다.</li></ul><p>비유로 말하면, 식당에서 진동벨을 받고 자리에 앉는 것과 같습니다. 나는 기다리지만, 카운터 앞을 막고 서 있지는 않습니다.</p><h2 id=2-코루틴-메커니즘-실행-흐름의-분할과-재개>2. 코루틴 메커니즘: 실행 흐름의 분할과 재개<a hidden class=anchor aria-hidden=true href=#2-코루틴-메커니즘-실행-흐름의-분할과-재개>#</a></h2><p>async/await의 핵심은 서브루틴이 아니라 코루틴의 개념입니다.</p><ul><li>실행 중 <code>await</code>를 만나면 상태를 저장하고 밖으로 빠져나온다.</li><li>비동기 작업이 완료되면 저장된 상태에서 다시 재개된다.</li><li>문법은 다르지만 구조는 제너레이터 + 프라미스/퓨처 조합과 유사하다.</li></ul><h3 id=실행-흐름-다이어그램>실행 흐름 다이어그램<a hidden class=anchor aria-hidden=true href=#실행-흐름-다이어그램>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>[caller] -&gt; async func 실행
</span></span><span style=display:flex><span>         -&gt; await 도달 (suspend)
</span></span><span style=display:flex><span>         -&gt; 제어권 반환
</span></span><span style=display:flex><span>[loop]   -&gt; 다른 작업 실행
</span></span><span style=display:flex><span>         -&gt; 작업 완료 이벤트
</span></span><span style=display:flex><span>         -&gt; async func resume
</span></span></code></pre></div><h2 id=3-언어별-내부-구현-비교>3. 언어별 내부 구현 비교<a hidden class=anchor aria-hidden=true href=#3-언어별-내부-구현-비교>#</a></h2><p>차이점은 다음 두 질문에 있습니다.</p><ul><li>기다리는 동안 스레드는 무엇을 하는가?</li><li>재개될 때 어디서 실행되는가?</li></ul><h3 id=31-javascript와-python-싱글-스레드-이벤트-루프>3.1 JavaScript와 Python: 싱글 스레드 이벤트 루프<a hidden class=anchor aria-hidden=true href=#31-javascript와-python-싱글-스레드-이벤트-루프>#</a></h3><p>모델은 이벤트 루프 기반 협력적 멀티태스킹입니다.</p><ul><li><code>await</code>는 작업을 백그라운드에 위임하고, 메인 루프는 즉시 다른 작업을 수행한다.</li><li>완료된 작업은 큐에 쌓이고, 루프가 비었을 때 재개된다.</li><li>재개 위치는 이벤트 루프가 도는 동일 스레드다.</li></ul><p>주의점은 간단합니다. 동기 함수가 오래 걸리면 루프 전체가 막힙니다. Python에서 <code>time.sleep()</code>을 <code>asyncio</code> 안에서 호출하면 모든 코루틴이 멈춘 것처럼 보입니다.</p><h3 id=32-c-net-상태-머신--스레드-풀>3.2 C# (.NET): 상태 머신 + 스레드 풀<a hidden class=anchor aria-hidden=true href=#32-c-net-상태-머신--스레드-풀>#</a></h3><p>C#은 컴파일러가 async 메서드를 상태 머신으로 변환합니다.</p><ul><li><code>await</code> 지점에서 스레드는 풀로 반환된다.</li><li>작업이 끝나면 컨텍스트에 따라 원래 스레드나 다른 풀 스레드에서 재개된다.</li><li><code>SynchronizationContext</code>가 있으면 원래 컨텍스트로 돌아가고, 없으면 풀 스레드에서 이어진다.</li></ul><p><code>Wait()</code>는 스레드를 점유한 채로 멈추지만, <code>await</code>는 스레드를 놓아줍니다. 이 차이가 처리량과 확장성에서 큰 차이를 만듭니다.</p><h3 id=33-c20-코루틴-상태-머신--실행자executor-의존>3.3 C++20 코루틴: 상태 머신 + 실행자(Executor) 의존<a hidden class=anchor aria-hidden=true href=#33-c20-코루틴-상태-머신--실행자executor-의존>#</a></h3><p>C++20 코루틴도 컴파일러가 상태 머신으로 변환한다는 점은 동일합니다. 하지만 재개가 어디서, 어떤 스레드에서 일어나는지는 표준이 정하지 않습니다.</p><ul><li><code>co_await</code>는 현재 코루틴의 상태를 저장하고 호출자(또는 프레임워크)로 제어권을 넘긴다.</li><li>재개는 사용하는 라이브러리/프레임워크의 실행자(Executor) 정책에 따라 결정된다.</li><li>기본적으로 “스레드 풀에서 이어진다”가 아니라, 어떤 스레드로 돌아갈지는 구현에 달려 있다.</li></ul><p>즉, C#은 런타임과 스레드 풀의 결합이 명확한 반면, C++은 코루틴 자체는 저수준 도구이고 스케줄링 정책은 라이브러리가 맡습니다.</p><h3 id=34-언어별-비동기-흐름의-공통점과-분기점>3.4 언어별 비동기 흐름의 공통점과 분기점<a hidden class=anchor aria-hidden=true href=#34-언어별-비동기-흐름의-공통점과-분기점>#</a></h3><p>비동기 문법은 서로 닮았지만, “누가 스케줄링을 책임지느냐”가 핵심 분기입니다.</p><ul><li>JS/Python: 이벤트 루프가 단일 스레드에서 태스크를 순차적으로 재개한다.</li><li>C#: 런타임이 스레드 풀과 컨텍스트를 관리하며 재개 지점을 결정한다.</li><li>C++: 코루틴은 상태 머신만 제공하고, 실행자/프레임워크가 재개 정책을 정한다.</li></ul><h2 id=4-wait-vs-await-가독성-이상의-의미>4. Wait vs Await: 가독성 이상의 의미<a hidden class=anchor aria-hidden=true href=#4-wait-vs-await-가독성-이상의-의미>#</a></h2><p>async/await는 단순히 콜백 지옥을 피하는 문법이 아닙니다. 리소스 관리 그 자체입니다.</p><table><thead><tr><th>구분</th><th>Blocking (Wait, Sleep)</th><th>Non-Blocking (await)</th></tr></thead><tbody><tr><td>스레드 상태</td><td>대기 중이며 점유</td><td>해방되어 다른 작업 가능</td></tr><tr><td>처리량</td><td>스레드 수에 제한</td><td>적은 스레드로 높은 처리량</td></tr><tr><td>적합한 작업</td><td>CPU Bound</td><td>I/O Bound</td></tr></tbody></table><h2 id=5-비동기-문법의-유사성과-차이-await와-스레드>5. 비동기 문법의 유사성과 차이: “await”와 “스레드”<a hidden class=anchor aria-hidden=true href=#5-비동기-문법의-유사성과-차이-await와-스레드>#</a></h2><p>많은 언어가 <code>async</code>/<code>await</code> 형태를 공유하지만, 실제로는 “스레드 비동기”와 “이벤트 루프 비동기”가 섞여 있습니다.</p><h3 id=51-문법적-유사성>5.1 문법적 유사성<a hidden class=anchor aria-hidden=true href=#51-문법적-유사성>#</a></h3><ul><li>공통점: <code>async</code> 함수는 즉시 반환하고, <code>await</code>는 결과가 준비될 때까지 논리적 대기 상태로 들어간다.</li><li>결과: 코드 흐름은 동기처럼 보이지만, 실행은 분할되어 스케줄러가 재개한다.</li></ul><h3 id=52-기능적-차이점-await가-스레드를-의미하지는-않는다>5.2 기능적 차이점: await가 “스레드”를 의미하지는 않는다<a hidden class=anchor aria-hidden=true href=#52-기능적-차이점-await가-스레드를-의미하지는-않는다>#</a></h3><ul><li>JS/Python: <code>await</code>는 스레드를 만들지 않는다. 이벤트 루프에 제어권을 돌려준다.</li><li>C#: <code>await</code>는 스레드를 생성하지 않지만, 재개는 스레드 풀에서 일어날 수 있다.</li><li>C++: <code>co_await</code>는 스레드를 만들지 않는다. 어떤 스레드에서 재개되는지는 실행자에 달렸다.</li></ul><p>결론적으로 <code>await</code>는 “스레드 생성/병렬 실행”과 별개이며, “재개 시점과 위치를 스케줄러에 맡기는 문법”에 가깝습니다.</p><h2 id=6-비동기-흐름-비교-요약>6. 비동기 흐름 비교 요약<a hidden class=anchor aria-hidden=true href=#6-비동기-흐름-비교-요약>#</a></h2><table><thead><tr><th>언어</th><th>스케줄링 주체</th><th>기본 재개 스레드</th><th>비고</th></tr></thead><tbody><tr><td>JavaScript</td><td>이벤트 루프</td><td>메인 스레드</td><td>단일 스레드 협력적 멀티태스킹</td></tr><tr><td>Python</td><td>이벤트 루프</td><td>루프 스레드</td><td>동기 함수 혼용 시 전체 블로킹</td></tr><tr><td>C#</td><td>런타임 + 스레드 풀</td><td>컨텍스트/풀 스레드</td><td><code>SynchronizationContext</code> 영향</td></tr><tr><td>C++20</td><td>실행자/프레임워크</td><td>구현 의존</td><td>표준은 스케줄링 정책 미정</td></tr></tbody></table><h2 id=7-짧은-코드-비교>7. 짧은 코드 비교<a hidden class=anchor aria-hidden=true href=#7-짧은-코드-비교>#</a></h2><h3 id=javascript-블로킹-vs-비블로킹>JavaScript: 블로킹 vs 비블로킹<a hidden class=anchor aria-hidden=true href=#javascript-블로킹-vs-비블로킹>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#6272a4>// 블로킹 예시: 긴 CPU 작업
</span></span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>function</span> heavy() {
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>const</span> end <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>Date</span>.now() <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>2000</span>;
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>while</span> (<span style=color:#8be9fd;font-style:italic>Date</span>.now() <span style=color:#ff79c6>&lt;</span> end) {}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>console.log(<span style=color:#f1fa8c>&#39;A&#39;</span>);
</span></span><span style=display:flex><span>heavy();
</span></span><span style=display:flex><span>console.log(<span style=color:#f1fa8c>&#39;B&#39;</span>);
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#6272a4>// 비블로킹 예시: I/O 대기
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>async</span> <span style=color:#8be9fd;font-style:italic>function</span> run() {
</span></span><span style=display:flex><span>  console.log(<span style=color:#f1fa8c>&#39;A&#39;</span>);
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>await</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd;font-style:italic>Promise</span>(r =&gt; setTimeout(r, <span style=color:#bd93f9>2000</span>));
</span></span><span style=display:flex><span>  console.log(<span style=color:#f1fa8c>&#39;B&#39;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>run();
</span></span></code></pre></div><h3 id=python-asyncio에서의-차이>Python: asyncio에서의 차이<a hidden class=anchor aria-hidden=true href=#python-asyncio에서의-차이>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#ff79c6>import</span> asyncio
</span></span><span style=display:flex><span><span style=color:#ff79c6>import</span> time
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>async</span> <span style=color:#ff79c6>def</span> <span style=color:#50fa7b>bad</span>():
</span></span><span style=display:flex><span>    time<span style=color:#ff79c6>.</span>sleep(<span style=color:#bd93f9>2</span>)  <span style=color:#6272a4># 이벤트 루프 전체가 막힘</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>async</span> <span style=color:#ff79c6>def</span> <span style=color:#50fa7b>good</span>():
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>await</span> asyncio<span style=color:#ff79c6>.</span>sleep(<span style=color:#bd93f9>2</span>)  <span style=color:#6272a4># 루프에 양보</span>
</span></span></code></pre></div><h3 id=c-wait-vs-await>C#: Wait() vs await<a hidden class=anchor aria-hidden=true href=#c-wait-vs-await>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#6272a4>// 블로킹</span>
</span></span><span style=display:flex><span>Task.Delay(<span style=color:#bd93f9>2000</span>).Wait();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 논블로킹</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>await</span> Task.Delay(<span style=color:#bd93f9>2000</span>);
</span></span></code></pre></div><h2 id=8-핵심-요약>8. 핵심 요약<a hidden class=anchor aria-hidden=true href=#8-핵심-요약>#</a></h2><ul><li>async/await는 동기 코드처럼 보이게 하지만, 실제로는 실행 흐름을 쪼개는 코루틴 메커니즘이다.</li><li>JavaScript와 Python은 이벤트 루프 기반으로 단일 스레드를 효율적으로 돌려쓴다.</li><li>C#은 스레드 풀과 상태 머신으로 스레드를 점유하지 않고 재개한다.</li><li>본질은 &ldquo;기다리는 것"이 아니라 &ldquo;나중에 할 일로 미뤄두고 자원을 반납하는 것"이다.</li></ul><h2 id=블로그-작성-팁>블로그 작성 팁<a hidden class=anchor aria-hidden=true href=#블로그-작성-팁>#</a></h2><ul><li>JS 이벤트 루프 모델과 C# 스레드 풀 모델을 대비하는 그림을 넣으면 이해가 빠르다.</li><li>Sleep과 await의 차이를 보여주는 간단한 벤치마크 예제를 덧붙이면 독자의 체감이 커진다.</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://cdecl.github.io/tags/async/>Async</a></li><li><a href=https://cdecl.github.io/tags/await/>Await</a></li><li><a href=https://cdecl.github.io/tags/coroutine/>Coroutine</a></li><li><a href=https://cdecl.github.io/tags/event-loop/>Event-Loop</a></li><li><a href=https://cdecl.github.io/tags/javascript/>Javascript</a></li><li><a href=https://cdecl.github.io/tags/python/>Python</a></li><li><a href=https://cdecl.github.io/tags/csharp/>Csharp</a></li><li><a href=https://cdecl.github.io/tags/thread-pool/>Thread-Pool</a></li><li><a href=https://cdecl.github.io/tags/concurrency/>Concurrency</a></li></ul></footer><script src=https://giscus.app/client.js data-repo=cdecl/cdecl.github.io data-repo-id="MDEwOlJlcG9zaXRvcnkzNDk1ODUyNjg=" data-category=General data-category-id=DIC_kwDOFNY_dM4C1XMk data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=transparent_dark data-lang=ko crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2026 <a href=https://cdecl.github.io/>cdeclog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>