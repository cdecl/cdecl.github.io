<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Devs | cdeclog</title><meta name=keywords content><meta name=description content="Devs - cdeclog"><meta name=author content="Byung Kyu KIM"><link rel=canonical href=https://cdecl.github.io/dev/><link crossorigin=anonymous href=/assets/css/stylesheet.94cdd6e6bf254a927ddb1a5b8ae2c24a30232449c016f55d87efd0d9bed87c55.css integrity="sha256-lM3W5r8lSpJ92xpbiuLCSjAjJEnAFvVdh+/Q2b7YfFU=" rel="preload stylesheet" as=style><link rel=icon href=https://cdecl.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://cdecl.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://cdecl.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://cdecl.github.io/apple-touch-icon.png><link rel=mask-icon href=https://cdecl.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://cdecl.github.io/dev/index.xml title=rss><link rel=alternate hreflang=en href=https://cdecl.github.io/dev/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-VQQHHYPN7K"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VQQHHYPN7K")}</script><meta property="og:url" content="https://cdecl.github.io/dev/"><meta property="og:site_name" content="cdeclog"><meta property="og:title" content="Devs"><meta property="og:description" content="cdecl's Development Blog - Dev, DevOps, Etc."><meta property="og:locale" content="ko-kr"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Devs"><meta name=twitter:description content="cdecl's Development Blog - Dev, DevOps, Etc."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Devs","item":"https://cdecl.github.io/dev/"}]}</script></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://cdecl.github.io/ accesskey=h title="cdeclog (Alt + H)">cdeclog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://cdecl.github.io/dev/ title=Dev><span class=active>Dev</span></a></li><li><a href=https://cdecl.github.io/devops/ title=DevOps><span>DevOps</span></a></li><li><a href=https://cdecl.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://cdecl.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://cdecl.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>Devs</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Git Worktree: 하나의 저장소, 여러 작업 공간</h2></header><div class=entry-content><p>Git Worktree란 무엇이며 왜 필요한가? Stash와의 차이점부터 주요 명령어까지, 효율적인 브랜치 관리
개요 개발을 하다 보면 현재 작업 중인 브랜치에서 아직 커밋하지 못한 변경 사항이 있는데, 긴급하게 다른 브랜치(예: 배포를 위한 핫픽스)로 전환해야 하는 상황을 자주 마주하게 됩니다. 보통은 git stash를 사용하거나 아직 완료되지 않은 코드를 임시 커밋(WIP)하고 브랜치를 전환하지만, 이러한 방식은 번거롭고 컨텍스트 전환에 비용이 듭니다.
Git Worktree는 이런 문제를 우아하게 해결해주는 Git의 강력한 기능입니다. 이 글에서는 Git Worktree의 개념과 필요성, 그리고 git stash와의 차이점과 사용법에 대해 알아봅니다.
...</p></div><footer class=entry-footer><span title='2026-01-07 00:00:00 +0900 KST'>January 7, 2026</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to Git Worktree: 하나의 저장소, 여러 작업 공간" href=https://cdecl.github.io/dev/git-worktree-guide/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>사례로 보는 Git 트러블 슈팅</h2></header><div class=entry-content><p>Git은 강력하지만, 복잡한 상황에서는 개발자를 당황하게 만드는 경우가 많습니다. “앗, 방금 뭘 한 거지?” 싶은 순간은 누구에게나 찾아옵니다. 이 글에서는 checkout, stash, branch 등 핵심 명령어를 중심으로, 실제 현업에서 자주 겪는 20가지 트러블 슈팅 사례와 해결 방안을 구체적으로 정리했습니다.
Part 1: checkout 관련 문제 - “코드가 뒤섞였어요!” checkout은 브랜치를 바꾸거나 특정 버전으로 돌아갈 때 사용하지만, 이 과정에서 많은 실수가 발생합니다.
사례 1: 다른 브랜치로 이동하려는데, 작업하던 내용이 있어서 막힐 때 문제 상황: feature/new-login 브랜치에서 작업하던 중, 급하게 hotfix/bug-report 브랜치로 이동해야 합니다. git checkout hotfix/bug-report를 입력하니 “error: Your local changes to the following files would be overwritten by checkout…” 메시지가 나옵니다. 해결 방안: 아직 커밋하기 애매한 작업 내용을 임시 저장 공간(stash)에 저장합니다. # 현재 작업 내용을 스택에 임시 저장 git stash > `git stash`: 현재 작업 디렉터리의 변경된 파일(Tracked files)을 임시로 스택에 저장합니다. `push`, `pop`, `apply`, `list` 등의 하위 명령어를 통해 관리할 수 있습니다. # 원하는 브랜치로 이동하여 작업 수행 git checkout hotfix/bug-report # ... 핫픽스 작업 ... git commit -m "Fix: Critical bug" git push origin hotfix/bug-report # 원래 브랜치로 복귀 git checkout feature/new-login # 임시 저장했던 작업 내용 다시 적용 git stash pop 사례 2: 실수로 파일을 삭제했는데, 커밋은 아직 안 했을 때 (rm a.txt) 문제 상황: git rm이 아닌 rm 명령어로 파일을 삭제했습니다. git status에 “deleted: a.txt"로 표시됩니다. 해결 방안: checkout을 사용해 현재 브랜치(HEAD)의 마지막 커밋 상태에서 해당 파일을 복원합니다. # a.txt 파일을 마지막 커밋 상태로 복원 git checkout HEAD -- a.txt ```bash > `git checkout &lt;commit> -- &lt;file>`: 특정 커밋 상태의 특정 파일을 현재 작업 디렉터리로 복원합니다. `--`는 브랜치/커밋과 파일 경로를 명확하게 구분하는 역할을 합니다. # -- 를 사용하면 브랜치 이름과 파일 이름을 명확히 구분할 수 있어 안전합니다. 사례 3: 브랜치를 옮기지 않고 다른 브랜치의 파일 내용만 보고 싶을 때 문제 상황: 현재 브랜치는 feature인데, main 브랜치의 config.yml 파일 내용과 비교하고 싶습니다. 브랜치를 통째로 옮기기엔 부담스럽습니다. 해결 방안: git show 또는 git checkout을 특정 파일에 대해서만 실행합니다. # 1. git show 사용 (단순 조회) git show main:path/to/config.yml > `git show &lt;branch>:&lt;path/to/file>`: 브랜치를 변경하지 않고, 다른 브랜치에 있는 파일의 내용을 터미널에 출력합니다. # 2. git checkout 사용 (현재 작업 디렉터리로 가져오기) git checkout main -- path/to/config.yml # 위 명령은 `main` 브랜치의 `config.yml`을 현재 디렉터리로 가져와 덮어씁니다. # 주의: 현재 작업 디렉터리의 내용이 변경됩니다. 사례 4: “Detached HEAD” 상태가 되었을 때 문제 상황: git checkout &lt;commit-hash> 나 git checkout origin/main 처럼 브랜치가 아닌 포인터를 직접 체크아웃하면 “You are in ‘detached HEAD’ state.” 라는 메시지가 나옵니다. 이 상태에서 작업하고 커밋하면 해당 커밋은 어떤 브랜치에도 속하지 않게 되어 나중에 잃어버릴 수 있습니다. 해결 방안: 현재 “Detached HEAD” 상태에서 새로운 브랜치를 만들어 작업을 이어갑니다. # 현재 위치에서 'temp-work' 라는 새 브랜치를 생성 git checkout -b temp-work > `git checkout -b &lt;new-branch>`: 현재 위치(커밋)에서 새로운 브랜치를 생성하고, 즉시 해당 브랜치로 전환합니다. # 이제 'temp-work' 브랜치에서 안전하게 커밋을 이어갈 수 있습니다. git add . git commit -m "Add new feature from detached state" 사례 5: 과거의 특정 파일 버전 하나만 현재 브랜치로 가져오고 싶을 때 문제 상황: config.js 파일의 과거 버전이 필요합니다. 3개의 커밋 전(HEAD~3) 버전의 config.js만 현재 작업 내용에 덮어쓰고 싶습니다. 해결 방안: git checkout에 커밋 해시와 파일 경로를 지정합니다. # 3개 커밋 전 버전의 'config.js'를 현재 디렉터리로 가져옴 git checkout HEAD~3 -- src/config.js git checkout &lt;commit> -- &lt;file>: 특정 커밋에 해당하는 파일의 버전으로 현재 작업 디렉터리의 파일을 덮어씁니다.
...</p></div><footer class=entry-footer><span title='2025-12-30 00:00:00 +0900 KST'>December 30, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to 사례로 보는 Git 트러블 슈팅" href=https://cdecl.github.io/dev/git-troubleshooting-examples/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Github에서 사용되는 주요 라이선스 종류 및 허용, 제약 사항</h2></header><div class=entry-content><p>오픈 소스 프로젝트를 시작하거나 기여할 때 가장 먼저 고려해야 할 것 중 하나는 **라이선스(License)**입니다. Github에는 수많은 프로젝트가 존재하며, 각 프로젝트는 코드 사용에 대한 권리와 의무를 규정하는 라이선스를 가지고 있습니다.
라이선스를 제대로 이해하지 못하고 코드를 사용하면 법적 분쟁에 휘말릴 수 있습니다. 이 글에서는 Github에서 가장 널리 사용되는 주요 오픈 소스 라이선스들의 특징과 허용 범위, 제약 사항을 정리해 봅니다.
1. MIT 라이선스 (MIT License) MIT 라이선스는 가장 단순하고 제한이 적은 라이선스 중 하나로, Github에서 가장 많이 사용되는 라이선스입니다.
...</p></div><footer class=entry-footer><span title='2025-12-11 00:00:00 +0900 KST'>December 11, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to Github에서 사용되는 주요 라이선스 종류 및 허용, 제약 사항" href=https://cdecl.github.io/dev/github-open-source-licenses/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>웹 개발 필수 개념: SOP, CORS, CORP의 관계 정리</h2></header><div class=entry-content><p>현대 웹 환경에서는 Cross-Origin 리소스 접근을 관리하기 위한 복잡한 보안 메커니즘이 존재합니다. 그 중심에는 SOP, CORS, CORP 세 가지 정책이 있습니다.
특히 CDN(Content Delivery Network)을 사용하는 경우, 이 정책들을 정확히 이해하지 못하면 예측하지 못한 로드 오류(CORS/CORP 에러)에 직면하게 됩니다.
1. 웹 보안의 근간: 출처(Origin)와 SOP 웹 보안의 모든 논의는 **출처(Origin)**의 개념에서 시작됩니다.
1-1. 출처(Origin)의 정의 두 URL이 동일한 출처가 되기 위해서는 다음 세 가지 요소가 모두 일치해야 합니다.
프로토콜 (Scheme): http 또는 https 호스트 (Host): 도메인 이름 (예: example.com) 포트 (Port): 포트 번호 (생략 시 기본값 80 또는 443) 1-2. 동일 출처 정책 (SOP: Same-Origin Policy) SOP는 웹 브라우저의 가장 기본적인 보안 정책입니다.
...</p></div><footer class=entry-footer><span title='2025-12-08 00:00:00 +0900 KST'>December 8, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to 웹 개발 필수 개념: SOP, CORS, CORP의 관계 정리" href=https://cdecl.github.io/dev/sop-cors-corp/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>락프리(Lock-Free) 알고리즘 이해하기</h2></header><div class=entry-content><p>멀티스레드 프로그래밍 환경에서 동시성 제어는 성능과 직결되는 매우 중요한 문제입니다. 이번 글에서는 전통적인 락 기반 동시성 제어의 한계를 극복하기 위해 등장한 락프리(Lock-Free) 알고리즘에 대해 알아보고, 그 개념과 구현 방법, 그리고 장단점을 살펴보겠습니다.
락프리 알고리즘이란? **락프리(Lock-Free)**는 이름 그대로 “자물쇠(Lock) 없이” 여러 스레드가 동시에 데이터를 처리하는 기술입니다.
쉽게 비유하자면 회전문과 같습니다.
락(Lock): 한 번에 한 명만 들어갈 수 있는 화장실입니다. 누군가 안에 있으면 밖에서 열쇠를 받을 때까지 마냥 기다려야 합니다. 락프리(Lock-Free): 여러 사람이 동시에 지나갈 수 있는 회전문입니다. 가끔 문이 꽉 차서 한 바퀴 더 돌아야 할 수도 있지만, 멈추지 않고 계속 움직일 수 있습니다. 락프리는 시스템 전체가 멈추는 일(Deadlock) 없이, 누군가는 반드시 작업을 완료한다는 것을 보장합니다.
...</p></div><footer class=entry-footer><span title='2025-12-07 00:00:00 +0900 KST'>December 7, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to 락프리(Lock-Free) 알고리즘 이해하기" href=https://cdecl.github.io/dev/lock-free-algorithm/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Linux vs Windows 쓰레딩 모델 비교</h2></header><div class=entry-content><p>쓰레드는 운영체제가 프로세스 내에서 작업을 병렬로 실행하기 위해 사용하는 기본 실행 단위입니다. 리눅스와 윈도우는 이 쓰레드를 관리하고 스케줄링하는 방식에서 서로 다른 모델을 채택하고 있으며, 이러한 차이는 시스템 성능과 프로그래밍 방식에 영향을 미칩니다.
🐧 리눅스 쓰레딩 모델: N:1 및 1:1 혼합 (NPTL) 리눅스는 역사적으로 다양한 쓰레딩 모델을 거쳐왔으나, 현재는 **NPTL(Native POSIX Thread Library)**이라는 1:1 모델과 N:1 모델의 장점을 결합한 형태가 주류입니다.
1. 핵심 개념: 경량 프로세스 (LWP, LightWeight Process) 리눅스 커널의 관점: 리눅스 커널은 프로세스와 쓰레드를 구분하지 않고, 모두 태스크(Task) 또는 **경량 프로세스(LWP)**로 취급하고 스케줄링합니다. 쓰레드의 생성: POSIX 쓰레드(pthreads) 라이브러리를 통해 쓰레드를 생성하면, 커널에 새로운 LWP가 생성됩니다. 이 LWP들은 부모 프로세스의 주소 공간, 파일 디스크립터 등을 공유하며, 각자의 실행 문맥(Context)을 가집니다. 2. 모델 유형: 1:1 모델 특징: 사용자 공간의 **각 쓰레드(N)**가 커널 공간의 각각의 스케줄링 가능한 엔티티(1), 즉 LWP에 직접적으로 대응됩니다. 장점: 진정한 병렬성: 멀티 코어 환경에서 여러 쓰레드가 동시에 병렬로 실행될 수 있습니다. 커널 지원: 특정 쓰레드가 I/O 작업 등으로 블록(Block) 상태가 되더라도, 커널은 해당 프로세스의 다른 쓰레드들을 계속 스케줄링할 수 있습니다. 단점: 쓰레드 생성 및 컨텍스트 전환 시 커널 오버헤드가 발생합니다. 요약: 리눅스는 POSIX 표준을 따르며, 사용자 레벨의 쓰레드가 커널 레벨의 프로세스와 유사한 경량 프로세스로 매핑되는 1:1 모델에 가깝습니다.
...</p></div><footer class=entry-footer><span title='2025-11-22 00:00:00 +0900 KST'>November 22, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to Linux vs Windows 쓰레딩 모델 비교" href=https://cdecl.github.io/dev/linux-vs-windows-threading/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Python 유용한 생산성 라이브러리</h2></header><div class=entry-content><p>파이썬으로 개발할 때 생산성을 크게 향상시켜주는 유용한 라이브러리들을 소개합니다.
tqdm 간략 설명 tqdm은 “taqaddum"의 약자로, 아랍어로 “진행"을 의미합니다. 긴 작업의 진행 상황을 시각적으로 보여주는 스마트한 프로그레스 바를 쉽게 추가할 수 있게 해주는 라이브러리입니다.
사용 잇점 작업의 진행률을 시각적으로 확인할 수 있어 대기 시간을 예측하고 지루함을 덜 수 있습니다. 반복문(loop)에 간단하게 적용할 수 있어 코드 수정이 거의 필요 없습니다. 처리 속도, 남은 시간 등 유용한 정보를 함께 표시해줍니다. 설치 pip install tqdm 간략 예제 코드 import time from tqdm import tqdm for i in tqdm(range(100), desc="Processing"): time.sleep(0.05) 실행 결과 Processing: 100%|██████████| 100/100 [00:05&lt;00:00, 19.99it/s] 추가 예제: 리스트와 함께 사용 tqdm은 리스트 컴프리헨션이나 제너레이터 표현식과도 잘 동작합니다.
...</p></div><footer class=entry-footer><span title='2025-11-17 00:00:00 +0900 KST'>November 17, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to Python 유용한 생산성 라이브러리" href=https://cdecl.github.io/dev/python-productivity-libraries/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Python uv 프로젝트 구조</h2></header><div class=entry-content><p>uv를 활용한 현대적인 Python 프로젝트 구조, src 레이아웃과 Flat 레이아웃의 차이점, 그리고 uvx를 통한 원격 도구 실행 방법을 알아봅니다.
Python 프로젝트 구조의 중요성 잘 구성된 프로젝트 디렉토리 구조는 코드의 유지보수성, 확장성, 그리고 협업 효율성을 크게 향상시킵니다. Python에서는 전통적으로 두 가지 주요 레이아웃이 사용됩니다: Flat 레이아웃과 src 레이아웃. 현대적인 Python 프로젝트에서는 src 레이아웃이 많은 이점을 제공하여 표준으로 자리 잡고 있습니다.
일반적인 Python 프로젝트 디렉토리 구조 현대적인 Python 프로젝트는 일반적으로 다음과 같은 구조를 가집니다.
...</p></div><footer class=entry-footer><span title='2025-07-20 00:00:00 +0900 KST'>July 20, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to Python uv 프로젝트 구조" href=https://cdecl.github.io/dev/python-uv-project-structure/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>MCP-SuperAssistant 사용법</h2></header><div class=entry-content><p>Model Context Pro **Model Context Pro
MCP-SuperAssistant란? MCP-SuperAssistant는 MCP를 활용해 AI 플랫폼(ChatGPT, Perplexity, Google Gemini, Grok 등)과 외부 데이터 및 도구를 연결하는 크롬 확장 프로그램입니다. 이 도구는 AI 대화 내에서 MCP 도구 호출을 감지하고, 실행 결과를 자동 또는 수동으로 대화에 삽입하여 워크플로우를 간소화합니다. MCP-SuperAssistant는 다양한 AI 플랫폼과의 호환성과 유연한 설정을 통해 개발자와 비즈니스 사용자의 생산성을 극대화합니다.
MCP-SuperAssistant의 주요 기능 MCP-SuperAssistant는 다음과 같은 기능을 제공합니다:
다양한 AI 플랫폼 지원: ChatGPT, Perplexity, Google Gemini, Grok, Google AI Studio, OpenRouter, DeepSeek 등에서 MCP 도구 실행 가능 MCP 도구 실행 및 결과 삽입: AI 대화 내 도구 호출을 감지해 실행하고 결과를 대화에 삽입 실시간 데이터 연결: MCP를 통해 콘텐츠 저장소, 비즈니스 앱, 개발 환경 등과 안전하게 연결 자동/수동 모드: 자동 모드(도구 실행 및 결과 제출 자동화)와 수동 모드(사용자 제어) 지원 확장성과 모듈성: 플러그인 기반 아키텍처로 새로운 플랫폼 및 도구 추가 가능, WebSocket 및 SSE 지원 보안 및 접근성: 복잡한 API 키 설정 없이 기존 AI 구독 활용, 최소 설정으로 사용 가능 6000+ MCP 서버 지원: 다양한 MCP 서버와 통합해 AI 워크플로우 강화 특징: 확장 프로그램은 간단한 설치로 즉시 사용 가능하며, 샌드박스 환경에서 실행되어 보안성을 유지합니다. 제약사항: 일부 복잡한 도구 호출은 MCP 서버 설정이 필요하며, AI 모델의 프롬프트 이해도에 따라 결과 정확도가 달라질 수 있습니다. 초기 설치 및 세팅, 실행 준비 MCP-SuperAssistant를 사용하려면 크롬 확장 프로그램 설치와 MCP 프록시 서버 설정이 필요합니다. 아래는 단계별 설치 및 실행 준비 과정입니다.
...</p></div><footer class=entry-footer><span title='2025-06-24 00:00:00 +0900 KST'>June 24, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to MCP-SuperAssistant 사용법" href=https://cdecl.github.io/dev/superassistant/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Gemini CLI의 MCP(Model Context Pro</h2></header><div class=entry-content><p>Gemini CLI의 MCP(Model Context Pro
Model Context Pro **Model Context Pro
Gemini CLI와 MCP 지원 개요 Gemini CLI는 Google의 생성형 AI 모델인 Gemini를 터미널에서 활용할 수 있는 오픈소스 도구로, MCP를 통해 내장 및 외부 도구와의 통합을 지원합니다. MCP를 활용하면 Gemini CLI는 파일 시스템 작업, 웹 검색, 버전 관리 시스템(Git 등)과의 연동, 또는 사용자 정의 API와의 상호작용과 같은 다양한 기능을 수행할 수 있습니다. Gemini CLI는 MCP를 통해 모델의 컨텍스트를 확장하여 복잡한 작업을 처리하거나, 외부 시스템과의 실시간 데이터 교환을 가능하게 합니다.
...</p></div><footer class=entry-footer><span title='2025-06-23 00:00:00 +0900 KST'>June 23, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to Gemini CLI의 MCP(Model Context Pro" href=https://cdecl.github.io/dev/gemini-cli-mcp-101/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://cdecl.github.io/dev/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2026 <a href=https://cdecl.github.io/>cdeclog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>