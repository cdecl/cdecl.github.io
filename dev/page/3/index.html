<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Devs | cdeclog</title><meta name=keywords content><meta name=description content="Devs - cdeclog"><meta name=author content="Byung Kyu KIM"><link rel=canonical href=https://cdecl.github.io/dev/><link crossorigin=anonymous href=/assets/css/stylesheet.d980bb9fb2cba61af0aead0606b5eb221d7e358748ac394b60233d95d626c563.css integrity="sha256-2YC7n7LLphrwrq0GBrXrIh1+NYdIrDlLYCM9ldYmxWM=" rel="preload stylesheet" as=style><link rel=icon href=https://cdecl.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://cdecl.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://cdecl.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://cdecl.github.io/apple-touch-icon.png><link rel=mask-icon href=https://cdecl.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://cdecl.github.io/dev/index.xml title=rss><link rel=alternate hreflang=en href=https://cdecl.github.io/dev/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-VQQHHYPN7K"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VQQHHYPN7K")}</script><meta property="og:url" content="https://cdecl.github.io/dev/"><meta property="og:site_name" content="cdeclog"><meta property="og:title" content="Devs"><meta property="og:description" content="cdecl's Development Blog - Dev, DevOps, Etc."><meta property="og:locale" content="ko-kr"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Devs"><meta name=twitter:description content="cdecl's Development Blog - Dev, DevOps, Etc."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Devs","item":"https://cdecl.github.io/dev/"}]}</script></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://cdecl.github.io/ accesskey=h title="cdeclog (Alt + H)">cdeclog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://cdecl.github.io/dev/ title=Dev><span class=active>Dev</span></a></li><li><a href=https://cdecl.github.io/devops/ title=DevOps><span>DevOps</span></a></li><li><a href=https://cdecl.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://cdecl.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://cdecl.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>Devs</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Playwright 101</h2></header><div class=entry-content><p>Playwright 가이드: 웹 자동화
1. Playwright란? Playwright는 웹 브라우저 자동화를 위한 도구로, Selenium의 대안으로 설계되었습니다. 주요 용도는 다음과 같습니다:
웹 애플리케이션 테스트 자동화 웹 스크래핑 및 데이터 추출 반복적인 웹 작업 자동화 크로스 브라우저 테스팅 주요 기능 브라우저 제어: Chromium, Firefox, Webkit(Safari 엔진) 지원 DOM 조작: querySelector와 locator로 요소 검색 및 조작 폼 자동화: 입력 및 제출 자동화 스크린샷 캡처: 페이지 또는 요소 캡처 헤드리스 모드: GUI 없는 실행 Playwright는 Selenium보다 최신 기술을 활용하며, 자동 대기와 간결한 API를 제공합니다.
...</p></div><footer class=entry-footer><span title='2025-03-01 00:00:00 +0900 KST'>March 1, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to Playwright 101" href=https://cdecl.github.io/dev/playwright-101/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>모던 CMake 기본 가이드</h2></header><div class=entry-content><p>모던 CMake 기본 가이드: 타겟 중심의 현대적인 빌드 시스템
1. Makefile 대비 CMake의 장점 크로스 플랫폼 지원 Makefile은 Unix 계열 시스템에 특화되어 있지만, CMake는 Windows, Linux, macOS 등 다양한 플랫폼 지원 Visual Studio, Ninja, Unix Makefiles 등 다양한 빌드 시스템 생성 가능 타겟 중심의 의존성 관리 명확한 의존성 전파 (PUBLIC, PRIVATE, INTERFACE) 자동 헤더 의존성 추적 현대적인 패키지 관리 (find_package) 향상된 IDE 지원 Visual Studio, CLion 등과 완벽한 통합 자동 완성 및 인텔리센스 지원 CMake 프리셋 지원 2. 모던 CMake의 특징 기존 CMake와의 주요 차이점 타겟 중심 접근: 전역 변수 대신 특정 타겟에 한정하여 빌드 옵션을 지정합니다. 개선된 의존성 관리: 빌드 의존성 문제를 해결하고 불필요한 참조를 줄입니다. 새로운 명령어 도입: target_link_libraries, target_include_directories 등의 새로운 명령어를 사용합니다. PUBLIC, PRIVATE 키워드를 통한 세밀한 의존 관계 설정 CMake 3.0.0부터 모던 CMake의 기본 기능 지원 CMake 3.12+ 버전부터 “More Modern CMake” 기능 제공 CMake 3.15+ 버전 사용 권장 타겟 중심 접근 # 안티패턴 (사용하지 말 것) include_directories(include) add_definitions(-DSOME_DEFINE) link_directories(lib) # 모던 패턴 (권장) add_executable(myapp src/main.cpp) target_include_directories(myapp PUBLIC ${CMAKE_CURRENT_SOURCE_DIR}/include ) target_compile_definitions(myapp PRIVATE SOME_DEFINE ) target_link_directories(myapp PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/lib ) 범위와 전파 # 라이브러리 설정 add_library(mylib SHARED src/lib.cpp include/lib.h ) target_include_directories(mylib PUBLIC ${CMAKE_CURRENT_SOURCE_DIR}/include # 헤더는 공개 PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/src # 구현은 비공개 ) # 실행 파일에서 라이브러리 사용 add_executable(myapp src/main.cpp) target_link_libraries(myapp PRIVATE mylib) # 자동으로 include 경로 전파 범위(Scope)와 전파(Propagation)의 개념 CMake에서 범위는 특정 설정(컴파일 옵션, include 디렉토리 등)이 어디에 적용될지를 나타냅니다. 전파는 이러한 설정이 다른 타겟(target)으로 전달되는 방식을 정의합니다.
...</p></div><footer class=entry-footer><span title='2024-11-15 00:00:00 +0900 KST'>November 15, 2024</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to 모던 CMake 기본 가이드" href=https://cdecl.github.io/dev/modern-cmake-guide/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>프롬프트 엔지니어링 기본 가이드</h2></header><div class=entry-content><p>프롬프트 엔지니어링 가이드: 기초 개념부터 고급 테크닉까지 요약
프롬프트 엔지니어링은 AI 모델에게 원하는 답변을 얻기 위해 입력을 최적화하는 기술입니다. 이 기술은 특히 대화형 AI나 데이터 생성, 모델 학습에서 중요한 역할을 하며, AI 활용의 효율성과 정확성을 크게 높일 수 있습니다.
1. 프롬프트 엔지니어링의 개념과 중요성 정의: AI 모델의 성능을 극대화하기 위해 명확하고 체계적으로 구성된 질문이나 지시문(프롬프트)을 설계하는 기술입니다. 중요성 정확성 향상: 원하는 정보를 정확하게 얻을 수 있습니다. 효율성: 반복 작업을 줄이고, 응답 속도와 질을 높입니다. 일관성: 일정한 포맷과 내용의 응답을 보장할 수 있습니다. 비용 절감: 불필요한 재작업을 줄이고, AI API 호출 효율을 최적화합니다. 창의성 촉진: AI의 창의적 잠재력을 활용해 혁신적인 해결책을 이끌어냅니다. 2. 핵심 원칙과 테크닉 명확한 지시사항 작성 원하는 출력 형식과 구조를 구체적으로 명시합니다.
...</p></div><footer class=entry-footer><span title='2024-10-29 00:00:00 +0900 KST'>October 29, 2024</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to 프롬프트 엔지니어링 기본 가이드" href=https://cdecl.github.io/dev/ai-prompt-engineering/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Python PEP 8 스타일 가이드</h2></header><div class=entry-content><p>Python PEP 8 스타일 가이드
1. PEP 8이란? PEP 8(Python Enhancement Proposal 8)은 Python 코드의 가독성과 일관성을 향상시키기 위한 스타일 가이드입니다. Python의 창시자인 Guido van Rossum이 작성했으며, Python 커뮤니티에서 널리 채택된 코딩 표준입니다.
1.1 PEP 8의 목적 코드의 가독성 향상 일관된 코딩 스타일 유지 협업 효율성 증대 코드 유지보수 용이성 향상 2. PEP 8 주요 규약 2.1 코드 레이아웃 들여쓰기 4칸 공백 사용 # 올바른 들여쓰기 (4칸 공백 사용) def long_function_name( var_one, var_two, var_three, var_four): print(var_one) # 잘못된 들여쓰기 def long_function_name( var_one, var_two, # 들여쓰기가 부족함 var_three, var_four): print(var_one) 최대 줄 길이 한 줄은 최대 79자 긴 줄은 여러 줄로 나누기 백슬래시() 사용하여 줄 나누기 # 올바른 예시 from mypkg.mymodule import ( function1, function2, function3, function4) long_string = ('This is a very long string that ' 'cannot fit within 79 characters ' 'so we split it into multiple lines.') 2.2 공백 규칙 연산자 주변 공백 # 올바른 예시 x = 1 y = 2 long_variable = 3 # 잘못된 예시 x=1 y = 2 long_variable = 3 쉼표 후 공백 # 올바른 예시 def complex_function(x, y, z): pass # 잘못된 예시 def complex_function(x,y,z): pass 2.3 명명 규칙 변수명 : snake case 소문자 사용 단어 사이는 언더스코어(_)로 구분 my_variable = 1 count_of_users = 10 first_name = "John" 함수명 : snake case 소문자 사용 단어 사이는 언더스코어로 구분 def calculate_average(): pass def get_user_info(): pass 클래스명 : Pascal Case) CapWords(Pascal Case) 컨벤션 사용 class UserAccount: pass class DatabaseConnection: pass 상수 대문자와 언더스코어 사용 MAX_CONNECTIONS = 100 DEFAULT_TIMEOUT = 30 2.4 제어문 스타일 if 문 # 올바른 예시 if x is not None: pass if x == 4: print('x is 4') elif x == 5: print('x is 5') else: print('x is not 4 or 5') # 잘못된 예시 if x!=None: pass for 문 # 올바른 예시 for i in range(5): print(i) # 리스트 컴프리헨션 (한 줄인 경우) squares = [x**2 for x in range(10)] # 리스트 컴프리헨션 (복잡한 경우) squares = [ x**2 for x in range(10) if x % 2 == 0 ] 2.5 주석 작성 규칙 인라인 주석 x = 5 # 이것은 인라인 주석입니다 # 잘못된 예시 x = 5# 공백이 없음 문서화 문자열 (Docstrings) def complex_function(param1, param2): """이 함수는 복잡한 연산을 수행합니다. Args: param1 (int): 첫 번째 매개변수 param2 (str): 두 번째 매개변수 Returns: bool: 연산 성공 여부 """ pass 3. VS Code에서 PEP 8 설정하기 3.1 필수 플러그인 Python Extension Pack Python 언어 지원 기본적인 PEP 8 검사 기능 포함 Pylint 코드 분석 도구 PEP 8 규칙 검사 { "python.linting.pylintEnabled": true, "python.linting.enabled": true } Flake8 PEP 8 스타일 가이드 검사
...</p></div><footer class=entry-footer><span title='2024-10-28 00:00:00 +0900 KST'>October 28, 2024</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to Python PEP 8 스타일 가이드" href=https://cdecl.github.io/dev/python-pep8/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Git 커밋 메시지 수정</h2></header><div class=entry-content><p>Git 커밋 메시지 수정
Git 커밋 메시지 수정 가이드 Git을 사용하다 보면 커밋 메시지를 수정해야 할 경우가 자주 발생합니다.
이 글에서는 가장 기본적인 방법부터 고급 기술까지 모든 커밋 메시지 수정 방법을 다루겠습니다.
기본적인 커밋 메시지 수정 방법 1. 가장 최근 커밋 메시지 수정 가장 최근의 커밋 메시지를 수정하는 것은 매우 간단합니다.
git commit --amend 또는 에디터를 열지 않고 직접 메시지를 입력할 수우도 있습니다:
git commit --amend -m "새로운 커밋 메시지" 2. 커밋 내용과 메시지 함께 수정 파일 변경사항을 포함하여 최근 커밋을 수정할 수 있습니다:
...</p></div><footer class=entry-footer><span title='2024-10-26 00:00:00 +0900 KST'>October 26, 2024</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to Git 커밋 메시지 수정" href=https://cdecl.github.io/dev/git-rebase-commit-message-edit-guide/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Selenium 101</h2></header><div class=entry-content><p>Python Selenium 이용한 웹 스크래핑 방법, 웹 자동화
Selenium 가이드: 웹 자동화 1. Selenium 이란? Selenium은 웹 브라우저 자동화를 위한 아래와 같은 용도
웹 애플리케이션 테스트 자동화 웹 스크래핑 및 데이터 추출 반복적인 웹 작업 자동화 크로스 브라우저 테스팅 주요 기능 브라우저 제어: 다양한 브라우저에서 웹 페이지를 자동으로 로드하고 조작할 수 있습니다. DOM 조작: 웹 페이지의 DOM 요소를 검색하고 조작할 수 있습니다. 폼 자동화: 폼을 자동으로 작성하고 제출할 수 있습니다. 스크린샷 캡처: 웹 페이지의 스크린샷을 캡처할 수 있습니다. 헤드리스 모드: 브라우저 창을 띄우지 않고 백그라운드에서 작업을 수행할 수 있습니다. Selenium은 다양한 프로그래밍 언어를 지원하며, 웹 개발자와 QA 엔지니어들에게 필수적인 도구로 사용
...</p></div><footer class=entry-footer><span title='2024-08-01 00:00:00 +0900 KST'>August 1, 2024</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to Selenium 101" href=https://cdecl.github.io/dev/selenium-101/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>GNU C++로 정적 라이브러리 링크하는 방법</h2></header><div class=entry-content><p>GNU C++ 프로그램에서 정적 라이브러리를 링크하는 방법
정적 라이브러리 사용 사용 시 고려 사항 프로그램 크기 증가: 정적 라이브러리를 사용하면 실행 파일 크기가 크게 증가할 수 있슴 라이브러리 업데이트: 정적 라이브러리를 사용하면 라이브러리 업데이트 시 프로그램을 다시 컴파일해야 필요 사용 장점 운영 체제 의존성 감소: 정적 라이브러리를 사용하면 프로그램 실행에 필요한 모든 라이브러리가 실행 파일에 포함되어 있어 운영 체제에 동일한 라이브러리가 설치되어 있지 않아도 프로그램을 실행 보안 강화: 정적 라이브러리를 사용하면 공유 라이브러리 공격과 같은 보안 취약점에 대한 위험을 줄일 수 있음 성능 향상: 정적 라이브러리를 사용하면 프로그램 실행 속도를 향상시킬 수 있음 정적 라이브러리 링크 링크 옵션 -static C 런타임 라이브러리뿐만 아니라 모든 외부 라이브러리를 정적으로 링크합니다. 실행 파일에 모든 필요한 라이브러리 코드를 포함시킵니다. 결과적으로 실행 파일의 크기가 크게 증가할 수 있습니다. 시스템 라이브러리에 대한 의존성을 제거하여 이식성을 높입니다. -static-libstdc++ C++ 표준 라이브러리만 정적으로 링크합니다. 다른 시스템 라이브러리나 사용자 정의 라이브러리는 여전히 동적으로 링크될 수 있습니다. -static 옵션보다 실행 파일 크기 증가가 덜합니다. C++ ABI 호환성 문제를 해결하는 데 유용할 수 있습니다. g++ -static main.cpp -o myprogram 라이브러리 링크 지정 방법 -l 옵션 (일반적인 방법) 컴파일러에게 특정 라이브러리를 링크하도록 지시. 먼저 동적 라이브러리(.so 파일)를 찾습니다. 동적 라이브러리가 없으면 정적 라이브러리(.a 파일)를 찾습니다. 표준 라이브러리 경로(예: /usr/lib, /lib)와 -L 옵션으로 지정된 추가 경로에서 라이브러리를 찾습니다. 정적 라이브러리를 명시적으로 지정하려면, 전체 파일 경로를 사용할 수 있습니다. 예: g++ main.cpp /path/to/libmylib.a -o myprogram 뒤에 오는 라이브러리 이름은 관례에 따라 lib 접두사와 .a 확장자를 가진 정적 라이브러리 파일명 -static 옵션과 함께 사용 시 -static 옵션과 함께 -l을 사용하면, 링커는 오직 정적 라이브러리만을 찾습니다. 이 경우 정적 라이브러리가 없다면 링크 에러가 발생합니다. -Wl,–whole-archive 옵션 컴파일러에게 라이브러리에 있는 모든 객체 파일을 링크하도록 지시 이 옵션을 사용하면 라이브러리에 있는 모든 함수가 사용될 수 있음 주로 정적 라이브러리(.a)에 사용됩니다. 전역 객체의 생성자나 정적 초기화 함수가 반드시 링크되도록 보장합니다. 주요 차이점 : -l -Wl,–whole-archive -l은 선택적으로 필요한 부분만 링크하지만, –whole-archive는 라이브러리 전체를 링크합니다. -l은 동적/정적 라이브러리 모두에 사용 가능하지만, –whole-archive는 주로 정적 라이브러리에 사용됩니다. –whole-archive를 사용하면 실행 파일 크기가 더 커질 수 있습니다. -Wl,–whole-archive는 플러그인 시스템이나 동적으로 로드되는 모듈을 구현할 때 특히 유용할 수 있습니다 g++ main.cpp -lstdc++ -Wl,--whole-archive my_lib.a -o myprogram 의존성 확인 실행 파일의 의존성을 확인하는 것은 프로그램이 어떤 라이브러리에 의존하고 있는지 파악하는 데 중요합니다. 이를 통해 정적 링킹이 제대로 되었는지, 혹은 동적 라이브러리에 대한 의존성이 있는지 확인할 수 있습니다.
...</p></div><footer class=entry-footer><span title='2024-02-25 00:00:00 +0900 KST'>February 25, 2024</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to GNU C++로 정적 라이브러리 링크하는 방법" href=https://cdecl.github.io/dev/g++-static/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Git Repository 복제, Branch 동기화 관리</h2></header><div class=entry-content><p>Git Repository 복제 및 Branch 관리 가이드 Git Repository 복제 Remote → Local 복제 Git 저장소를 복제하는 방법에는 여러 가지가 있으며, 각각의 방식에 따라 다른 특징이 있습니다.
--mirror 복제의 특징 git clone --mirror: Remote repository의 모든 참조(refs)를 포함하여 Local에 저장 기본 clone과 달리 작업 디렉토리 없이 저장소의 메타데이터 전체를 복제 주로 저장소 백업이나 완전한 미러링에 사용 # mirror 복제 $ git clone --mirror https://github.com/cdecl/test $ tree -d . └── test.git ├── branches ├── hooks ├── info ├── objects │ ├── info │ └── pack └── refs ├── heads └── tags 💡 추가 정보:
...</p></div><footer class=entry-footer><span title='2022-02-23 00:00:00 +0900 KST'>February 23, 2022</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to Git Repository 복제, Branch 동기화 관리" href=https://cdecl.github.io/dev/git-mirror-branch/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>C++ Lambda 표현식</h2></header><div class=entry-content><p>C++14, C++17, C++20 버전별 Lambda 표현 정리
The Evolutions of Lambdas in C++14, C++17 and C++20 https://www.fluentcpp.com/2021/12/13/the-evolutions-of-lambdas-in-c14-c17-and-c20/{:target="_blank"} 해당 글을 참고하여 예제 자체 작성 C++14 Default parameters #include &lt;iostream> using namespace std; int main() { auto fn = [](int a, int b = 0) { return a + b; }; cout &lt;&lt; fn(1) &lt;&lt; endl; // 1 cout &lt;&lt; fn(1, 2) &lt;&lt; endl; // 3 } Template parameters #include &lt;iostream> #include &lt;string> #include &lt;vector> using namespace std; int main() { auto fn = [](auto && c) { return c.size(); }; vector&lt;int> v = {1, 2, 3}; cout &lt;&lt; fn(v) &lt;&lt; endl; // 3 string s = "12345"; cout &lt;&lt; fn(s) &lt;&lt; endl; // 5 } Generalised capture #include &lt;iostream> #include &lt;string> using namespace std; int main() { string str = "string"; auto fn = [s = str + "_capture"s](string body) { cout &lt;&lt; s &lt;&lt; " : " &lt;&lt; body &lt;&lt; endl; }; fn("test"); // string_capture : test } Returning a lambda from a function #include &lt;iostream> using namespace std; auto getAdd(int n) { return [n](int an) { return n + an; }; } int main() { auto fn = getAdd(10); cout &lt;&lt; fn(20) &lt;&lt; endl; } C++17 Constexpr #include &lt;iostream> using namespace std; int main() { constexpr auto fn = [](int n){ return n + 10; }; static_assert(fn(10) == 20); // ok static_assert(fn(20) == 20); // error: static assertion failed } Capturing a copy of *this this 참조에 캡쳐가 아닌, *this 복사본 캡쳐 #include &lt;iostream> #include &lt;memory> #include &lt;tuple> using namespace std; class item { public: item(int n = 0) : _value(n) {} auto test() { _value += 1; // copy capture auto fn1 = [*this] { return _value; }; auto fn2 = [self = *this] { return self._value; }; // ref capture auto fn3 = [this] { return _value; }; _value += 1; fn1(); // 11 fn2(); // 11 fn3(); // 12 return make_tuple(fn1, fn2, fn3); } private: int _value; }; int main() { auto it = make_shared&lt;item>(10); auto tp = it->test(); it.reset(); cout &lt;&lt; get&lt;0>(tp)() &lt;&lt; endl; cout &lt;&lt; get&lt;1>(tp)() &lt;&lt; endl; cout &lt;&lt; get&lt;2>(tp)() &lt;&lt; endl; // ref memory error } C++20 Template syntax for lambdas #include &lt;iostream> #include &lt;vector> using namespace std; int main() { auto fn = []&lt;typename T>(vector&lt;T> &amp;v) { return v.size(); }; vector&lt;int> v = {1, 2, 3, 4, 5}; cout &lt;&lt; fn(v) &lt;&lt; endl; } Lambda capture of parameter pack #include &lt;iostream> #include &lt;string> using namespace std; template &lt;typename... Args> auto getAddFunc(Args&&... args){ // by ref [&...args = std::forward&lt;Args>(args)] // by value return [...args = std::forward&lt;Args>(args)] (auto && init) { return init + (args + ...); }; } int main() { auto fn = getAddFunc(1, 2, 3); cout &lt;&lt; fn(10) &lt;&lt; endl; // 16 auto fns = getAddFunc("this "s, "is "s, "sample"s); cout &lt;&lt; fns("note: "s) &lt;&lt; endl; // note: this is sample }</p></div><footer class=entry-footer><span title='2021-12-14 00:00:00 +0900 KST'>December 14, 2021</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to C++ Lambda 표현식" href=https://cdecl.github.io/dev/c++-lambda/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Golang GC</h2></header><div class=entry-content><p>Golang GC (가비지 컬렉터) 주요 내용
Golang GC : GOGC 유효하지 않는 메모리(Dangling Object)를 주기적으로 해제하는 기법 Java의 Parallel GC, G1GC 와 유사하나 구현 방식에서 차이가 있음 Stop-the-World 시간을 최소화하도록 설계됨 Tri-Color Algorithm 사용 동시성을 고려한 효율적인 메모리 관리 알고리즘 CMS (Concurrent Mark and Sweep) 방식 운영 Java 와 같은 Generation GC 기법이나 Compaction은 지원하지 않음 대신 더 효율적인 메모리 할당 전략을 사용 Compaction (압축, 재배치) 가 없음 재배치를 하지 않는 대신 TCMalloc를 통한 메모리 할당 관리 메모리 단편화를 최소화하고 빠른 할당을 지원 멀티쓰레드 최적화 힙 메모리 할당기 - tcmalloc. jemalloc{:target="_blank"} Tri-Color Algorithm 동작 원리 white, black, grey 세 가지 상태를 통한 메모리 관리
...</p></div><footer class=entry-footer><span title='2021-12-01 00:00:00 +0900 KST'>December 1, 2021</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to Golang GC" href=https://cdecl.github.io/dev/golang-gogc/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://cdecl.github.io/dev/page/2/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://cdecl.github.io/dev/page/4/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2026 <a href=https://cdecl.github.io/>cdeclog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>