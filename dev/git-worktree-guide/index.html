<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Git Worktree: 하나의 저장소, 여러 작업 공간 | cdeclog</title><meta name=keywords content="git,worktree,productivity,version-control"><meta name=description content="Git Worktree란 무엇이며 왜 필요한가? Stash와의 차이점부터 주요 명령어까지, 효율적인 브랜치 관리
개요
개발을 하다 보면 현재 작업 중인 브랜치에서 아직 커밋하지 못한 변경 사항이 있는데, 긴급하게 다른 브랜치(예: 배포를 위한 핫픽스)로 전환해야 하는 상황을 자주 마주하게 됩니다. 보통은 git stash를 사용하거나 아직 완료되지 않은 코드를 임시 커밋(WIP)하고 브랜치를 전환하지만, 이러한 방식은 번거롭고 컨텍스트 전환에 비용이 듭니다.
Git Worktree는 이런 문제를 우아하게 해결해주는 Git의 강력한 기능입니다. 이 글에서는 Git Worktree의 개념과 필요성, 그리고 git stash와의 차이점과 사용법에 대해 알아봅니다."><meta name=author content="Byung Kyu KIM"><link rel=canonical href=https://cdecl.github.io/dev/git-worktree-guide/><link crossorigin=anonymous href=/assets/css/stylesheet.f939c4ffefb264e6fe85e04352266f79db6bb1303c8e16ae9b6064c1247b5e32.css integrity="sha256-+TnE/++yZOb+heBDUiZvedtrsTA8jhaum2BkwSR7XjI=" rel="preload stylesheet" as=style><link rel=icon href=https://cdecl.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://cdecl.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://cdecl.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://cdecl.github.io/apple-touch-icon.png><link rel=mask-icon href=https://cdecl.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://cdecl.github.io/dev/git-worktree-guide/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-VQQHHYPN7K"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VQQHHYPN7K")}</script><meta property="og:url" content="https://cdecl.github.io/dev/git-worktree-guide/"><meta property="og:site_name" content="cdeclog"><meta property="og:title" content="Git Worktree: 하나의 저장소, 여러 작업 공간"><meta property="og:description" content="Git Worktree란 무엇이며 왜 필요한가? Stash와의 차이점부터 주요 명령어까지, 효율적인 브랜치 관리
개요 개발을 하다 보면 현재 작업 중인 브랜치에서 아직 커밋하지 못한 변경 사항이 있는데, 긴급하게 다른 브랜치(예: 배포를 위한 핫픽스)로 전환해야 하는 상황을 자주 마주하게 됩니다. 보통은 git stash를 사용하거나 아직 완료되지 않은 코드를 임시 커밋(WIP)하고 브랜치를 전환하지만, 이러한 방식은 번거롭고 컨텍스트 전환에 비용이 듭니다.
Git Worktree는 이런 문제를 우아하게 해결해주는 Git의 강력한 기능입니다. 이 글에서는 Git Worktree의 개념과 필요성, 그리고 git stash와의 차이점과 사용법에 대해 알아봅니다."><meta property="og:locale" content="ko-kr"><meta property="og:type" content="article"><meta property="article:section" content="dev"><meta property="article:published_time" content="2026-01-07T00:00:00+09:00"><meta property="article:modified_time" content="2026-01-07T00:00:00+09:00"><meta property="article:tag" content="Git"><meta property="article:tag" content="Worktree"><meta property="article:tag" content="Productivity"><meta property="article:tag" content="Version-Control"><meta name=twitter:card content="summary"><meta name=twitter:title content="Git Worktree: 하나의 저장소, 여러 작업 공간"><meta name=twitter:description content="Git Worktree란 무엇이며 왜 필요한가? Stash와의 차이점부터 주요 명령어까지, 효율적인 브랜치 관리
개요
개발을 하다 보면 현재 작업 중인 브랜치에서 아직 커밋하지 못한 변경 사항이 있는데, 긴급하게 다른 브랜치(예: 배포를 위한 핫픽스)로 전환해야 하는 상황을 자주 마주하게 됩니다. 보통은 git stash를 사용하거나 아직 완료되지 않은 코드를 임시 커밋(WIP)하고 브랜치를 전환하지만, 이러한 방식은 번거롭고 컨텍스트 전환에 비용이 듭니다.
Git Worktree는 이런 문제를 우아하게 해결해주는 Git의 강력한 기능입니다. 이 글에서는 Git Worktree의 개념과 필요성, 그리고 git stash와의 차이점과 사용법에 대해 알아봅니다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Devs","item":"https://cdecl.github.io/dev/"},{"@type":"ListItem","position":2,"name":"Git Worktree: 하나의 저장소, 여러 작업 공간","item":"https://cdecl.github.io/dev/git-worktree-guide/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Git Worktree: 하나의 저장소, 여러 작업 공간","name":"Git Worktree: 하나의 저장소, 여러 작업 공간","description":"Git Worktree란 무엇이며 왜 필요한가? Stash와의 차이점부터 주요 명령어까지, 효율적인 브랜치 관리\n개요 개발을 하다 보면 현재 작업 중인 브랜치에서 아직 커밋하지 못한 변경 사항이 있는데, 긴급하게 다른 브랜치(예: 배포를 위한 핫픽스)로 전환해야 하는 상황을 자주 마주하게 됩니다. 보통은 git stash를 사용하거나 아직 완료되지 않은 코드를 임시 커밋(WIP)하고 브랜치를 전환하지만, 이러한 방식은 번거롭고 컨텍스트 전환에 비용이 듭니다.\nGit Worktree는 이런 문제를 우아하게 해결해주는 Git의 강력한 기능입니다. 이 글에서는 Git Worktree의 개념과 필요성, 그리고 git stash와의 차이점과 사용법에 대해 알아봅니다.\n","keywords":["git","worktree","productivity","version-control"],"articleBody":"Git Worktree란 무엇이며 왜 필요한가? Stash와의 차이점부터 주요 명령어까지, 효율적인 브랜치 관리\n개요 개발을 하다 보면 현재 작업 중인 브랜치에서 아직 커밋하지 못한 변경 사항이 있는데, 긴급하게 다른 브랜치(예: 배포를 위한 핫픽스)로 전환해야 하는 상황을 자주 마주하게 됩니다. 보통은 git stash를 사용하거나 아직 완료되지 않은 코드를 임시 커밋(WIP)하고 브랜치를 전환하지만, 이러한 방식은 번거롭고 컨텍스트 전환에 비용이 듭니다.\nGit Worktree는 이런 문제를 우아하게 해결해주는 Git의 강력한 기능입니다. 이 글에서는 Git Worktree의 개념과 필요성, 그리고 git stash와의 차이점과 사용법에 대해 알아봅니다.\nGit Worktree란? 기본적으로 Git 저장소(Repository)를 clone하면 하나의 작업 디렉토리(Working Directory)가 생성되고, 이 디렉토리는 한 번에 하나의 브랜치만 체크아웃할 수 있습니다.\nGit Worktree는 하나의 로컬 저장소에 여러 개의 작업 디렉토리를 연결하여, 동시에 여러 브랜치를 체크아웃할 수 있게 해주는 기능입니다. 즉, 물리적으로 분리된 여러 폴더에서 서로 다른 브랜치를 띄워놓고 작업할 수 있습니다.\n핵심 개념 Main Working Tree: git clone 시 생성되는 기본 작업 공간. Linked Working Tree: git worktree add 명령어로 생성된 추가 작업 공간들. 모든 Worktree는 .git 디렉토리(저장소 데이터, 객체 데이터베이스)를 공유합니다. 따라서 디스크 공간을 효율적으로 사용하며, 한 Worktree에서의 커밋은 다른 Worktree에서도 즉시 반영됩니다. 현재 작업 디렉토리의 변경 사항(Untracked 파일 포함)을 건드리지 않고, 완전히 깨끗한 새 브랜치 환경을 즉시 얻을 수 있습니다. 왜 필요한가요? (활용 사례) Worktree가 유용한 대표적인 상황들은 다음과 같습니다.\n브랜치 전환의 번거로움 해소: 현재 기능 개발(feature-A) 중에 긴급한 버그 수정 요청(hotfix)이 들어왔을 때, 하던 작업을 정리할 필요 없이 새로운 Worktree를 만들어 즉시 수정 작업을 시작할 수 있습니다. 독립적인 테스트 및 빌드: 하나의 브랜치에서는 서버를 실행해두고, 다른 브랜치에서는 클라이언트 코드를 수정하거나 테스트 코드를 돌려볼 때 유용합니다. 의존성 패키지(node_modules 등)가 브랜치마다 달라서 충돌이 나는 경우, 폴더가 분리되어 있으므로 서로 영향을 주지 않습니다. IDE 및 빌드 환경 유지: 기존 브랜치에서 IDE 창을 열어두고 서버를 띄워둔 상태 그대로, 새 창에서 다른 작업을 할 수 있습니다. stash를 사용했다면 IDE가 파일을 다시 로딩하거나 빌드 캐시가 깨지는 등의 문제가 발생할 수 있지만, worktree는 독립된 환경을 보장합니다. 특히 Full-stack 개발처럼 프론트엔드와 백엔드를 동시에 수정해야 하거나, 여러 기능/핫픽스를 동시에 다뤄야 할 때 매우 유용합니다. git worktree add ../new-work 명령어로 간단히 시작할 수 있습니다.\nStash vs. Worktree 비슷한 상황에서 사용되는 git stash와 비교해보면 차이점이 명확합니다.\n기능 Git Stash Git Worktree Untracked 파일 -u 옵션 필요, 실수로 누락 시 오류 발생 가능 현재 디렉토리 그대로 유지, 새 작업 공간은 깨끗한 상태 병렬 작업 한번에 하나만 가능 (Push/Pop 반복으로 컨텍스트 손실) 여러 디렉토리에서 동시 작업 가능 (IDE 여러 개 실행 등) 리스크 Stash 목록 관리의 어려움 (무엇을 저장했는지 잊음) 최소화 (공유 .git으로 일관성 유지) 디스크 공간 거의 차지하지 않음 체크아웃된 파일만큼 추가 사용 정리하자면:\n단순하고 짧은 작업 전환에는 stash가 빠르고 간편합니다. 긴 호흡의 병렬 작업, Untracked 파일을 포함한 복잡한 상태 유지, 환경 격리가 필요할 때는 worktree가 압도적으로 유리합니다. 주요 명령어 사용법 1. Worktree 생성 (Add) 새로운 작업 디렉토리를 생성하고 특정 브랜치를 체크아웃합니다.\n# 기본 사용법: git worktree add \u003c경로\u003e \u003c브랜치명\u003e $ git worktree add ../project-hotfix hotfix/login-bug 이렇게 하면 상위 폴더의 project-hotfix라는 디렉토리에 hotfix/login-bug 브랜치가 체크아웃됩니다. 기존 저장소와는 별개로 완전히 독립된 파일 시스템 공간을 가집니다.\nTip: 기존 브랜치가 없다면 -b 옵션으로 새 브랜치를 생성하며 Worktree를 만들 수 있습니다.\n$ git worktree add -b feature/new-ui ../project-ui 2. Worktree 목록 확인 (List) 현재 연결된 모든 Worktree의 목록을 확인합니다.\n$ git worktree list 출력 예시:\n/Users/user/dev/project (main) /Users/user/dev/project-ui (feature/new-ui) 3. Worktree 삭제 (Remove) 작업이 끝난 Worktree는 디렉토리를 그냥 지우는 것보다 git 명령어로 정리하는 것이 깔끔합니다 (Git 내부의 메타데이터도 함께 정리됨).\n$ git worktree remove ../project-ui 4. 정리 (Prune) 만약 Worktree 디렉토리를 파일 탐색기나 rm 명령어로 강제 삭제했다면, Git은 해당 Worktree가 유효하지 않다고 판단하지만 목록에는 남아있을 수 있습니다. 이때 prune을 사용합니다.\n$ git worktree prune 유의사항 중복 체크아웃 불가: 하나의 브랜치는 동시에 여러 Worktree에서 체크아웃될 수 없습니다. 이미 main 브랜치가 열려있다면 다른 Worktree에서 main을 열 수 없습니다. 디렉토리 관리: Worktree 디렉토리는 보통 메인 프로젝트 폴더의 형제(sibling) 폴더로 두는 것이 관리에 용이합니다. 하위 폴더로 둘 경우 .gitignore 설정이 꼬일 수 있으므로 주의해야 합니다. Git Worktree는 멀티태스킹이 필수적인 현대 개발 환경에서 매우 강력한 도구입니다. 상황에 맞게 Stash와 Worktree를 적절히 섞어 사용한다면 개발 생산성을 크게 높일 수 있을 것입니다.\n","wordCount":"641","inLanguage":"en","datePublished":"2026-01-07T00:00:00+09:00","dateModified":"2026-01-07T00:00:00+09:00","author":{"@type":"Person","name":"Byung Kyu KIM"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://cdecl.github.io/dev/git-worktree-guide/"},"publisher":{"@type":"Organization","name":"cdeclog","logo":{"@type":"ImageObject","url":"https://cdecl.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://cdecl.github.io/ accesskey=h title="cdeclog (Alt + H)">cdeclog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://cdecl.github.io/dev/ title=Dev><span>Dev</span></a></li><li><a href=https://cdecl.github.io/devops/ title=DevOps><span>DevOps</span></a></li><li><a href=https://cdecl.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://cdecl.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://cdecl.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://cdecl.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://cdecl.github.io/dev/>Devs</a></div><h1 class="post-title entry-hint-parent">Git Worktree: 하나의 저장소, 여러 작업 공간</h1><div class=post-meta><span title='2026-01-07 00:00:00 +0900 KST'>January 7, 2026</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%ea%b0%9c%ec%9a%94 aria-label=개요>개요</a></li><li><a href=#git-worktree%eb%9e%80 aria-label="Git Worktree란?">Git Worktree란?</a><ul><li><a href=#%ed%95%b5%ec%8b%ac-%ea%b0%9c%eb%85%90 aria-label="핵심 개념">핵심 개념</a></li></ul></li><li><a href=#%ec%99%9c-%ed%95%84%ec%9a%94%ed%95%9c%ea%b0%80%ec%9a%94-%ed%99%9c%ec%9a%a9-%ec%82%ac%eb%a1%80 aria-label="왜 필요한가요? (활용 사례)">왜 필요한가요? (활용 사례)</a></li><li><a href=#stash-vs-worktree aria-label="Stash vs. Worktree">Stash vs. Worktree</a></li><li><a href=#%ec%a3%bc%ec%9a%94-%eb%aa%85%eb%a0%b9%ec%96%b4-%ec%82%ac%ec%9a%a9%eb%b2%95 aria-label="주요 명령어 사용법">주요 명령어 사용법</a><ul><li><a href=#1-worktree-%ec%83%9d%ec%84%b1-add aria-label="1. Worktree 생성 (Add)">1. Worktree 생성 (Add)</a></li><li><a href=#2-worktree-%eb%aa%a9%eb%a1%9d-%ed%99%95%ec%9d%b8-list aria-label="2. Worktree 목록 확인 (List)">2. Worktree 목록 확인 (List)</a></li><li><a href=#3-worktree-%ec%82%ad%ec%a0%9c-remove aria-label="3. Worktree 삭제 (Remove)">3. Worktree 삭제 (Remove)</a></li><li><a href=#4-%ec%a0%95%eb%a6%ac-prune aria-label="4. 정리 (Prune)">4. 정리 (Prune)</a></li></ul></li><li><a href=#%ec%9c%a0%ec%9d%98%ec%82%ac%ed%95%ad aria-label=유의사항>유의사항</a></li></ul></div></details></div><div class=post-content><p>Git Worktree란 무엇이며 왜 필요한가? Stash와의 차이점부터 주요 명령어까지, 효율적인 브랜치 관리</p><h2 id=개요>개요<a hidden class=anchor aria-hidden=true href=#개요>#</a></h2><p>개발을 하다 보면 현재 작업 중인 브랜치에서 아직 커밋하지 못한 변경 사항이 있는데, 긴급하게 다른 브랜치(예: 배포를 위한 핫픽스)로 전환해야 하는 상황을 자주 마주하게 됩니다. 보통은 <code>git stash</code>를 사용하거나 아직 완료되지 않은 코드를 임시 커밋(WIP)하고 브랜치를 전환하지만, 이러한 방식은 번거롭고 컨텍스트 전환에 비용이 듭니다.</p><p><strong>Git Worktree</strong>는 이런 문제를 우아하게 해결해주는 Git의 강력한 기능입니다. 이 글에서는 Git Worktree의 개념과 필요성, 그리고 <code>git stash</code>와의 차이점과 사용법에 대해 알아봅니다.</p><h2 id=git-worktree란>Git Worktree란?<a hidden class=anchor aria-hidden=true href=#git-worktree란>#</a></h2><p>기본적으로 Git 저장소(Repository)를 clone하면 하나의 작업 디렉토리(Working Directory)가 생성되고, 이 디렉토리는 한 번에 하나의 브랜치만 체크아웃할 수 있습니다.</p><p><strong>Git Worktree</strong>는 하나의 로컬 저장소에 여러 개의 작업 디렉토리를 연결하여, <strong>동시에 여러 브랜치를 체크아웃</strong>할 수 있게 해주는 기능입니다. 즉, 물리적으로 분리된 여러 폴더에서 서로 다른 브랜치를 띄워놓고 작업할 수 있습니다.</p><h3 id=핵심-개념>핵심 개념<a hidden class=anchor aria-hidden=true href=#핵심-개념>#</a></h3><ul><li><strong>Main Working Tree</strong>: <code>git clone</code> 시 생성되는 기본 작업 공간.</li><li><strong>Linked Working Tree</strong>: <code>git worktree add</code> 명령어로 생성된 추가 작업 공간들.</li><li>모든 Worktree는 <code>.git</code> 디렉토리(저장소 데이터, 객체 데이터베이스)를 공유합니다. 따라서 디스크 공간을 효율적으로 사용하며, 한 Worktree에서의 커밋은 다른 Worktree에서도 즉시 반영됩니다.</li><li>현재 작업 디렉토리의 변경 사항(Untracked 파일 포함)을 건드리지 않고, 완전히 깨끗한 새 브랜치 환경을 즉시 얻을 수 있습니다.</li></ul><h2 id=왜-필요한가요-활용-사례>왜 필요한가요? (활용 사례)<a hidden class=anchor aria-hidden=true href=#왜-필요한가요-활용-사례>#</a></h2><p>Worktree가 유용한 대표적인 상황들은 다음과 같습니다.</p><ol><li><strong>브랜치 전환의 번거로움 해소</strong>: 현재 기능 개발(<code>feature-A</code>) 중에 긴급한 버그 수정 요청(<code>hotfix</code>)이 들어왔을 때, 하던 작업을 정리할 필요 없이 새로운 Worktree를 만들어 즉시 수정 작업을 시작할 수 있습니다.</li><li><strong>독립적인 테스트 및 빌드</strong>: 하나의 브랜치에서는 서버를 실행해두고, 다른 브랜치에서는 클라이언트 코드를 수정하거나 테스트 코드를 돌려볼 때 유용합니다. 의존성 패키지(node_modules 등)가 브랜치마다 달라서 충돌이 나는 경우, 폴더가 분리되어 있으므로 서로 영향을 주지 않습니다.</li><li><strong>IDE 및 빌드 환경 유지</strong>: 기존 브랜치에서 IDE 창을 열어두고 서버를 띄워둔 상태 그대로, 새 창에서 다른 작업을 할 수 있습니다. <code>stash</code>를 사용했다면 IDE가 파일을 다시 로딩하거나 빌드 캐시가 깨지는 등의 문제가 발생할 수 있지만, worktree는 독립된 환경을 보장합니다.</li></ol><p>특히 <strong>Full-stack 개발</strong>처럼 프론트엔드와 백엔드를 동시에 수정해야 하거나, 여러 기능/핫픽스를 동시에 다뤄야 할 때 매우 유용합니다. <code>git worktree add ../new-work &lt;branch></code> 명령어로 간단히 시작할 수 있습니다.</p><h2 id=stash-vs-worktree>Stash vs. Worktree<a hidden class=anchor aria-hidden=true href=#stash-vs-worktree>#</a></h2><p>비슷한 상황에서 사용되는 <code>git stash</code>와 비교해보면 차이점이 명확합니다.</p><table><thead><tr><th style=text-align:left>기능</th><th style=text-align:left>Git Stash</th><th style=text-align:left>Git Worktree</th></tr></thead><tbody><tr><td style=text-align:left><strong>Untracked 파일</strong></td><td style=text-align:left><code>-u</code> 옵션 필요, 실수로 누락 시 오류 발생 가능</td><td style=text-align:left>현재 디렉토리 그대로 유지, 새 작업 공간은 깨끗한 상태</td></tr><tr><td style=text-align:left><strong>병렬 작업</strong></td><td style=text-align:left>한번에 하나만 가능 (Push/Pop 반복으로 컨텍스트 손실)</td><td style=text-align:left>여러 디렉토리에서 동시 작업 가능 (IDE 여러 개 실행 등)</td></tr><tr><td style=text-align:left><strong>리스크</strong></td><td style=text-align:left>Stash 목록 관리의 어려움 (무엇을 저장했는지 잊음)</td><td style=text-align:left>최소화 (공유 .git으로 일관성 유지)</td></tr><tr><td style=text-align:left><strong>디스크 공간</strong></td><td style=text-align:left>거의 차지하지 않음</td><td style=text-align:left>체크아웃된 파일만큼 추가 사용</td></tr></tbody></table><p><strong>정리하자면:</strong></p><ul><li><strong>단순하고 짧은 작업 전환</strong>에는 <code>stash</code>가 빠르고 간편합니다.</li><li><strong>긴 호흡의 병렬 작업</strong>, <strong>Untracked 파일을 포함한 복잡한 상태 유지</strong>, <strong>환경 격리</strong>가 필요할 때는 <code>worktree</code>가 압도적으로 유리합니다.</li></ul><h2 id=주요-명령어-사용법>주요 명령어 사용법<a hidden class=anchor aria-hidden=true href=#주요-명령어-사용법>#</a></h2><h3 id=1-worktree-생성-add>1. Worktree 생성 (Add)<a hidden class=anchor aria-hidden=true href=#1-worktree-생성-add>#</a></h3><p>새로운 작업 디렉토리를 생성하고 특정 브랜치를 체크아웃합니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#6272a4># 기본 사용법: git worktree add &lt;경로&gt; &lt;브랜치명&gt;</span>
</span></span><span style=display:flex><span>$ git worktree add ../project-hotfix hotfix/login-bug
</span></span></code></pre></div><p>이렇게 하면 상위 폴더의 <code>project-hotfix</code>라는 디렉토리에 <code>hotfix/login-bug</code> 브랜치가 체크아웃됩니다. 기존 저장소와는 별개로 완전히 독립된 파일 시스템 공간을 가집니다.</p><blockquote><p><strong>Tip</strong>: 기존 브랜치가 없다면 <code>-b</code> 옵션으로 새 브랜치를 생성하며 Worktree를 만들 수 있습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git worktree add -b feature/new-ui ../project-ui
</span></span></code></pre></div></blockquote><h3 id=2-worktree-목록-확인-list>2. Worktree 목록 확인 (List)<a hidden class=anchor aria-hidden=true href=#2-worktree-목록-확인-list>#</a></h3><p>현재 연결된 모든 Worktree의 목록을 확인합니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git worktree list
</span></span></code></pre></div><p>출력 예시:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>/Users/user/dev/project       (main)
</span></span><span style=display:flex><span>/Users/user/dev/project-ui    (feature/new-ui)
</span></span></code></pre></div><h3 id=3-worktree-삭제-remove>3. Worktree 삭제 (Remove)<a hidden class=anchor aria-hidden=true href=#3-worktree-삭제-remove>#</a></h3><p>작업이 끝난 Worktree는 디렉토리를 그냥 지우는 것보다 git 명령어로 정리하는 것이 깔끔합니다 (Git 내부의 메타데이터도 함께 정리됨).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git worktree remove ../project-ui
</span></span></code></pre></div><h3 id=4-정리-prune>4. 정리 (Prune)<a hidden class=anchor aria-hidden=true href=#4-정리-prune>#</a></h3><p>만약 Worktree 디렉토리를 파일 탐색기나 <code>rm</code> 명령어로 강제 삭제했다면, Git은 해당 Worktree가 유효하지 않다고 판단하지만 목록에는 남아있을 수 있습니다. 이때 <code>prune</code>을 사용합니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git worktree prune
</span></span></code></pre></div><h2 id=유의사항>유의사항<a hidden class=anchor aria-hidden=true href=#유의사항>#</a></h2><ul><li><strong>중복 체크아웃 불가</strong>: 하나의 브랜치는 동시에 여러 Worktree에서 체크아웃될 수 없습니다. 이미 <code>main</code> 브랜치가 열려있다면 다른 Worktree에서 <code>main</code>을 열 수 없습니다.</li><li><strong>디렉토리 관리</strong>: Worktree 디렉토리는 보통 메인 프로젝트 폴더의 형제(sibling) 폴더로 두는 것이 관리에 용이합니다. 하위 폴더로 둘 경우 <code>.gitignore</code> 설정이 꼬일 수 있으므로 주의해야 합니다.</li></ul><hr><p>Git Worktree는 멀티태스킹이 필수적인 현대 개발 환경에서 매우 강력한 도구입니다. 상황에 맞게 Stash와 Worktree를 적절히 섞어 사용한다면 개발 생산성을 크게 높일 수 있을 것입니다.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://cdecl.github.io/tags/git/>Git</a></li><li><a href=https://cdecl.github.io/tags/worktree/>Worktree</a></li><li><a href=https://cdecl.github.io/tags/productivity/>Productivity</a></li><li><a href=https://cdecl.github.io/tags/version-control/>Version-Control</a></li></ul></footer><script src=https://giscus.app/client.js data-repo=cdecl/cdecl.github.io data-repo-id="MDEwOlJlcG9zaXRvcnkzNDk1ODUyNjg=" data-category=General data-category-id=DIC_kwDOFNY_dM4C1XMk data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=transparent_dark data-lang=ko crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2026 <a href=https://cdecl.github.io/>cdeclog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>