<!doctype html><html lang=en dir=auto data-theme=auto><head><meta name=generator content="Hugo 0.155.1"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>cdeclog</title><meta name=description content="cdecl's Dev.Ops Blog"><meta name=author content="Byung Kyu KIM"><link rel=canonical href=https://cdecl.github.io/><link crossorigin=anonymous href=/assets/css/stylesheet.f939c4ffefb264e6fe85e04352266f79db6bb1303c8e16ae9b6064c1247b5e32.css integrity="sha256-+TnE/++yZOb+heBDUiZvedtrsTA8jhaum2BkwSR7XjI=" rel="preload stylesheet" as=style><link rel=icon href=https://cdecl.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://cdecl.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://cdecl.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://cdecl.github.io/apple-touch-icon.png><link rel=mask-icon href=https://cdecl.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://cdecl.github.io/index.xml title=rss><link rel=alternate type=application/json href=https://cdecl.github.io/index.json title=json><link rel=alternate hreflang=en href=https://cdecl.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-VQQHHYPN7K"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VQQHHYPN7K")}</script><meta property="og:url" content="https://cdecl.github.io/"><meta property="og:site_name" content="cdeclog"><meta property="og:title" content="cdeclog"><meta property="og:description" content="cdecl's Dev.Ops Blog"><meta property="og:locale" content="ko-kr"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="cdeclog"><meta name=twitter:description content="cdecl's Dev.Ops Blog"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"cdeclog","url":"https://cdecl.github.io/","description":"cdecl's Dev.Ops Blog","logo":"https://cdecl.github.io/favicon.ico","sameAs":["https://github.com/cdecl","https://cdecl.tistory.com/"]}</script></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://cdecl.github.io/ accesskey=h title="cdeclog (Alt + H)">cdeclog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://cdecl.github.io/dev/ title=Dev><span>Dev</span></a></li><li><a href=https://cdecl.github.io/devops/ title=DevOps><span>DevOps</span></a></li><li><a href=https://cdecl.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://cdecl.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://cdecl.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Python PEP 8 스타일 가이드</h2></header><div class=entry-content><p>Python PEP 8 스타일 가이드
1. PEP 8이란? PEP 8(Python Enhancement Proposal 8)은 Python 코드의 가독성과 일관성을 향상시키기 위한 스타일 가이드입니다. Python의 창시자인 Guido van Rossum이 작성했으며, Python 커뮤니티에서 널리 채택된 코딩 표준입니다.
1.1 PEP 8의 목적 코드의 가독성 향상 일관된 코딩 스타일 유지 협업 효율성 증대 코드 유지보수 용이성 향상 2. PEP 8 주요 규약 2.1 코드 레이아웃 들여쓰기 4칸 공백 사용 # 올바른 들여쓰기 (4칸 공백 사용) def long_function_name( var_one, var_two, var_three, var_four): print(var_one) # 잘못된 들여쓰기 def long_function_name( var_one, var_two, # 들여쓰기가 부족함 var_three, var_four): print(var_one) 최대 줄 길이 한 줄은 최대 79자 긴 줄은 여러 줄로 나누기 백슬래시() 사용하여 줄 나누기 # 올바른 예시 from mypkg.mymodule import ( function1, function2, function3, function4) long_string = ('This is a very long string that ' 'cannot fit within 79 characters ' 'so we split it into multiple lines.') 2.2 공백 규칙 연산자 주변 공백 # 올바른 예시 x = 1 y = 2 long_variable = 3 # 잘못된 예시 x=1 y = 2 long_variable = 3 쉼표 후 공백 # 올바른 예시 def complex_function(x, y, z): pass # 잘못된 예시 def complex_function(x,y,z): pass 2.3 명명 규칙 변수명 : snake case 소문자 사용 단어 사이는 언더스코어(_)로 구분 my_variable = 1 count_of_users = 10 first_name = "John" 함수명 : snake case 소문자 사용 단어 사이는 언더스코어로 구분 def calculate_average(): pass def get_user_info(): pass 클래스명 : Pascal Case) CapWords(Pascal Case) 컨벤션 사용 class UserAccount: pass class DatabaseConnection: pass 상수 대문자와 언더스코어 사용 MAX_CONNECTIONS = 100 DEFAULT_TIMEOUT = 30 2.4 제어문 스타일 if 문 # 올바른 예시 if x is not None: pass if x == 4: print('x is 4') elif x == 5: print('x is 5') else: print('x is not 4 or 5') # 잘못된 예시 if x!=None: pass for 문 # 올바른 예시 for i in range(5): print(i) # 리스트 컴프리헨션 (한 줄인 경우) squares = [x**2 for x in range(10)] # 리스트 컴프리헨션 (복잡한 경우) squares = [ x**2 for x in range(10) if x % 2 == 0 ] 2.5 주석 작성 규칙 인라인 주석 x = 5 # 이것은 인라인 주석입니다 # 잘못된 예시 x = 5# 공백이 없음 문서화 문자열 (Docstrings) def complex_function(param1, param2): """이 함수는 복잡한 연산을 수행합니다. Args: param1 (int): 첫 번째 매개변수 param2 (str): 두 번째 매개변수 Returns: bool: 연산 성공 여부 """ pass 3. VS Code에서 PEP 8 설정하기 3.1 필수 플러그인 Python Extension Pack Python 언어 지원 기본적인 PEP 8 검사 기능 포함 Pylint 코드 분석 도구 PEP 8 규칙 검사 { "python.linting.pylintEnabled": true, "python.linting.enabled": true } Flake8 PEP 8 스타일 가이드 검사
...</p></div><footer class=entry-footer><span title='2024-10-28 00:00:00 +0900 KST'>October 28, 2024</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to Python PEP 8 스타일 가이드" href=https://cdecl.github.io/dev/python-pep8/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>xargs - 효율적인 명령어 인수 처리와 병렬 실행</h2></header><div class=entry-content><p>xargs - 효율적인 명령어 인수 처리와 병렬 실행
xargs 명령어: 효율적인 명령어 확장과 파라미터 전달 xargs 명령어는 한 명령어의 출력을 다른 명령어의 인수로 전달할 때 유용하게 사용됩니다. 특히 명령어의 파라미터가 길어지거나 여러 파일, 디렉토리를 대상으로 명령어를 실행해야 할 때 xargs를 사용하면 성능과 효율성을 높일 수 있습니다.
주요 옵션과 활용 예시 1. 기본 사용법 xargs는 기본적으로 표준 입력에서 받은 데이터를 공백 또는 개행으로 구분하여 후속 명령어의 인수로 전달합니다.
예시:
echo "file1 file2 file3" | xargs ls -l file1, file2, file3을 ls -l의 인수로 전달하여 파일의 상세 정보를 출력합니다.
...</p></div><footer class=entry-footer><span title='2024-10-27 00:00:00 +0900 KST'>October 27, 2024</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to xargs - 효율적인 명령어 인수 처리와 병렬 실행" href=https://cdecl.github.io/devops/xargs-command-guide/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Git 커밋 메시지 수정</h2></header><div class=entry-content><p>Git 커밋 메시지 수정
Git 커밋 메시지 수정 가이드 Git을 사용하다 보면 커밋 메시지를 수정해야 할 경우가 자주 발생합니다.
이 글에서는 가장 기본적인 방법부터 고급 기술까지 모든 커밋 메시지 수정 방법을 다루겠습니다.
기본적인 커밋 메시지 수정 방법 1. 가장 최근 커밋 메시지 수정 가장 최근의 커밋 메시지를 수정하는 것은 매우 간단합니다.
git commit --amend 또는 에디터를 열지 않고 직접 메시지를 입력할 수우도 있습니다:
git commit --amend -m "새로운 커밋 메시지" 2. 커밋 내용과 메시지 함께 수정 파일 변경사항을 포함하여 최근 커밋을 수정할 수 있습니다:
...</p></div><footer class=entry-footer><span title='2024-10-26 00:00:00 +0900 KST'>October 26, 2024</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to Git 커밋 메시지 수정" href=https://cdecl.github.io/dev/git-rebase-commit-message-edit-guide/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>sed - pattern capture substitute 활용</h2></header><div class=entry-content><p>sed 명령어: 텍스트 패턴 캡처와 치환 활용법
sed는 파일이나 텍스트 스트림의 내용에서 특정 패턴을 찾아 변경하는 데 유용한 **스트림 편집기(Stream Editor)**입니다.
특히 정규 표현식 기능을 통해 텍스트의 특정 부분을 캡처하고 치환하는 기능이 강력합니다.
이번 글에서는 -E 및 -r 옵션을 사용하여 더 간편하게 캡처 그룹을 생성하고 치환하는 방법을 소개하겠습니다.
1. sed 명령어 정의 및 용도 sed는 파일이나 텍스트를 자동으로 조작하는 명령어로, 주로 Linux 및 Unix 환경에서 사용됩니다.
sed는 스크립트 없이도 다양한 텍스트 처리 작업을 쉽게 수행할 수 있는 장점이 있으며, 주요 용도는 다음과 같습니다:
...</p></div><footer class=entry-footer><span title='2024-10-25 00:00:00 +0900 KST'>October 25, 2024</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to sed - pattern capture substitute 활용" href=https://cdecl.github.io/devops/sed-capture-replace/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Selenium 101</h2></header><div class=entry-content><p>Python Selenium 이용한 웹 스크래핑 방법, 웹 자동화
Selenium 가이드: 웹 자동화 1. Selenium 이란? Selenium은 웹 브라우저 자동화를 위한 아래와 같은 용도
웹 애플리케이션 테스트 자동화 웹 스크래핑 및 데이터 추출 반복적인 웹 작업 자동화 크로스 브라우저 테스팅 주요 기능 브라우저 제어: 다양한 브라우저에서 웹 페이지를 자동으로 로드하고 조작할 수 있습니다. DOM 조작: 웹 페이지의 DOM 요소를 검색하고 조작할 수 있습니다. 폼 자동화: 폼을 자동으로 작성하고 제출할 수 있습니다. 스크린샷 캡처: 웹 페이지의 스크린샷을 캡처할 수 있습니다. 헤드리스 모드: 브라우저 창을 띄우지 않고 백그라운드에서 작업을 수행할 수 있습니다. Selenium은 다양한 프로그래밍 언어를 지원하며, 웹 개발자와 QA 엔지니어들에게 필수적인 도구로 사용
...</p></div><footer class=entry-footer><span title='2024-08-01 00:00:00 +0900 KST'>August 1, 2024</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to Selenium 101" href=https://cdecl.github.io/dev/selenium-101/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>ARP 스푸핑, arpspoof와 fragrouter 사용법 원리</h2></header><div class=entry-content><p>네트워크 보안 툴 arpspoof와 fragrouter 사용법 및 ARP 스푸핑 원리
1. ARP (주소 결정 프로토콜)란? 1. 정의 ARP`(Address Resolution Pro 이를 통해 로컬 네트워크에서 IP 패킷이 올바른 물리적 네트워크 장치로 전달될 수 있습니다.
2. 작동 원리 ARP는 다음과 같은 과정으로 작동합니다:
ARP 요청 (Request) 송신 호스트가 목적지 호스트의 MAC 주소를 모를 때, ARP 요청 패킷을 브로드캐스트로 네트워크에 전송합니다. 이 요청 패킷에는 송신 호스트의 IP 주소와 MAC 주소, 그리고 목적지 호스트의 IP 주소가 포함되어 있습니다. ARP 응답 (Reply) 네트워크에 있는 모든 호스트가 이 ARP 요청을 수신합니다. 요청된 IP 주소를 가진 호스트는 자신의 MAC 주소를 포함한 ARP 응답 패킷을 송신 호스트에게 유니캐스트로 전송합니다. 주소 매핑 송신 호스트는 ARP 응답을 수신하고, 해당 IP 주소와 MAC 주소의 매핑을 ARP 캐시(테이블)에 저장합니다. 이후 동일한 IP 주소로의 통신이 발생할 때, ARP 캐시를 참조하여 MAC 주소를 빠르게 확인할 수 있습니다. 3. ARP 캐시 ARP 캐시는 IP 주소와 MAC 주소의 매핑을 일시적으로 저장하는 테이블입니다.
이를 통해 같은 IP 주소에 대한 반복적인 ARP 요청을 방지하고, 네트워크 성능을 향상시킬 수 있습니다.
그러나 ARP 캐시는 보통 일정 시간이 지나면 항목이 만료됩니다.
...</p></div><footer class=entry-footer><span title='2024-06-26 00:00:00 +0900 KST'>June 26, 2024</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to ARP 스푸핑, arpspoof와 fragrouter 사용법 원리" href=https://cdecl.github.io/devops/arpspoof-fragrouter/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Docker 네트워크 - Macvlan</h2></header><div class=entry-content><p>Docker Macvlan 네트워크 소개, 활용 및 이슈
1. Docker Macvlan 네트워크? Macvlan 네트워크는 컨테이너에 독립적인 네트워크 인터페이스를 제공하여 물리적 네트워크와 직접 상호작용 가능
이는 각 컨테이너가 고유한 MAC 주소를 가지므로 네트워크 수준에서 완전히 독립된 호스트처럼 동작 가능
호스트 머신과 같은 네트워크에 docker 컨테이너를 생성 목적
Macvlan 네트워크 설정은 물리적 네트워크 환경에 따라 적절한 서브넷과 게이트웨이를 사용 필요 (e.g. DHCP 환경)
Macvlan 구성 네트워크 성능 향상: 호스트의 NAT를 거치지 않아 성능이 향상 네트워크 격리: 각 컨테이너가 고유한 MAC 주소를 가져 네트워크 레벨에서 완전히 격리 기존 네트워크와의 통합: 기존 물리적 네트워크 인프라와 쉽게 통합 Docker 네트워크 유형 브리지 네트워크 (Bridge Network) 기본 네트워크 모드로, Docker가 기본적으로 사용하는 네트워크입니다. 내부 네트워크를 생성하여 컨테이너 간의 통신을 가능하게 합니다. 호스트와 컨테이너 간의 통신은 NAT(Network Address Translation)를 사용합니다. 호스트 네트워크 (Host Network) 컨테이너가 호스트의 네트워크 스택을 공유합니다. 성능이 중요한 애플리케이션에서 사용될 수 있습니다. 컨테이너와 호스트 간의 네트워크 격리가 없습니다. None 네트워크 (None Network) 네트워크 연결이 없는 컨테이너를 생성합니다. 네트워크 격리가 필요한 경우에 유용합니다. 2. Macvlan 네트워크 설정 설치 요구 사항 Docker가 설치된 시스템, 루트 권한 또는 Docker 관리 권한
...</p></div><footer class=entry-footer><span title='2024-06-25 00:00:00 +0900 KST'>June 25, 2024</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to Docker 네트워크 - Macvlan" href=https://cdecl.github.io/devops/docker-macvlan/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Nmap vs. Netcat</h2></header><div class=entry-content><p>Nmap vs. nc (Network Mapper vs. Netcat) 네트워크 스캐닝 도구로서 비교
Nmap vs. nc (Netcat): 네트워크 스캐닝 도구 비교 Nmap (Network Mapper) 네트워크 스캐닝 및 보안 평가 도구로, 대규모 네트워크에서 호스트, 서비스, 오픈 포트를 탐지하는 데 사용
네트워크 호스트, 서비스, 오픈 포트 스캐닝, 운영 체제 감지, 버전 감지, 서비스 식별 등 다양한 네트워크 탐지 및 보안 평가 기능
옵션 설명 예제 -p 특정 포트를 스캔합니다 nmap -p 80,443 192.168.1.100 -p- 모든 포트를 스캔합니다 nmap -p- 192.168.1.100 -sV 서비스 버전을 탐지합니다 nmap -sV 192.168.1.100 -O 운영 체제를 탐지합니다 nmap -O 192.168.1.100 -sS TCP SYN 스캔을 수행합니다 nmap -sS 192.168.1.100 -sU UDP 포트를 스캔합니다 nmap -sU 192.168.1.100 -T4 스캔 속도를 높입니다 nmap -T4 192.168.1.100 -A 공격적 스캔을 수행합니다 (OS, 서비스 탐지) nmap -A 192.168.1.100 -oN 스캔 결과를 일반 텍스트 파일로 저장합니다 nmap -oN scan_results.txt 192.168.1.100 -oX 스캔 결과를 XML 파일로 저장합니다 nmap -oX scan_results.xml 192.168.1.100 -oG 스캔 결과를 그레프블(grepable) 형식으로 저장합니다 nmap -oG scan_results.gnmap 192.168.1.100 -oA 모든 형식으로 스캔 결과를 저장합니다 (N, X, G 파일) nmap -oA scan_results 192.168.1.100 -v 스캔 중 자세한 출력을 제공합니다 nmap -v 192.168.1.100 -vv 매우 자세한 출력을 제공합니다 nmap -vv 192.168.1.100 -Pn 호스트가 응답하지 않더라도 스캔을 수행합니다 nmap -Pn 192.168.1.100 --open 열린 포트만 출력합니다 nmap --open 192.168.1.100 --reason 포트 상태 결정의 이유를 출력합니다 nmap --reason 192.168.1.100 --script NSE(Nmap Scripting Engine) 스크립트를 실행합니다 nmap --script default 192.168.1.100 --exclude 특정 IP 주소를 제외하고 스캔합니다 nmap -sn 192.168.1.0/24 --exclude 192.168.1.1 --max-retries 재시도 횟수를 지정합니다 nmap --max-retries 2 192.168.1.100 nc (Netcat) 네트워크 연결 도구로, TCP/IP 소켓을 직접 다루는 데 사용되며, 데이터 전송, 포트 스캐닝, 포트 열기 및 메시지 전송 등의 작업을 수행할 수 있음
...</p></div><footer class=entry-footer><span title='2024-06-17 00:00:00 +0900 KST'>June 17, 2024</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to Nmap vs. Netcat" href=https://cdecl.github.io/devops/nmap-nc/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Homebrew, Formulae와 Cask의 차이점</h2></header><div class=entry-content><p>Homebrew는 macOS와 Linux에서 소프트웨어를 쉽게 설치하고 관리할 수 있는 패키지 관리자.
Homebrew https://brew.sh/{:target="_blank"} Homebrew는 macOS와 Linux에서 소프트웨어 패키지를 간편하게 설치하고 관리할 수 있는 패키지 관리자 Homebrew에는 두 가지 주요 설치 방법인 Formulae와 Cask가 있습니다. Formulae와 Cask의 차이점과 동일한 애플리케이션이 두 가지 방법으로 제공되는 예시를 설명 Homebrew 설치 macOS $ brew --version # 설치 확인 Linux $ eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)" $ brew --version # 설치 확인 Homebrew 주요 명령어 Formulae 설치 (CLI 애플리케이션) brew install &lt;package-name> 예: wget 설치
...</p></div><footer class=entry-footer><span title='2024-06-07 00:00:00 +0900 KST'>June 7, 2024</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to Homebrew, Formulae와 Cask의 차이점" href=https://cdecl.github.io/devops/homebrew-formulae-cask/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>TLS와 SSH 프로토콜 기능</h2></header><div class=entry-content><p>TLS와 SSH 프로토콜의 서버-클라이언트 협상 항목과 기능 비교
TLS와 SSH 프로토콜 정의 1. TLS(Transport Layer Security) TLS 프로토콜은 인터넷 상에서 안전한 통신을 위해 사용되는 암호화 프로토콜입니다. TLS는 SSL(Secure Sockets Layer) 프로토콜의 후속 버전으로, 웹 브라우저와 웹 서버 사이의 통신을 암호화하여 데이터 보안을 강화하는데 사용됩니다.
TLS 프로토콜의 주요 기능 암호화: 클라이언트와 서버 간의 통신 내용을 암호화하여 보호 인증: 서버의 신원을 인증하고, 클라이언트 인증도 지원 무결성: 전송 데이터의 변조를 방지 TLS는 HTTP, SMTP, IMAP 등 다양한 프로토콜의 보안 계층으로 사용됩니다. TLS 1.0/1.1은 더 이상 권장되지 않으며, 현재는 TLS 1.2와 가장 최신 표준인 TLS 1.3이 널리 사용되고 있습니다. 특히 TLS 1.3은 이전 버전 대비 보안성과 성능이 크게 향상되었습니다.
...</p></div><footer class=entry-footer><span title='2024-04-06 00:00:00 +0900 KST'>April 6, 2024</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to TLS와 SSH 프로토콜 기능" href=https://cdecl.github.io/devops/tls-ssh-handshake/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://cdecl.github.io/page/6/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://cdecl.github.io/page/8/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2026 <a href=https://cdecl.github.io/>cdeclog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>