<!doctype html><html lang=en dir=auto data-theme=auto><head><meta name=generator content="Hugo 0.154.5"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>cdeclog</title><meta name=description content="cdecl's Dev.Ops Blog"><meta name=author content="Byung Kyu KIM"><link rel=canonical href=https://cdecl.github.io/><link crossorigin=anonymous href=/assets/css/stylesheet.f939c4ffefb264e6fe85e04352266f79db6bb1303c8e16ae9b6064c1247b5e32.css integrity="sha256-+TnE/++yZOb+heBDUiZvedtrsTA8jhaum2BkwSR7XjI=" rel="preload stylesheet" as=style><link rel=icon href=https://cdecl.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://cdecl.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://cdecl.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://cdecl.github.io/apple-touch-icon.png><link rel=mask-icon href=https://cdecl.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://cdecl.github.io/index.xml title=rss><link rel=alternate type=application/json href=https://cdecl.github.io/index.json title=json><link rel=alternate hreflang=en href=https://cdecl.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-VQQHHYPN7K"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VQQHHYPN7K")}</script><meta property="og:url" content="https://cdecl.github.io/"><meta property="og:site_name" content="cdeclog"><meta property="og:title" content="cdeclog"><meta property="og:description" content="cdecl's Dev.Ops Blog"><meta property="og:locale" content="ko-kr"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="cdeclog"><meta name=twitter:description content="cdecl's Dev.Ops Blog"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"cdeclog","url":"https://cdecl.github.io/","description":"cdecl's Dev.Ops Blog","logo":"https://cdecl.github.io/favicon.ico","sameAs":["https://github.com/cdecl","https://cdecl.tistory.com/"]}</script></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://cdecl.github.io/ accesskey=h title="cdeclog (Alt + H)">cdeclog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://cdecl.github.io/dev/ title=Dev><span>Dev</span></a></li><li><a href=https://cdecl.github.io/devops/ title=DevOps><span>DevOps</span></a></li><li><a href=https://cdecl.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://cdecl.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://cdecl.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Selenium 101</h2></header><div class=entry-content><p>Python Selenium 이용한 웹 스크래핑 방법, 웹 자동화
Selenium 가이드: 웹 자동화 1. Selenium 이란? Selenium은 웹 브라우저 자동화를 위한 아래와 같은 용도
웹 애플리케이션 테스트 자동화 웹 스크래핑 및 데이터 추출 반복적인 웹 작업 자동화 크로스 브라우저 테스팅 주요 기능 브라우저 제어: 다양한 브라우저에서 웹 페이지를 자동으로 로드하고 조작할 수 있습니다. DOM 조작: 웹 페이지의 DOM 요소를 검색하고 조작할 수 있습니다. 폼 자동화: 폼을 자동으로 작성하고 제출할 수 있습니다. 스크린샷 캡처: 웹 페이지의 스크린샷을 캡처할 수 있습니다. 헤드리스 모드: 브라우저 창을 띄우지 않고 백그라운드에서 작업을 수행할 수 있습니다. Selenium은 다양한 프로그래밍 언어를 지원하며, 웹 개발자와 QA 엔지니어들에게 필수적인 도구로 사용
...</p></div><footer class=entry-footer><span title='2024-08-01 00:00:00 +0900 KST'>August 1, 2024</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to Selenium 101" href=https://cdecl.github.io/dev/selenium-101/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>ARP 스푸핑, arpspoof와 fragrouter 사용법 원리</h2></header><div class=entry-content><p>네트워크 보안 툴 arpspoof와 fragrouter 사용법 및 ARP 스푸핑 원리
1. ARP (주소 결정 프로토콜)란? 1. 정의 ARP`(Address Resolution Pro 이를 통해 로컬 네트워크에서 IP 패킷이 올바른 물리적 네트워크 장치로 전달될 수 있습니다.
2. 작동 원리 ARP는 다음과 같은 과정으로 작동합니다:
ARP 요청 (Request) 송신 호스트가 목적지 호스트의 MAC 주소를 모를 때, ARP 요청 패킷을 브로드캐스트로 네트워크에 전송합니다. 이 요청 패킷에는 송신 호스트의 IP 주소와 MAC 주소, 그리고 목적지 호스트의 IP 주소가 포함되어 있습니다. ARP 응답 (Reply) 네트워크에 있는 모든 호스트가 이 ARP 요청을 수신합니다. 요청된 IP 주소를 가진 호스트는 자신의 MAC 주소를 포함한 ARP 응답 패킷을 송신 호스트에게 유니캐스트로 전송합니다. 주소 매핑 송신 호스트는 ARP 응답을 수신하고, 해당 IP 주소와 MAC 주소의 매핑을 ARP 캐시(테이블)에 저장합니다. 이후 동일한 IP 주소로의 통신이 발생할 때, ARP 캐시를 참조하여 MAC 주소를 빠르게 확인할 수 있습니다. 3. ARP 캐시 ARP 캐시는 IP 주소와 MAC 주소의 매핑을 일시적으로 저장하는 테이블입니다.
이를 통해 같은 IP 주소에 대한 반복적인 ARP 요청을 방지하고, 네트워크 성능을 향상시킬 수 있습니다.
그러나 ARP 캐시는 보통 일정 시간이 지나면 항목이 만료됩니다.
...</p></div><footer class=entry-footer><span title='2024-06-26 00:00:00 +0900 KST'>June 26, 2024</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to ARP 스푸핑, arpspoof와 fragrouter 사용법 원리" href=https://cdecl.github.io/devops/arpspoof-fragrouter/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Docker 네트워크 - Macvlan</h2></header><div class=entry-content><p>Docker Macvlan 네트워크 소개, 활용 및 이슈
1. Docker Macvlan 네트워크? Macvlan 네트워크는 컨테이너에 독립적인 네트워크 인터페이스를 제공하여 물리적 네트워크와 직접 상호작용 가능
이는 각 컨테이너가 고유한 MAC 주소를 가지므로 네트워크 수준에서 완전히 독립된 호스트처럼 동작 가능
호스트 머신과 같은 네트워크에 docker 컨테이너를 생성 목적
Macvlan 네트워크 설정은 물리적 네트워크 환경에 따라 적절한 서브넷과 게이트웨이를 사용 필요 (e.g. DHCP 환경)
Macvlan 구성 네트워크 성능 향상: 호스트의 NAT를 거치지 않아 성능이 향상 네트워크 격리: 각 컨테이너가 고유한 MAC 주소를 가져 네트워크 레벨에서 완전히 격리 기존 네트워크와의 통합: 기존 물리적 네트워크 인프라와 쉽게 통합 Docker 네트워크 유형 브리지 네트워크 (Bridge Network) 기본 네트워크 모드로, Docker가 기본적으로 사용하는 네트워크입니다. 내부 네트워크를 생성하여 컨테이너 간의 통신을 가능하게 합니다. 호스트와 컨테이너 간의 통신은 NAT(Network Address Translation)를 사용합니다. 호스트 네트워크 (Host Network) 컨테이너가 호스트의 네트워크 스택을 공유합니다. 성능이 중요한 애플리케이션에서 사용될 수 있습니다. 컨테이너와 호스트 간의 네트워크 격리가 없습니다. None 네트워크 (None Network) 네트워크 연결이 없는 컨테이너를 생성합니다. 네트워크 격리가 필요한 경우에 유용합니다. 2. Macvlan 네트워크 설정 설치 요구 사항 Docker가 설치된 시스템, 루트 권한 또는 Docker 관리 권한
...</p></div><footer class=entry-footer><span title='2024-06-25 00:00:00 +0900 KST'>June 25, 2024</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to Docker 네트워크 - Macvlan" href=https://cdecl.github.io/devops/docker-macvlan/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Nmap vs. Netcat</h2></header><div class=entry-content><p>Nmap vs. nc (Network Mapper vs. Netcat) 네트워크 스캐닝 도구로서 비교
Nmap vs. nc (Netcat): 네트워크 스캐닝 도구 비교 Nmap (Network Mapper) 네트워크 스캐닝 및 보안 평가 도구로, 대규모 네트워크에서 호스트, 서비스, 오픈 포트를 탐지하는 데 사용
네트워크 호스트, 서비스, 오픈 포트 스캐닝, 운영 체제 감지, 버전 감지, 서비스 식별 등 다양한 네트워크 탐지 및 보안 평가 기능
옵션 설명 예제 -p 특정 포트를 스캔합니다 nmap -p 80,443 192.168.1.100 -p- 모든 포트를 스캔합니다 nmap -p- 192.168.1.100 -sV 서비스 버전을 탐지합니다 nmap -sV 192.168.1.100 -O 운영 체제를 탐지합니다 nmap -O 192.168.1.100 -sS TCP SYN 스캔을 수행합니다 nmap -sS 192.168.1.100 -sU UDP 포트를 스캔합니다 nmap -sU 192.168.1.100 -T4 스캔 속도를 높입니다 nmap -T4 192.168.1.100 -A 공격적 스캔을 수행합니다 (OS, 서비스 탐지) nmap -A 192.168.1.100 -oN 스캔 결과를 일반 텍스트 파일로 저장합니다 nmap -oN scan_results.txt 192.168.1.100 -oX 스캔 결과를 XML 파일로 저장합니다 nmap -oX scan_results.xml 192.168.1.100 -oG 스캔 결과를 그레프블(grepable) 형식으로 저장합니다 nmap -oG scan_results.gnmap 192.168.1.100 -oA 모든 형식으로 스캔 결과를 저장합니다 (N, X, G 파일) nmap -oA scan_results 192.168.1.100 -v 스캔 중 자세한 출력을 제공합니다 nmap -v 192.168.1.100 -vv 매우 자세한 출력을 제공합니다 nmap -vv 192.168.1.100 -Pn 호스트가 응답하지 않더라도 스캔을 수행합니다 nmap -Pn 192.168.1.100 --open 열린 포트만 출력합니다 nmap --open 192.168.1.100 --reason 포트 상태 결정의 이유를 출력합니다 nmap --reason 192.168.1.100 --script NSE(Nmap Scripting Engine) 스크립트를 실행합니다 nmap --script default 192.168.1.100 --exclude 특정 IP 주소를 제외하고 스캔합니다 nmap -sn 192.168.1.0/24 --exclude 192.168.1.1 --max-retries 재시도 횟수를 지정합니다 nmap --max-retries 2 192.168.1.100 nc (Netcat) 네트워크 연결 도구로, TCP/IP 소켓을 직접 다루는 데 사용되며, 데이터 전송, 포트 스캐닝, 포트 열기 및 메시지 전송 등의 작업을 수행할 수 있음
...</p></div><footer class=entry-footer><span title='2024-06-17 00:00:00 +0900 KST'>June 17, 2024</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to Nmap vs. Netcat" href=https://cdecl.github.io/devops/nmap-nc/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Homebrew, Formulae와 Cask의 차이점</h2></header><div class=entry-content><p>Homebrew는 macOS와 Linux에서 소프트웨어를 쉽게 설치하고 관리할 수 있는 패키지 관리자.
Homebrew https://brew.sh/{:target="_blank"} Homebrew는 macOS와 Linux에서 소프트웨어 패키지를 간편하게 설치하고 관리할 수 있는 패키지 관리자 Homebrew에는 두 가지 주요 설치 방법인 Formulae와 Cask가 있습니다. Formulae와 Cask의 차이점과 동일한 애플리케이션이 두 가지 방법으로 제공되는 예시를 설명 Homebrew 설치 macOS $ brew --version # 설치 확인 Linux $ eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)" $ brew --version # 설치 확인 Homebrew 주요 명령어 Formulae 설치 (CLI 애플리케이션) brew install &lt;package-name> 예: wget 설치
...</p></div><footer class=entry-footer><span title='2024-06-07 00:00:00 +0900 KST'>June 7, 2024</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to Homebrew, Formulae와 Cask의 차이점" href=https://cdecl.github.io/devops/homebrew-formulae-cask/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>TLS와 SSH 프로토콜 기능</h2></header><div class=entry-content><p>TLS와 SSH 프로토콜의 서버-클라이언트 협상 항목과 기능 비교
TLS와 SSH 프로토콜 정의 1. TLS(Transport Layer Security) TLS 프로토콜은 인터넷 상에서 안전한 통신을 위해 사용되는 암호화 프로토콜입니다. TLS는 SSL(Secure Sockets Layer) 프로토콜의 후속 버전으로, 웹 브라우저와 웹 서버 사이의 통신을 암호화하여 데이터 보안을 강화하는데 사용됩니다.
TLS 프로토콜의 주요 기능 암호화: 클라이언트와 서버 간의 통신 내용을 암호화하여 보호 인증: 서버의 신원을 인증하고, 클라이언트 인증도 지원 무결성: 전송 데이터의 변조를 방지 TLS는 HTTP, SMTP, IMAP 등 다양한 프로토콜의 보안 계층으로 사용됩니다. TLS 1.0/1.1은 더 이상 권장되지 않으며, 현재는 TLS 1.2와 가장 최신 표준인 TLS 1.3이 널리 사용되고 있습니다. 특히 TLS 1.3은 이전 버전 대비 보안성과 성능이 크게 향상되었습니다.
...</p></div><footer class=entry-footer><span title='2024-04-06 00:00:00 +0900 KST'>April 6, 2024</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to TLS와 SSH 프로토콜 기능" href=https://cdecl.github.io/devops/tls-ssh-handshake/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>GNU C++로 정적 라이브러리 링크하는 방법</h2></header><div class=entry-content><p>GNU C++ 프로그램에서 정적 라이브러리를 링크하는 방법
정적 라이브러리 사용 사용 시 고려 사항 프로그램 크기 증가: 정적 라이브러리를 사용하면 실행 파일 크기가 크게 증가할 수 있슴 라이브러리 업데이트: 정적 라이브러리를 사용하면 라이브러리 업데이트 시 프로그램을 다시 컴파일해야 필요 사용 장점 운영 체제 의존성 감소: 정적 라이브러리를 사용하면 프로그램 실행에 필요한 모든 라이브러리가 실행 파일에 포함되어 있어 운영 체제에 동일한 라이브러리가 설치되어 있지 않아도 프로그램을 실행 보안 강화: 정적 라이브러리를 사용하면 공유 라이브러리 공격과 같은 보안 취약점에 대한 위험을 줄일 수 있음 성능 향상: 정적 라이브러리를 사용하면 프로그램 실행 속도를 향상시킬 수 있음 정적 라이브러리 링크 링크 옵션 -static C 런타임 라이브러리뿐만 아니라 모든 외부 라이브러리를 정적으로 링크합니다. 실행 파일에 모든 필요한 라이브러리 코드를 포함시킵니다. 결과적으로 실행 파일의 크기가 크게 증가할 수 있습니다. 시스템 라이브러리에 대한 의존성을 제거하여 이식성을 높입니다. -static-libstdc++ C++ 표준 라이브러리만 정적으로 링크합니다. 다른 시스템 라이브러리나 사용자 정의 라이브러리는 여전히 동적으로 링크될 수 있습니다. -static 옵션보다 실행 파일 크기 증가가 덜합니다. C++ ABI 호환성 문제를 해결하는 데 유용할 수 있습니다. g++ -static main.cpp -o myprogram 라이브러리 링크 지정 방법 -l 옵션 (일반적인 방법) 컴파일러에게 특정 라이브러리를 링크하도록 지시. 먼저 동적 라이브러리(.so 파일)를 찾습니다. 동적 라이브러리가 없으면 정적 라이브러리(.a 파일)를 찾습니다. 표준 라이브러리 경로(예: /usr/lib, /lib)와 -L 옵션으로 지정된 추가 경로에서 라이브러리를 찾습니다. 정적 라이브러리를 명시적으로 지정하려면, 전체 파일 경로를 사용할 수 있습니다. 예: g++ main.cpp /path/to/libmylib.a -o myprogram 뒤에 오는 라이브러리 이름은 관례에 따라 lib 접두사와 .a 확장자를 가진 정적 라이브러리 파일명 -static 옵션과 함께 사용 시 -static 옵션과 함께 -l을 사용하면, 링커는 오직 정적 라이브러리만을 찾습니다. 이 경우 정적 라이브러리가 없다면 링크 에러가 발생합니다. -Wl,–whole-archive 옵션 컴파일러에게 라이브러리에 있는 모든 객체 파일을 링크하도록 지시 이 옵션을 사용하면 라이브러리에 있는 모든 함수가 사용될 수 있음 주로 정적 라이브러리(.a)에 사용됩니다. 전역 객체의 생성자나 정적 초기화 함수가 반드시 링크되도록 보장합니다. 주요 차이점 : -l -Wl,–whole-archive -l은 선택적으로 필요한 부분만 링크하지만, –whole-archive는 라이브러리 전체를 링크합니다. -l은 동적/정적 라이브러리 모두에 사용 가능하지만, –whole-archive는 주로 정적 라이브러리에 사용됩니다. –whole-archive를 사용하면 실행 파일 크기가 더 커질 수 있습니다. -Wl,–whole-archive는 플러그인 시스템이나 동적으로 로드되는 모듈을 구현할 때 특히 유용할 수 있습니다 g++ main.cpp -lstdc++ -Wl,--whole-archive my_lib.a -o myprogram 의존성 확인 실행 파일의 의존성을 확인하는 것은 프로그램이 어떤 라이브러리에 의존하고 있는지 파악하는 데 중요합니다. 이를 통해 정적 링킹이 제대로 되었는지, 혹은 동적 라이브러리에 대한 의존성이 있는지 확인할 수 있습니다.
...</p></div><footer class=entry-footer><span title='2024-02-25 00:00:00 +0900 KST'>February 25, 2024</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to GNU C++로 정적 라이브러리 링크하는 방법" href=https://cdecl.github.io/dev/g++-static/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>유니코드 NFD to NFC 변환</h2></header><div class=entry-content><p>유니코드 NFD 문자열을 NFC 문자열로 변환하는 방법을 Python 스크립트와 nfd2c 툴을 활용하여 설명합니다.
이 글은 macOS 및 다양한 운영 체제에서 유니코드 호환성을 유지하기 위해 NFD와 NFC 간 변환이 필요한 상황에 유용합니다.
NFD와 NFC 유니코드는 다양한 언어와 문자를 일관되게 표현하기 위한 국제 표준입니다. 하지만 동일한 문자라도 운영 체제나 시스템에 따라 다른 유니코드 정규화 방식(NFD, NFC)으로 저장되거나 처리될 수 있습니다.
이는 파일 시스템, 데이터베이스, 문자열 비교 등에서 예상치 못한 문제를 일으킬 수 있습니다.
...</p></div><footer class=entry-footer><span title='2024-02-06 00:00:00 +0900 KST'>February 6, 2024</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to 유니코드 NFD to NFC 변환" href=https://cdecl.github.io/devops/nfd-to-nfc/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Ollama를 이용한 Mistral 로컬 실행 가이드</h2></header><div class=entry-content><p>ollama, ollama-webui, mistral 설치 및 테스트
Ollama OLLAMA는 Open Large Language Model for AI Applications의 약자로, Google AI에서 개발한 대규모 언어 모델 (LLM)입니다. OLLAMA는 텍스트 생성, 번역, 질문 응답 등 다양한 AI 애플리케이션 개발을 위해 사용할 수 있는 강력한 도구
다양한 기능: OLLAMA는 텍스트 생성, 번역, 질문 응답, 요약, 코드 생성 등 다양한 기능을 제공합니다. 강력한 성능: OLLAMA는 Google AI의 최첨단 기술을 기반으로 개발되어 강력한 성능을 제공합니다. 쉬운 사용: OLLAMA는 Python API를 제공하여 쉽게 사용할 수 있습니다. 다양한 모델: OLLAMA는 다양한 크기와 기능을 가진 모델을 제공하여 사용자의 필요에 맞게 선택할 수 있습니다. Ollama 설치 다운로드 : https://ollama.ai/download{:target="_blank"} 설치 및 활용 가능한 모델 : https://ollama.ai/library{:target="_blank"} $ ollama Usage: ollama [flags] ollama [command] Available Commands: serve Start ollama create Create a model from a Modelfile show Show information for a model run Run a model pull Pull a model from a registry push Push a model to a registry list List models cp Copy a model rm Remove a model help Help about any command Flags: -h, --help help for ollama -v, --version Show version information Use "ollama [command] --help" for more information about a command. mistral 모델 설치 https://ollama.ai/library/mistral{:target="_blank"} Mistral은 최근에 개발된 대형 언어 모델 중 하나입니다. 이 모델은 7.3 billion 개의 파라미터를 가지고 있으며, 자연어 처리 분야에서 매우 높은 성능을 보입니다. Mistral은 다양한 자연어 처리 작업에서 사용될 수 있습니다. 예를 들어, 이 모델은 텍스트 생성, 기계 번역, 질문 응답, 감성 분석 등의 작업에 사용될 수 있습니다.
...</p></div><footer class=entry-footer><span title='2024-01-27 00:00:00 +0900 KST'>January 27, 2024</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to Ollama를 이용한 Mistral 로컬 실행 가이드" href=https://cdecl.github.io/devops/ollama-mistral/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>DuckDB, CSV에서 MySQL로의 ETL</h2></header><div class=entry-content><p>DuckDB를 ETL 도구로 활용 : CSV 데이터 → MySQL
DuckDB를 통한 CSV 데이터를 MySQL로 ETL 하는 방법 ETL이란? ETL이란 Extract, Transform, Load의 약자로, 데이터를 다양한 소스에서 추출하고 변환하고 적재하는 과정 ETL을 수행하기 위해서는 여러가지 툴을 사용할 수 있는데 그 중 하나 DuckDB 활용하는 안 DuckDB DuckDB는 분석 쿼리에 최적화된 임베디드 데이터베이스 DuckDB는 PostgreSQL과 호환되는 SQL 문법을 사용하고, 여러 DB와 연결하여 데이터를 효율적으로 가져와 로컬 DuckDB에서 데이터 처리 가능 Extensions : https://duckdb.org/docs/extensions/overview ETL 예제 DuckDB에서 CSV 파일을 읽어와 테이블 생성 MySQL Extension{:target="_blank"} CREATE TABLE csv_table AS SELECT * FROM read_csv_auto('your_csv_file'); DuckDB에서 MySQL에 연결합니다. 다음과 같은 명령어를 사용할 수 있습니다. INSTALL MySQL; LOAD MySQL; ATTACH 'host=localhost user=root port=0 database=etldb' AS mysqldb (TYPE mysql) USE mysqldb; DuckDB에서 MySQL로 데이터를 적재합니다. 다음과 같은 명령어를 사용할 수 있습니다. CREATE TABLE mysqldb.etldb.csvtbl AS SELECT * FROM csv_table; 참고 MySQL LOAD DATA{:target="_blank"} CSV to SQLite3{:target="_blank"}</p></div><footer class=entry-footer><span title='2024-01-25 00:00:00 +0900 KST'>January 25, 2024</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to DuckDB, CSV에서 MySQL로의 ETL" href=https://cdecl.github.io/devops/etl-csv-to-mysql/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://cdecl.github.io/page/6/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://cdecl.github.io/page/8/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2026 <a href=https://cdecl.github.io/>cdeclog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>