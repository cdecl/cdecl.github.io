<!doctype html><html lang=en dir=auto data-theme=auto><head><meta name=generator content="Hugo 0.154.5"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>cdeclog</title><meta name=description content="cdecl's Development Blog - Dev, DevOps, Etc."><meta name=author content="Byung Kyu KIM"><link rel=canonical href=https://cdecl.github.io/><link crossorigin=anonymous href=/assets/css/stylesheet.d980bb9fb2cba61af0aead0606b5eb221d7e358748ac394b60233d95d626c563.css integrity="sha256-2YC7n7LLphrwrq0GBrXrIh1+NYdIrDlLYCM9ldYmxWM=" rel="preload stylesheet" as=style><link rel=icon href=https://cdecl.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://cdecl.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://cdecl.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://cdecl.github.io/apple-touch-icon.png><link rel=mask-icon href=https://cdecl.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://cdecl.github.io/index.xml title=rss><link rel=alternate type=application/json href=https://cdecl.github.io/index.json title=json><link rel=alternate hreflang=en href=https://cdecl.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-VQQHHYPN7K"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VQQHHYPN7K")}</script><meta property="og:url" content="https://cdecl.github.io/"><meta property="og:site_name" content="cdeclog"><meta property="og:title" content="cdeclog"><meta property="og:description" content="cdecl's Development Blog - Dev, DevOps, Etc."><meta property="og:locale" content="ko-kr"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="cdeclog"><meta name=twitter:description content="cdecl's Development Blog - Dev, DevOps, Etc."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"cdeclog","url":"https://cdecl.github.io/","description":"cdecl's Development Blog - Dev, DevOps, Etc.","logo":"https://cdecl.github.io/favicon.ico","sameAs":["https://github.com/cdecl","https://cdecl.tistory.com/"]}</script></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://cdecl.github.io/ accesskey=h title="cdeclog (Alt + H)">cdeclog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://cdecl.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://cdecl.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://cdecl.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>리눅스의 Init 시스템</h2></header><div class=entry-content><p>리눅스의 Init 시스템: System V Init와 Systemd 비교 분석 및 docker 활용
개요 리눅스 시스템에서 운영체제 부팅 시 초기화를 담당하는 프로그램을 init 시스템이라고 합니다.
전통적인 System V Init와 현대적인 Systemd를 비교 분석하여, 시스템 초기화 방식의 발전과 실무적 영향을 살펴보겠습니다.
System V Init와 Systemd의 역사적 배경 System V Init 1983년 Unix System V에서 처음 도입된 init 시스템으로, 당시 컴퓨팅 환경의 단순함에 맞춰 설계되었습니다. 이 시스템은 주로 서버와 메인프레임에서 사용되었으며, 런레벨 기반의 단순한 상태 전환을 제공했습니다.
...</p></div><footer class=entry-footer><span title='2024-11-03 00:00:00 +0900 KST'>November 3, 2024</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to 리눅스의 Init 시스템" href=https://cdecl.github.io/devops/systemv-systemd/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>xargs - 효율적인 명령어 인수 처리와 병렬 실행</h2></header><div class=entry-content><p>xargs - 효율적인 명령어 인수 처리와 병렬 실행
xargs 명령어: 효율적인 명령어 확장과 파라미터 전달 xargs 명령어는 한 명령어의 출력을 다른 명령어의 인수로 전달할 때 유용하게 사용됩니다. 특히 명령어의 파라미터가 길어지거나 여러 파일, 디렉토리를 대상으로 명령어를 실행해야 할 때 xargs를 사용하면 성능과 효율성을 높일 수 있습니다.
주요 옵션과 활용 예시 1. 기본 사용법 xargs는 기본적으로 표준 입력에서 받은 데이터를 공백 또는 개행으로 구분하여 후속 명령어의 인수로 전달합니다.
예시:
echo "file1 file2 file3" | xargs ls -l file1, file2, file3을 ls -l의 인수로 전달하여 파일의 상세 정보를 출력합니다.
...</p></div><footer class=entry-footer><span title='2024-10-27 00:00:00 +0900 KST'>October 27, 2024</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to xargs - 효율적인 명령어 인수 처리와 병렬 실행" href=https://cdecl.github.io/devops/xargs-command-guide/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>sed - pattern capture substitute 활용</h2></header><div class=entry-content><p>sed 명령어: 텍스트 패턴 캡처와 치환 활용법
sed는 파일이나 텍스트 스트림의 내용에서 특정 패턴을 찾아 변경하는 데 유용한 **스트림 편집기(Stream Editor)**입니다.
특히 정규 표현식 기능을 통해 텍스트의 특정 부분을 캡처하고 치환하는 기능이 강력합니다.
이번 글에서는 -E 및 -r 옵션을 사용하여 더 간편하게 캡처 그룹을 생성하고 치환하는 방법을 소개하겠습니다.
1. sed 명령어 정의 및 용도 sed는 파일이나 텍스트를 자동으로 조작하는 명령어로, 주로 Linux 및 Unix 환경에서 사용됩니다.
sed는 스크립트 없이도 다양한 텍스트 처리 작업을 쉽게 수행할 수 있는 장점이 있으며, 주요 용도는 다음과 같습니다:
...</p></div><footer class=entry-footer><span title='2024-10-25 00:00:00 +0900 KST'>October 25, 2024</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to sed - pattern capture substitute 활용" href=https://cdecl.github.io/devops/sed-capture-replace/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>ARP 스푸핑, arpspoof와 fragrouter 사용법 원리</h2></header><div class=entry-content><p>네트워크 보안 툴 arpspoof와 fragrouter 사용법 및 ARP 스푸핑 원리
1. ARP (주소 결정 프로토콜)란? 1. 정의 ARP`(Address Resolution Pro 이를 통해 로컬 네트워크에서 IP 패킷이 올바른 물리적 네트워크 장치로 전달될 수 있습니다.
2. 작동 원리 ARP는 다음과 같은 과정으로 작동합니다:
ARP 요청 (Request) 송신 호스트가 목적지 호스트의 MAC 주소를 모를 때, ARP 요청 패킷을 브로드캐스트로 네트워크에 전송합니다. 이 요청 패킷에는 송신 호스트의 IP 주소와 MAC 주소, 그리고 목적지 호스트의 IP 주소가 포함되어 있습니다. ARP 응답 (Reply) 네트워크에 있는 모든 호스트가 이 ARP 요청을 수신합니다. 요청된 IP 주소를 가진 호스트는 자신의 MAC 주소를 포함한 ARP 응답 패킷을 송신 호스트에게 유니캐스트로 전송합니다. 주소 매핑 송신 호스트는 ARP 응답을 수신하고, 해당 IP 주소와 MAC 주소의 매핑을 ARP 캐시(테이블)에 저장합니다. 이후 동일한 IP 주소로의 통신이 발생할 때, ARP 캐시를 참조하여 MAC 주소를 빠르게 확인할 수 있습니다. 3. ARP 캐시 ARP 캐시는 IP 주소와 MAC 주소의 매핑을 일시적으로 저장하는 테이블입니다.
이를 통해 같은 IP 주소에 대한 반복적인 ARP 요청을 방지하고, 네트워크 성능을 향상시킬 수 있습니다.
그러나 ARP 캐시는 보통 일정 시간이 지나면 항목이 만료됩니다.
...</p></div><footer class=entry-footer><span title='2024-06-26 00:00:00 +0900 KST'>June 26, 2024</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to ARP 스푸핑, arpspoof와 fragrouter 사용법 원리" href=https://cdecl.github.io/devops/arpspoof-fragrouter/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Docker 네트워크 - Macvlan</h2></header><div class=entry-content><p>Docker Macvlan 네트워크 소개, 활용 및 이슈
1. Docker Macvlan 네트워크? Macvlan 네트워크는 컨테이너에 독립적인 네트워크 인터페이스를 제공하여 물리적 네트워크와 직접 상호작용 가능
이는 각 컨테이너가 고유한 MAC 주소를 가지므로 네트워크 수준에서 완전히 독립된 호스트처럼 동작 가능
호스트 머신과 같은 네트워크에 docker 컨테이너를 생성 목적
Macvlan 네트워크 설정은 물리적 네트워크 환경에 따라 적절한 서브넷과 게이트웨이를 사용 필요 (e.g. DHCP 환경)
Macvlan 구성 네트워크 성능 향상: 호스트의 NAT를 거치지 않아 성능이 향상 네트워크 격리: 각 컨테이너가 고유한 MAC 주소를 가져 네트워크 레벨에서 완전히 격리 기존 네트워크와의 통합: 기존 물리적 네트워크 인프라와 쉽게 통합 Docker 네트워크 유형 브리지 네트워크 (Bridge Network) 기본 네트워크 모드로, Docker가 기본적으로 사용하는 네트워크입니다. 내부 네트워크를 생성하여 컨테이너 간의 통신을 가능하게 합니다. 호스트와 컨테이너 간의 통신은 NAT(Network Address Translation)를 사용합니다. 호스트 네트워크 (Host Network) 컨테이너가 호스트의 네트워크 스택을 공유합니다. 성능이 중요한 애플리케이션에서 사용될 수 있습니다. 컨테이너와 호스트 간의 네트워크 격리가 없습니다. None 네트워크 (None Network) 네트워크 연결이 없는 컨테이너를 생성합니다. 네트워크 격리가 필요한 경우에 유용합니다. 2. Macvlan 네트워크 설정 설치 요구 사항 Docker가 설치된 시스템, 루트 권한 또는 Docker 관리 권한
...</p></div><footer class=entry-footer><span title='2024-06-25 00:00:00 +0900 KST'>June 25, 2024</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to Docker 네트워크 - Macvlan" href=https://cdecl.github.io/devops/docker-macvlan/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Nmap vs. Netcat</h2></header><div class=entry-content><p>Nmap vs. nc (Network Mapper vs. Netcat) 네트워크 스캐닝 도구로서 비교
Nmap vs. nc (Netcat): 네트워크 스캐닝 도구 비교 Nmap (Network Mapper) 네트워크 스캐닝 및 보안 평가 도구로, 대규모 네트워크에서 호스트, 서비스, 오픈 포트를 탐지하는 데 사용
네트워크 호스트, 서비스, 오픈 포트 스캐닝, 운영 체제 감지, 버전 감지, 서비스 식별 등 다양한 네트워크 탐지 및 보안 평가 기능
옵션 설명 예제 -p 특정 포트를 스캔합니다 nmap -p 80,443 192.168.1.100 -p- 모든 포트를 스캔합니다 nmap -p- 192.168.1.100 -sV 서비스 버전을 탐지합니다 nmap -sV 192.168.1.100 -O 운영 체제를 탐지합니다 nmap -O 192.168.1.100 -sS TCP SYN 스캔을 수행합니다 nmap -sS 192.168.1.100 -sU UDP 포트를 스캔합니다 nmap -sU 192.168.1.100 -T4 스캔 속도를 높입니다 nmap -T4 192.168.1.100 -A 공격적 스캔을 수행합니다 (OS, 서비스 탐지) nmap -A 192.168.1.100 -oN 스캔 결과를 일반 텍스트 파일로 저장합니다 nmap -oN scan_results.txt 192.168.1.100 -oX 스캔 결과를 XML 파일로 저장합니다 nmap -oX scan_results.xml 192.168.1.100 -oG 스캔 결과를 그레프블(grepable) 형식으로 저장합니다 nmap -oG scan_results.gnmap 192.168.1.100 -oA 모든 형식으로 스캔 결과를 저장합니다 (N, X, G 파일) nmap -oA scan_results 192.168.1.100 -v 스캔 중 자세한 출력을 제공합니다 nmap -v 192.168.1.100 -vv 매우 자세한 출력을 제공합니다 nmap -vv 192.168.1.100 -Pn 호스트가 응답하지 않더라도 스캔을 수행합니다 nmap -Pn 192.168.1.100 --open 열린 포트만 출력합니다 nmap --open 192.168.1.100 --reason 포트 상태 결정의 이유를 출력합니다 nmap --reason 192.168.1.100 --script NSE(Nmap Scripting Engine) 스크립트를 실행합니다 nmap --script default 192.168.1.100 --exclude 특정 IP 주소를 제외하고 스캔합니다 nmap -sn 192.168.1.0/24 --exclude 192.168.1.1 --max-retries 재시도 횟수를 지정합니다 nmap --max-retries 2 192.168.1.100 nc (Netcat) 네트워크 연결 도구로, TCP/IP 소켓을 직접 다루는 데 사용되며, 데이터 전송, 포트 스캐닝, 포트 열기 및 메시지 전송 등의 작업을 수행할 수 있음
...</p></div><footer class=entry-footer><span title='2024-06-17 00:00:00 +0900 KST'>June 17, 2024</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to Nmap vs. Netcat" href=https://cdecl.github.io/devops/nmap-nc/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Homebrew, Formulae와 Cask의 차이점</h2></header><div class=entry-content><p>Homebrew는 macOS와 Linux에서 소프트웨어를 쉽게 설치하고 관리할 수 있는 패키지 관리자.
Homebrew https://brew.sh/{:target="_blank"} Homebrew는 macOS와 Linux에서 소프트웨어 패키지를 간편하게 설치하고 관리할 수 있는 패키지 관리자 Homebrew에는 두 가지 주요 설치 방법인 Formulae와 Cask가 있습니다. Formulae와 Cask의 차이점과 동일한 애플리케이션이 두 가지 방법으로 제공되는 예시를 설명 Homebrew 설치 macOS $ brew --version # 설치 확인 Linux $ eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)" $ brew --version # 설치 확인 Homebrew 주요 명령어 Formulae 설치 (CLI 애플리케이션) brew install &lt;package-name> 예: wget 설치
...</p></div><footer class=entry-footer><span title='2024-06-07 00:00:00 +0900 KST'>June 7, 2024</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to Homebrew, Formulae와 Cask의 차이점" href=https://cdecl.github.io/devops/homebrew-formulae-cask/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>TLS와 SSH 프로토콜 기능</h2></header><div class=entry-content><p>TLS와 SSH 프로토콜의 서버-클라이언트 협상 항목과 기능 비교
TLS와 SSH 프로토콜 정의 1. TLS(Transport Layer Security) TLS 프로토콜은 인터넷 상에서 안전한 통신을 위해 사용되는 암호화 프로토콜입니다. TLS는 SSL(Secure Sockets Layer) 프로토콜의 후속 버전으로, 웹 브라우저와 웹 서버 사이의 통신을 암호화하여 데이터 보안을 강화하는데 사용됩니다.
TLS 프로토콜의 주요 기능 암호화: 클라이언트와 서버 간의 통신 내용을 암호화하여 보호 인증: 서버의 신원을 인증하고, 클라이언트 인증도 지원 무결성: 전송 데이터의 변조를 방지 TLS는 HTTP, SMTP, IMAP 등 다양한 프로토콜의 보안 계층으로 사용됩니다. TLS 1.0/1.1은 더 이상 권장되지 않으며, 현재는 TLS 1.2와 가장 최신 표준인 TLS 1.3이 널리 사용되고 있습니다. 특히 TLS 1.3은 이전 버전 대비 보안성과 성능이 크게 향상되었습니다.
...</p></div><footer class=entry-footer><span title='2024-04-06 00:00:00 +0900 KST'>April 6, 2024</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to TLS와 SSH 프로토콜 기능" href=https://cdecl.github.io/devops/tls-ssh-handshake/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>유니코드 NFD to NFC 변환</h2></header><div class=entry-content><p>유니코드 NFD 문자열을 NFC 문자열로 변환하는 방법을 Python 스크립트와 nfd2c 툴을 활용하여 설명합니다.
이 글은 macOS 및 다양한 운영 체제에서 유니코드 호환성을 유지하기 위해 NFD와 NFC 간 변환이 필요한 상황에 유용합니다.
NFD와 NFC 유니코드는 다양한 언어와 문자를 일관되게 표현하기 위한 국제 표준입니다. 하지만 동일한 문자라도 운영 체제나 시스템에 따라 다른 유니코드 정규화 방식(NFD, NFC)으로 저장되거나 처리될 수 있습니다.
이는 파일 시스템, 데이터베이스, 문자열 비교 등에서 예상치 못한 문제를 일으킬 수 있습니다.
...</p></div><footer class=entry-footer><span title='2024-02-06 00:00:00 +0900 KST'>February 6, 2024</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to 유니코드 NFD to NFC 변환" href=https://cdecl.github.io/devops/nfd-to-nfc/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Ollama를 이용한 Mistral 로컬 실행 가이드</h2></header><div class=entry-content><p>ollama, ollama-webui, mistral 설치 및 테스트
Ollama OLLAMA는 Open Large Language Model for AI Applications의 약자로, Google AI에서 개발한 대규모 언어 모델 (LLM)입니다. OLLAMA는 텍스트 생성, 번역, 질문 응답 등 다양한 AI 애플리케이션 개발을 위해 사용할 수 있는 강력한 도구
다양한 기능: OLLAMA는 텍스트 생성, 번역, 질문 응답, 요약, 코드 생성 등 다양한 기능을 제공합니다. 강력한 성능: OLLAMA는 Google AI의 최첨단 기술을 기반으로 개발되어 강력한 성능을 제공합니다. 쉬운 사용: OLLAMA는 Python API를 제공하여 쉽게 사용할 수 있습니다. 다양한 모델: OLLAMA는 다양한 크기와 기능을 가진 모델을 제공하여 사용자의 필요에 맞게 선택할 수 있습니다. Ollama 설치 다운로드 : https://ollama.ai/download{:target="_blank"} 설치 및 활용 가능한 모델 : https://ollama.ai/library{:target="_blank"} $ ollama Usage: ollama [flags] ollama [command] Available Commands: serve Start ollama create Create a model from a Modelfile show Show information for a model run Run a model pull Pull a model from a registry push Push a model to a registry list List models cp Copy a model rm Remove a model help Help about any command Flags: -h, --help help for ollama -v, --version Show version information Use "ollama [command] --help" for more information about a command. mistral 모델 설치 https://ollama.ai/library/mistral{:target="_blank"} Mistral은 최근에 개발된 대형 언어 모델 중 하나입니다. 이 모델은 7.3 billion 개의 파라미터를 가지고 있으며, 자연어 처리 분야에서 매우 높은 성능을 보입니다. Mistral은 다양한 자연어 처리 작업에서 사용될 수 있습니다. 예를 들어, 이 모델은 텍스트 생성, 기계 번역, 질문 응답, 감성 분석 등의 작업에 사용될 수 있습니다.
...</p></div><footer class=entry-footer><span title='2024-01-27 00:00:00 +0900 KST'>January 27, 2024</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to Ollama를 이용한 Mistral 로컬 실행 가이드" href=https://cdecl.github.io/devops/ollama-mistral/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://cdecl.github.io/page/3/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://cdecl.github.io/page/5/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2026 <a href=https://cdecl.github.io/>cdeclog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>