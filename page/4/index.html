<!doctype html><html lang=en dir=auto data-theme=auto><head><meta name=generator content="Hugo 0.154.5"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>cdeclog</title><meta name=description content="cdecl's Dev.Ops Blog"><meta name=author content="Byung Kyu KIM"><link rel=canonical href=https://cdecl.github.io/><link crossorigin=anonymous href=/assets/css/stylesheet.f939c4ffefb264e6fe85e04352266f79db6bb1303c8e16ae9b6064c1247b5e32.css integrity="sha256-+TnE/++yZOb+heBDUiZvedtrsTA8jhaum2BkwSR7XjI=" rel="preload stylesheet" as=style><link rel=icon href=https://cdecl.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://cdecl.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://cdecl.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://cdecl.github.io/apple-touch-icon.png><link rel=mask-icon href=https://cdecl.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://cdecl.github.io/index.xml title=rss><link rel=alternate type=application/json href=https://cdecl.github.io/index.json title=json><link rel=alternate hreflang=en href=https://cdecl.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-VQQHHYPN7K"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VQQHHYPN7K")}</script><meta property="og:url" content="https://cdecl.github.io/"><meta property="og:site_name" content="cdeclog"><meta property="og:title" content="cdeclog"><meta property="og:description" content="cdecl's Dev.Ops Blog"><meta property="og:locale" content="ko-kr"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="cdeclog"><meta name=twitter:description content="cdecl's Dev.Ops Blog"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"cdeclog","url":"https://cdecl.github.io/","description":"cdecl's Dev.Ops Blog","logo":"https://cdecl.github.io/favicon.ico","sameAs":["https://github.com/cdecl","https://cdecl.tistory.com/"]}</script></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://cdecl.github.io/ accesskey=h title="cdeclog (Alt + H)">cdeclog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://cdecl.github.io/dev/ title=Dev><span>Dev</span></a></li><li><a href=https://cdecl.github.io/devops/ title=DevOps><span>DevOps</span></a></li><li><a href=https://cdecl.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://cdecl.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://cdecl.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>구글의 AI 코딩 어시스턴트, Gemini CLI 사용 가이드</h2></header><div class=entry-content><p>Gemini CLI의 핵심 개념, 주요 기능, 설치 및 구성 방법, 그리고 다른 AI 코딩 도우미와의 비교를 통해 Gemini CLI를 효과적으로 활용하는 방법을 알아봅니다.
Gemini CLI란? Gemini CLI는 구글에서 개발한 대화형 AI 코딩 어시스턴트로, 터미널 환경에서 직접 작동합니다. 개발자는 자연어 명령을 통해 복잡한 개발 작업을 Gemini에게 위임할 수 있습니다. 파일 시스템 조작, 코드 리팩토링, 셸 명령어 실행, Git 버전 관리 등 다양한 작업을 자동화하여 개발 생산성을 크게 향상시킵니다. 이 포스트에서는 Gemini CLI의 핵심 철학, 주요 기능, 설치 및 구성, 그리고 GitHub Copilot CLI와의 비교를 통해 그 차이점을 명확히 설명합니다.
...</p></div><footer class=entry-footer><span title='2025-07-08 00:00:00 +0900 KST'>July 8, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to 구글의 AI 코딩 어시스턴트, Gemini CLI 사용 가이드" href=https://cdecl.github.io/devops/gemini_cli/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>오픈소스 AI 코딩 어시스턴트, Cline 사용 가이드</h2></header><div class=entry-content><p>Cline의 핵심 개념, 역할, 지원 AI 모델, 설치 및 구성 방법, 그리고 유용한 기능들을 상세히 소개합니다.
Cline이란? Cline은 Visual Studio Code(VS Code)와 통합된 오픈소스 AI 코딩 어시스턴트로, 복잡한 소프트웨어 개발 작업을 자동화하고 생산성을 극대화합니다. Claude 3.7 Sonnet, DeepSeek, Google Gemini 등 다양한 대형 언어 모델(LLM)을 활용하여 코드 작성, 디버깅, 리팩토링, 터미널 명령 실행 등을 지원합니다. 이 포스트에서는 Cline의 정의, 역할, 지원 AI 모델, 설치 및 구성 방법, 그리고 개발자를 위한 유용한 기능들을 자세히 다룹니다.
...</p></div><footer class=entry-footer><span title='2025-07-07 00:00:00 +0900 KST'>July 7, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to 오픈소스 AI 코딩 어시스턴트, Cline 사용 가이드" href=https://cdecl.github.io/devops/cline_usage_guide/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Tailscale 가이드 - 안전한 매쉬 VPN 활용법</h2></header><div class=entry-content><p>Tailscale의 핵심 개념, VPN 정의, 동작 방식, 설치 및 구성 방법, 엔드포인트 관리, 포트 제어, 다른 단말 접속, 그리고 보안 설정 방법
Tailscale이란? Tailscale은 WireGuard 프로토콜을 기반으로 한 현대적인 매쉬 VPN 솔루션으로, 복잡한 네트워크 설정 없이 장치 간 안전하고 빠른 연결을 제공합니다. 개인, 팀, 또는 기업의 장치를 연결하여 로컬 네트워크, 원격 서버, 모바일 장치를 쉽게 관리할 수 있습니다. 이 포스트에서는 Tailscale의 핵심 개념, VPN 정의와 매쉬 VPN 동작 방식, 설치 및 구성, 엔드포인트 확인, 포트 제어, 다른 단말 접속, 그리고 보안 설정을 자세히 다룹니다.
...</p></div><footer class=entry-footer><span title='2025-07-05 00:00:00 +0900 KST'>July 5, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to Tailscale 가이드 - 안전한 매쉬 VPN 활용법" href=https://cdecl.github.io/devops/tailscale-guide/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Obsidian 101 - 강력한 노트 관리 도구 활용법</h2></header><div class=entry-content><p>Obsidian의 주요 기능과 설정, 테마와 외관, 그리고 필수 커뮤니티 플러그인을 활용한 생산성 향상 방법
Obsidian이란? Obsidian은 마크다운 기반의 강력한 노트 관리 및 지식 관리 도구로, 로컬 파일을 활용해 개인 지식 베이스를 구축하는 데 최적화되어 있습니다. 링크를 통한 노트 간 연결, 그래프 뷰, 플러그인 생태계를 통해 유연한 워크플로우를 제공합니다. 이번 포스트에서는 Obsidian의 주요 기능, 설정, 테마와 외관, 그리고 생산성을 극대화할 수 있는 커뮤니티 플러그인(예: Tasks, Advanced Tables, Git 등)을 자세히 다룹니다.
...</p></div><footer class=entry-footer><span title='2025-07-04 00:00:00 +0900 KST'>July 4, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to Obsidian 101 - 강력한 노트 관리 도구 활용법" href=https://cdecl.github.io/devops/obsidian-101/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>정규식의 멀티라인 expressions 활용</h2></header><div class=entry-content><p>멀티라인 표현식의 활용법, Dotall (Single Line) 모드, Multi Line 모드, Non-Dotall 모드의 차이점, 여러 줄을 처리하는 방법
정규식의 멀티라인 표현식이란? 정규식(Regular Expression, Regex)은 텍스트 패턴을 검색하거나 조작할 때 강력한 도구로 사용됩니다. 특히 멀티라인 표현식은 여러 줄에 걸친 텍스트를 처리할 때 유용하며, 줄바꿈(\n)을 포함한 패턴 매칭을 가능하게 합니다. 이번 포스트에서는 멀티라인 표현식의 활용법, Dotall (Single Line) 모드, Multi Line 모드, Non-Dotall 모드의 차이점, 여러 줄을 처리하는 방법, 그리고 특정 패턴(예: start로 시작하고 end로 끝나는 패턴) 매칭 방법 등을 다룹니다. 또한, /s, /S, /w, /W, .|\n의 모드별 동작 차이를 설명합니다.
...</p></div><footer class=entry-footer><span title='2025-07-01 00:00:00 +0900 KST'>July 1, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to 정규식의 멀티라인 expressions 활용" href=https://cdecl.github.io/devops/regex-multiline/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>MCP-SuperAssistant 사용법</h2></header><div class=entry-content><p>Model Context Pro **Model Context Pro
MCP-SuperAssistant란? MCP-SuperAssistant는 MCP를 활용해 AI 플랫폼(ChatGPT, Perplexity, Google Gemini, Grok 등)과 외부 데이터 및 도구를 연결하는 크롬 확장 프로그램입니다. 이 도구는 AI 대화 내에서 MCP 도구 호출을 감지하고, 실행 결과를 자동 또는 수동으로 대화에 삽입하여 워크플로우를 간소화합니다. MCP-SuperAssistant는 다양한 AI 플랫폼과의 호환성과 유연한 설정을 통해 개발자와 비즈니스 사용자의 생산성을 극대화합니다.
MCP-SuperAssistant의 주요 기능 MCP-SuperAssistant는 다음과 같은 기능을 제공합니다:
다양한 AI 플랫폼 지원: ChatGPT, Perplexity, Google Gemini, Grok, Google AI Studio, OpenRouter, DeepSeek 등에서 MCP 도구 실행 가능 MCP 도구 실행 및 결과 삽입: AI 대화 내 도구 호출을 감지해 실행하고 결과를 대화에 삽입 실시간 데이터 연결: MCP를 통해 콘텐츠 저장소, 비즈니스 앱, 개발 환경 등과 안전하게 연결 자동/수동 모드: 자동 모드(도구 실행 및 결과 제출 자동화)와 수동 모드(사용자 제어) 지원 확장성과 모듈성: 플러그인 기반 아키텍처로 새로운 플랫폼 및 도구 추가 가능, WebSocket 및 SSE 지원 보안 및 접근성: 복잡한 API 키 설정 없이 기존 AI 구독 활용, 최소 설정으로 사용 가능 6000+ MCP 서버 지원: 다양한 MCP 서버와 통합해 AI 워크플로우 강화 특징: 확장 프로그램은 간단한 설치로 즉시 사용 가능하며, 샌드박스 환경에서 실행되어 보안성을 유지합니다. 제약사항: 일부 복잡한 도구 호출은 MCP 서버 설정이 필요하며, AI 모델의 프롬프트 이해도에 따라 결과 정확도가 달라질 수 있습니다. 초기 설치 및 세팅, 실행 준비 MCP-SuperAssistant를 사용하려면 크롬 확장 프로그램 설치와 MCP 프록시 서버 설정이 필요합니다. 아래는 단계별 설치 및 실행 준비 과정입니다.
...</p></div><footer class=entry-footer><span title='2025-06-24 00:00:00 +0900 KST'>June 24, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to MCP-SuperAssistant 사용법" href=https://cdecl.github.io/dev/superassistant/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Gemini CLI의 MCP(Model Context Pro</h2></header><div class=entry-content><p>Gemini CLI의 MCP(Model Context Pro
Model Context Pro **Model Context Pro
Gemini CLI와 MCP 지원 개요 Gemini CLI는 Google의 생성형 AI 모델인 Gemini를 터미널에서 활용할 수 있는 오픈소스 도구로, MCP를 통해 내장 및 외부 도구와의 통합을 지원합니다. MCP를 활용하면 Gemini CLI는 파일 시스템 작업, 웹 검색, 버전 관리 시스템(Git 등)과의 연동, 또는 사용자 정의 API와의 상호작용과 같은 다양한 기능을 수행할 수 있습니다. Gemini CLI는 MCP를 통해 모델의 컨텍스트를 확장하여 복잡한 작업을 처리하거나, 외부 시스템과의 실시간 데이터 교환을 가능하게 합니다.
...</p></div><footer class=entry-footer><span title='2025-06-23 00:00:00 +0900 KST'>June 23, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to Gemini CLI의 MCP(Model Context Pro" href=https://cdecl.github.io/dev/gemini-cli-mcp-101/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Gemini CLI 툴 소개</h2></header><div class=entry-content><p>Gemini CLI 툴: VSCode 플러그인과의 차이, 활용법, 실전 시나리오
Gemini CLI 이란? Gemini CLI는 Google의 생성형 AI 모델인 Gemini를 터미널 환경에서 직접 사용할 수 있도록 지원하는 커맨드라인 도구입니다. 이 도구를 활용하여 코드 생성, 요약, 번역, 문서화 등 다양한 AI 기능을 명령어 한 줄로 빠르게 수행할 수 있습니다. 특히, 별도의 통합 개발 환경(IDE) 없이도 쉘 스크립트, 자동화, 지속적 통합(CI)과 같은 다양한 환경에서 AI 기능을 활용할 수 있다는 점이 큰 특징입니다. Gemini CLI는 또한 **mcp(Model Context Pro
...</p></div><footer class=entry-footer><span title='2025-06-22 00:00:00 +0900 KST'>June 22, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to Gemini CLI 툴 소개" href=https://cdecl.github.io/dev/gemini-cli/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>정규식 탐색 기법 - 전방탐색, 부정형 전방탐색, 후방탐색, 부정형 후방탐색</h2></header><div class=entry-content><p>정규식 탐색 기법: 전방탐색과 후방탐색
정규식 탐색 기법 요약 정규식(Regular Expression)은 텍스트 패턴 매칭에 강력한 도구. **전방탐색(Lookahead)**과 **후방탐색(Lookbehind)**은 특정 조건을 만족하는 패턴을 찾되, 그 조건 자체는 결과에 포함시키지 않는 고급 기법 기법 문법 설명 전방탐색 (?=패턴) 패턴이 앞에 있을 때 매칭 부정형 전방탐색 (?!패턴) 패턴이 앞에 없을 때 매칭 후방탐색 (?&lt;=패턴) 패턴이 뒤에 있을 때 매칭 부정형 후방탐색 (?&lt;!패턴) 패턴이 뒤에 없을 때 매칭 왜 전방탐색과 후방탐색이 필요한가? 전방탐색과 후방탐색은 매칭 조건을 설정하지만, 해당 조건은 최종 결과에 포함되지 않습니다. 이는 URL, 로그, 텍스트 파싱에서 특정 패턴의 주변 정보만 필요할 때 유용합니다. 주요 장점:
...</p></div><footer class=entry-footer><span title='2025-06-20 00:00:00 +0900 KST'>June 20, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to 정규식 탐색 기법 - 전방탐색, 부정형 전방탐색, 후방탐색, 부정형 후방탐색" href=https://cdecl.github.io/dev/regex-lookahead/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>모던 쉘 명령어로 터미널 생산성 높이기</h2></header><div class=entry-content><p>모던 쉘 명령어: 전통적인 도구를 대체하는 강력한 대안
터미널은 개발자와 시스템 관리자의 핵심 도구입니다. 하지만 전통적인 쉘 명령어(grep, sed, find, cat, watch, top, du)는 속도, 가독성, 사용 편의성 면에서 한계가 있습니다. 2025년 기준, 이러한 명령어들을 대체하는 모던 대안들이 주목받고 있습니다. 이 포스트에서는 ripgrep, sd, fd, bat, hwatch, htop, dust를 전통 명령어와 비교하며 특징과 사용법을 소개합니다.
모던 쉘 명령어 요약 전통 명령어 모던 대안 주요 특징 설치 명령어 (Ubuntu/Debian) grep ripgrep (rg) 고속 검색, .gitignore 통합, 컬러 출력 sudo apt-get install ripgrep sed sd 간단한 치환 문법, 빠른 처리 sudo apt-get install sd find fd 직관적 검색, .gitignore 지원 sudo apt-get install fd-find cat bat 구문 강조, Git 통합, 페이징 sudo apt-get install bat watch hwatch 변경 강조, 로그 저장 sudo apt-get install hwatch top htop 컬러 UI, 프로세스 트리 뷰 sudo apt-get install htop du dust 트리 구조, 직관적 시각화 sudo apt-get install dust 왜 모던 쉘 명령어가 필요한가? 모던 쉘 명령어는 Rust, Go 같은 현대 언어로 작성되어 속도와 효율성이 뛰어나며, 사용자 친화적인 인터페이스를 제공합니다. 주요 장점은 다음과 같습니다:
...</p></div><footer class=entry-footer><span title='2025-05-25 00:00:00 +0900 KST'>May 25, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to 모던 쉘 명령어로 터미널 생산성 높이기" href=https://cdecl.github.io/devops/moden-shell-command/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://cdecl.github.io/page/3/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://cdecl.github.io/page/5/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2026 <a href=https://cdecl.github.io/>cdeclog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>