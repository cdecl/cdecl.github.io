<!doctype html><html lang=en dir=auto data-theme=auto><head><meta name=generator content="Hugo 0.155.3"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>cdeclog</title><meta name=description content="cdecl's Dev.Ops Blog"><meta name=author content="Byung Kyu KIM"><link rel=canonical href=https://cdecl.github.io/><link crossorigin=anonymous href=/assets/css/stylesheet.f939c4ffefb264e6fe85e04352266f79db6bb1303c8e16ae9b6064c1247b5e32.css integrity="sha256-+TnE/++yZOb+heBDUiZvedtrsTA8jhaum2BkwSR7XjI=" rel="preload stylesheet" as=style><link rel=icon href=https://cdecl.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://cdecl.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://cdecl.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://cdecl.github.io/apple-touch-icon.png><link rel=mask-icon href=https://cdecl.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://cdecl.github.io/index.xml title=rss><link rel=alternate type=application/json href=https://cdecl.github.io/index.json title=json><link rel=alternate hreflang=en href=https://cdecl.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-VQQHHYPN7K"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VQQHHYPN7K")}</script><meta property="og:url" content="https://cdecl.github.io/"><meta property="og:site_name" content="cdeclog"><meta property="og:title" content="cdeclog"><meta property="og:description" content="cdecl's Dev.Ops Blog"><meta property="og:locale" content="ko-kr"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="cdeclog"><meta name=twitter:description content="cdecl's Dev.Ops Blog"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"cdeclog","url":"https://cdecl.github.io/","description":"cdecl's Dev.Ops Blog","logo":"https://cdecl.github.io/favicon.ico","sameAs":["https://github.com/cdecl","https://cdecl.tistory.com/"]}</script></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://cdecl.github.io/ accesskey=h title="cdeclog (Alt + H)">cdeclog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://cdecl.github.io/dev/ title=Dev><span>Dev</span></a></li><li><a href=https://cdecl.github.io/devops/ title=DevOps><span>DevOps</span></a></li><li><a href=https://cdecl.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://cdecl.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://cdecl.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>OpenRouter - 모든 AI 모델을 하나로 연결하는 관문</h2></header><div class=entry-content><p>수많은 대규모 언어 모델(LLM)이 등장하면서, 개발자와 기획자들은 프로젝트에 가장 적합한 모델을 선택하고 연동하는 데 많은 시간과 노력을 쏟고 있습니다. OpenRouter는 이러한 문제를 해결하기 위해 등장한 플랫폼으로, 다양한 AI 모델을 단일 API로 통합하여 제공하는 ‘AI의 관문(Gateway)’ 역할을 합니다. 이 글에서는 OpenRouter의 핵심 기능부터 요금 체계, 활용 방법까지 자세히 알아보겠습니다.
OpenRouter란? OpenRouter(https://openrouter.ai/)는 GPT-4, Claude 3.5 Sonnet, Gemini 2.5 Flash, Llama 3.1 등 여러 제공업체의 최신 AI 모델들을 하나의 표준화된 API 엔드포인트로 묶어 제공하는 서비스입니다. 개발자는 더 이상 각 모델의 API 문서를 따로 학습하거나, 여러 결제 시스템을 관리할 필요 없이 OpenRouter를 통해 원하는 모델을 손쉽게 테스트하고 실제 프로덕션에 적용할 수 있습니다.
...</p></div><footer class=entry-footer><span title='2025-07-23 00:00:00 +0900 KST'>July 23, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to OpenRouter - 모든 AI 모델을 하나로 연결하는 관문" href=https://cdecl.github.io/devops/openrouter-ai-gateway-guide/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Obsidian Tasks 플러그인으로 할 일 관리</h2></header><div class=entry-content><p>Obsidian을 단순한 노트 앱을 넘어 강력한 할 일 관리(To-Do) 도구로 만들어주는 Tasks 플러그인에 대해 알아봅니다. 이 플러그인을 활용하면 여러 노트에 흩어져 있는 할 일들을 한 곳에서 모아보고, 마감일, 우선순위, 반복 설정 등 다양한 기능을 통해 체계적으로 관리할 수 있습니다.
Tasks 플러그인 핵심 기능 Tasks 플러그인은 마크다운 기반의 할 일 관리를 한 단계 업그레이드해줍니다. 기본적인 체크박스 외에 다양한 메타데이터를 추가하여 할 일을 더욱 스마트하게 관리할 수 있습니다.
기본 Task 생성 가장 기본적인 할 일은 마크다운의 체크박스 문법을 사용하여 생성합니다.
...</p></div><footer class=entry-footer><span title='2025-07-22 00:00:00 +0900 KST'>July 22, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to Obsidian Tasks 플러그인으로 할 일 관리" href=https://cdecl.github.io/devops/obsidian-tasks-plugin-guide/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>macOS 데스크탑 화면 이동 순서 관리하기</h2></header><div class=entry-content><p>macOS의 Mission Control과 Spaces 기능을 활용하여 여러 데스크탑 화면을 효율적으로 관리하고 이동하는 방법에 대해 알아봅니다. 자동 재정렬 기능을 끄고 단축키를 활용하면 작업 생산성을 크게 높일 수 있습니다.
Mission Control 및 Spaces 기능 Mission Control: Mac에서 열려있는 모든 윈도우와 Spaces를 한눈에 보여주는 기능입니다. 여러 데스크탑 화면(Spaces)을 만들어 사용하거나, 전체 화면으로 실행 중인 앱 윈도우를 나열하는 데 사용됩니다. Spaces: macOS에서 제공하는 가상 데스크탑 기능으로, 여러 작업 공간을 분리하여 사용할 수 있습니다. Spaces를 통해 여러 개의 데스크탑을 만들고 각 데스크탑에 작업 윈도우를 배치하여 작업 효율성을 높일 수 있습니다. 최대 16개의 Spaces를 만들 수 있습니다. Spaces 순서 변경 및 고정 Spaces 자동 재정렬 끄기 macOS에서는 Spaces를 최근 사용 내역에 따라 자동으로 재정렬하는 기능이 기본적으로 활성화되어 있습니다. 이 기능을 끄면 데스크탑 순서가 사용자가 설정한 순서대로 고정됩니다. 설정 방법: 시스템 설정 열기. 데스크탑 및 Dock 또는 Mission Control 메뉴를 찾습니다. Mission Control 설정에서 “Spaces를 최근 사용 내역에 따라 자동으로 재정렬” 옵션을 끕니다. Spaces 순서 고정의 장점 데스크탑 순서가 바뀌지 않아 작업 공간을 예측 가능하게 관리할 수 있습니다. Control + 숫자 단축키를 사용하여 원하는 데스크탑으로 빠르게 이동할 수 있습니다. Spaces 이동 방법 트랙패드 제스처 세 손가락 또는 네 손가락을 사용하여 트랙패드를 좌우로 쓸어 넘겨 Spaces를 이동할 수 있습니다. 설정 확인: 시스템 환경설정 > 트랙패드에서 “Mission Control” 제스처가 활성화되어 있는지 확인합니다. 키보드 단축키 Control + ← 또는 Control + → 키를 사용하여 이전 또는 다음 Spaces로 이동할 수 있습니다. Control + 숫자 (1, 2, 3...) 키를 사용하여 특정 Spaces로 바로 이동할 수 있습니다. 단축키 활성화: 시스템 환경설정 > 키보드 > 단축키 > Mission Control에서 “데스크탑 X로 전환” 옵션을 활성화해야 합니다. Mission Control 사용 Mission Control을 열어(F3 키 또는 Control + ↑) 화면 상단의 Spaces 막대에서 원하는 Spaces를 클릭하여 이동할 수 있습니다. 추가 팁 Mission Control 설정 시스템 설정에서 Mission Control 관련 설정을 변경하여 작업 스타일에 맞게 조정할 수 있습니다. 예를 들어, “응용 프로그램으로 전환할 때, 응용 프로그램에 대해 윈도우가 열려 있는 Space로 전환” 옵션을 활성화하면 앱 전환 시 해당 앱의 윈도우가 열려 있는 Space로 자동으로 이동합니다. 핫 코너 활용 핫 코너를 설정하여 마우스 커서를 화면 모서리로 이동하면 Mission Control이 활성화되도록 할 수 있습니다. 시스템 설정 > 데스크탑 및 Dock > 핫 코너에서 설정할 수 있습니다. 윈도우 이동 Mission Control을 사용하여 윈도우를 다른 데스크탑으로 드래그 앤 드롭할 수 있습니다. 창 상단을 클릭한 상태에서 화면 위쪽 모서리로 마우스 커서를 이동하면 Spaces 막대가 나타나고, 원하는 데스크탑으로 창을 이동시킬 수 있습니다. Dock 활용 Dock에서 앱 아이콘을 Control-클릭하여 옵션 메뉴를 열고, “Option > Dock에 유지"를 선택하면 해당 앱이 Dock에 항상 표시되도록 할 수 있습니다. 이 정보가 macOS 데스크탑 화면 이동 순서를 관리하는 데 도움이 되기를 바랍니다.</p></div><footer class=entry-footer><span title='2025-07-21 00:00:00 +0900 KST'>July 21, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to macOS 데스크탑 화면 이동 순서 관리하기" href=https://cdecl.github.io/devops/macos-desktop-screen-switching-order/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>macOS에서 키를 길게 눌렀을 때 동작 변경하기</h2></header><div class=entry-content><p>macOS에서 키를 길게 눌렀을 때 기본적으로 악센트 메뉴(예: “a"를 길게 누르면 à, á, â 등이 표시)가 나타나지만, 이를 키 반복(Windows와 유사한 문자 반복 입력)으로 변경할 수 있습니다.
개요 이 문서에서는 터미널 명령어(defaults)를 사용해 ApplePressAndHoldEnabled 설정을 변경하는 방법과 관련된 동작 방식, 설정 확인, 삭제, 주의사항을 설명합니다.
ApplePressAndHoldEnabled 설정은 키를 길게 눌렀을 때의 동작을 제어합니다:
true (기본값): 키를 길게 누르면 악센트 메뉴가 표시됩니다. 예를 들어, “e” 키를 길게 누르면 é, è, ê 등의 선택 메뉴가 나타납니다. false: 키를 길게 누르면 해당 문자가 반복적으로 입력됩니다(예: “eeeee”). 이는 Windows의 키보드 동작과 유사합니다. 이 설정은 시스템 전반 또는 특정 응용 프로그램에 적용할 수 있습니다.
...</p></div><footer class=entry-footer><span title='2025-07-20 00:00:00 +0900 KST'>July 20, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to macOS에서 키를 길게 눌렀을 때 동작 변경하기" href=https://cdecl.github.io/devops/macos-key-repeat-settings/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Obsidian - Smart Connections 플러그인</h2></header><div class=entry-content><p>이 글에서는 Obsidian Smart Connections 플러그인의 개념부터 기능, 설정 방법, 주요 기능과 예제, 그리고 비슷한 플러그인까지 상세히 알아보겠습니다.
1. Obsidian Smart Connections 플러그인이란? Smart Connections는 Obsidian에서 AI 임베딩을 활용해 노트 간의 의미적 연결을 찾아주는 강력한 플러그인입니다. 사용자의 노트를 분석하여 관련된 콘텐츠를 실시간으로 추천하거나, 노트를 기반으로 대화형 AI와 상호작용할 수 있게 합니다. 블로그 작성, 연구, 지식 관리 등에서 생산성을 높여주며, 특히 대규모 노트 저장소에서 유용합니다.
주요 특징:
의미적 검색: 키워드가 아닌 노트의 의미를 기반으로 관련 노트를 찾아줍니다. 로컬 및 클라우드 AI 지원: Ollama, LM Studio 같은 로컬 모델과 OpenAI, Gemini, Claude 등 100개 이상의 API를 지원합니다. Smart Chat: 노트를 기반으로 AI와 대화하며 질문에 답변하거나 콘텐츠를 생성합니다. 컨텍스트 인식: 현재 노트나 선택한 텍스트를 활용해 관련 콘텐츠를 제안합니다. 오프라인 지원: 로컬 임베딩 모델을 사용해 데이터 프라이버시를 보장합니다. 2. 설치 및 설정 Smart Connections 플러그인은 Obsidian의 커뮤니티 플러그인 마켓에서 설치할 수 있습니다. 아래는 기본 설치 및 설정 방법입니다.
...</p></div><footer class=entry-footer><span title='2025-07-20 00:00:00 +0900 KST'>July 20, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to Obsidian - Smart Connections 플러그인" href=https://cdecl.github.io/devops/obsidian-smart-connections-plugin/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Python uv 프로젝트 구조</h2></header><div class=entry-content><p>uv를 활용한 현대적인 Python 프로젝트 구조, src 레이아웃과 Flat 레이아웃의 차이점, 그리고 uvx를 통한 원격 도구 실행 방법을 알아봅니다.
Python 프로젝트 구조의 중요성 잘 구성된 프로젝트 디렉토리 구조는 코드의 유지보수성, 확장성, 그리고 협업 효율성을 크게 향상시킵니다. Python에서는 전통적으로 두 가지 주요 레이아웃이 사용됩니다: Flat 레이아웃과 src 레이아웃. 현대적인 Python 프로젝트에서는 src 레이아웃이 많은 이점을 제공하여 표준으로 자리 잡고 있습니다.
일반적인 Python 프로젝트 디렉토리 구조 현대적인 Python 프로젝트는 일반적으로 다음과 같은 구조를 가집니다.
...</p></div><footer class=entry-footer><span title='2025-07-20 00:00:00 +0900 KST'>July 20, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to Python uv 프로젝트 구조" href=https://cdecl.github.io/dev/python-uv-project-structure/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Obsidian Text Generator 플러그인 가이드 (selected_text, context)</h2></header><div class=entry-content><p>이 글에서는 Obsidian Text Generator 플러그인의 개념부터 기능, 설정 방법, 명령어, 예약어 사용법, 그리고 유용한 추가 기능까지 상세히 알아보겠습니다.
1. Obsidian Text Generator 플러그인이란? Obsidian Text Generator 플러그인은 Obsidian에서 AI를 활용해 텍스트를 생성하는 강력한 도구입니다. 노트 작성, 아이디어 생성, 콘텐츠 요약 등 다양한 작업을 자동화하여 생산성을 높여줍니다. 이 플러그인은 사용자가 선택한 텍스트나 노트의 컨텍스트를 기반으로 AI 모델을 통해 문장을 완성하거나 새로운 콘텐츠를 생성합니다.
주요 특징:
다양한 AI 지원: OpenAI(GPT-3, GPT-4), Google Gemini, Anthropic Claude, 그리고 LM Studio와 같은 로컬 모델을 지원합니다. 템플릿 엔진: 반복 작업을 간소화하는 사용자 정의 템플릿을 제공합니다. 컨텍스트 인식: 현재 노트, 선택한 텍스트, 링크된 노트를 활용해 문맥에 맞는 텍스트를 생성합니다. 커뮤니티 템플릿: 다른 사용자의 템플릿을 공유하거나 가져와 다양한 활용 사례를 탐색할 수 있습니다. 유연한 설정: Frontmatter를 통해 AI 모델, 토큰 수, 온도 등을 세부적으로 조정 가능합니다. 2. 설치 및 Gemini 기반 설정 Text Generator 플러그인은 Obsidian의 커뮤니티 플러그인 마켓에서 설치할 수 있습니다. Google Gemini를 사용한 설정 예시는 다음과 같습니다.
...</p></div><footer class=entry-footer><span title='2025-07-17 00:00:00 +0900 KST'>July 17, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to Obsidian Text Generator 플러그인 가이드 (selected_text, context)" href=https://cdecl.github.io/devops/obsidian-text-generator-plugin/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>웹에서 만나는 터미널, ttyd 가이드</h2></header><div class=entry-content><p>이 글에서는 ttyd의 개념부터 설치, 활용법, 그리고 보안 강화 방안까지 상세하게 알아보겠습니다.
1. ttyd란 무엇인가? 개발자, 시스템 관리자, 혹은 단순히 터미널 작업을 즐기는 분이라면 원격으로 shell에 접속해야 하는 경우가 많습니다. SSH가 가장 일반적인 해결책이지만, 웹 브라우저만 있다면 어디서든 터미널에 접속할 수 있는 더 가벼운 방법이 있습니다. 바로 ttyd입니다.
ttyd는 ‘TTY over Web’의 약자로, 명령줄 도구를 웹 애플리케이션으로 변환해 주는 간단하고 효율적인 C언어 기반 프로그램입니다. 내부적으로는 Libwebsockets를 사용하여 웹소켓 통신을 처리하고, 프론트엔드에서는 xterm.js를 통해 완벽한 기능의 터미널을 웹 브라우저에 구현합니다.
...</p></div><footer class=entry-footer><span title='2025-07-13 00:00:00 +0900 KST'>July 13, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to 웹에서 만나는 터미널, ttyd 가이드" href=https://cdecl.github.io/devops/ttyd/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>구글의 AI 코딩 어시스턴트, Gemini CLI 사용 가이드</h2></header><div class=entry-content><p>Gemini CLI의 핵심 개념, 주요 기능, 설치 및 구성 방법, 그리고 다른 AI 코딩 도우미와의 비교를 통해 Gemini CLI를 효과적으로 활용하는 방법을 알아봅니다.
Gemini CLI란? Gemini CLI는 구글에서 개발한 대화형 AI 코딩 어시스턴트로, 터미널 환경에서 직접 작동합니다. 개발자는 자연어 명령을 통해 복잡한 개발 작업을 Gemini에게 위임할 수 있습니다. 파일 시스템 조작, 코드 리팩토링, 셸 명령어 실행, Git 버전 관리 등 다양한 작업을 자동화하여 개발 생산성을 크게 향상시킵니다. 이 포스트에서는 Gemini CLI의 핵심 철학, 주요 기능, 설치 및 구성, 그리고 GitHub Copilot CLI와의 비교를 통해 그 차이점을 명확히 설명합니다.
...</p></div><footer class=entry-footer><span title='2025-07-08 00:00:00 +0900 KST'>July 8, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to 구글의 AI 코딩 어시스턴트, Gemini CLI 사용 가이드" href=https://cdecl.github.io/devops/gemini_cli/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>오픈소스 AI 코딩 어시스턴트, Cline 사용 가이드</h2></header><div class=entry-content><p>Cline의 핵심 개념, 역할, 지원 AI 모델, 설치 및 구성 방법, 그리고 유용한 기능들을 상세히 소개합니다.
Cline이란? Cline은 Visual Studio Code(VS Code)와 통합된 오픈소스 AI 코딩 어시스턴트로, 복잡한 소프트웨어 개발 작업을 자동화하고 생산성을 극대화합니다. Claude 3.7 Sonnet, DeepSeek, Google Gemini 등 다양한 대형 언어 모델(LLM)을 활용하여 코드 작성, 디버깅, 리팩토링, 터미널 명령 실행 등을 지원합니다. 이 포스트에서는 Cline의 정의, 역할, 지원 AI 모델, 설치 및 구성 방법, 그리고 개발자를 위한 유용한 기능들을 자세히 다룹니다.
...</p></div><footer class=entry-footer><span title='2025-07-07 00:00:00 +0900 KST'>July 7, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to 오픈소스 AI 코딩 어시스턴트, Cline 사용 가이드" href=https://cdecl.github.io/devops/cline_usage_guide/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://cdecl.github.io/page/3/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://cdecl.github.io/page/5/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2026 <a href=https://cdecl.github.io/>cdeclog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>