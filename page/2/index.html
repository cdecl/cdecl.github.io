<!doctype html><html lang=en dir=auto data-theme=auto><head><meta name=generator content="Hugo 0.156.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>cdeclog</title><meta name=description content="cdecl's Dev.Ops Blog"><meta name=author content="Byung Kyu KIM"><link rel=canonical href=https://cdecl.github.io/><link crossorigin=anonymous href=/assets/css/stylesheet.f939c4ffefb264e6fe85e04352266f79db6bb1303c8e16ae9b6064c1247b5e32.css integrity="sha256-+TnE/++yZOb+heBDUiZvedtrsTA8jhaum2BkwSR7XjI=" rel="preload stylesheet" as=style><link rel=icon href=https://cdecl.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://cdecl.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://cdecl.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://cdecl.github.io/apple-touch-icon.png><link rel=mask-icon href=https://cdecl.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://cdecl.github.io/index.xml title=rss><link rel=alternate type=application/json href=https://cdecl.github.io/index.json title=json><link rel=alternate hreflang=en href=https://cdecl.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-VQQHHYPN7K"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VQQHHYPN7K")}</script><meta property="og:url" content="https://cdecl.github.io/"><meta property="og:site_name" content="cdeclog"><meta property="og:title" content="cdeclog"><meta property="og:description" content="cdecl's Dev.Ops Blog"><meta property="og:locale" content="ko-kr"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="cdeclog"><meta name=twitter:description content="cdecl's Dev.Ops Blog"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"cdeclog","url":"https://cdecl.github.io/","description":"cdecl's Dev.Ops Blog","logo":"https://cdecl.github.io/favicon.ico","sameAs":["https://github.com/cdecl","https://cdecl.tistory.com/"]}</script></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://cdecl.github.io/ accesskey=h title="cdeclog (Alt + H)">cdeclog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://cdecl.github.io/dev/ title=Dev><span>Dev</span></a></li><li><a href=https://cdecl.github.io/devops/ title=DevOps><span>DevOps</span></a></li><li><a href=https://cdecl.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://cdecl.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://cdecl.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Agent Skill 가이드: AI 에이전트의 전문성을 위한 모듈식 아키텍처</h2></header><div class=entry-content><p>Claude Code나 Gemini CLI를 사용해본 개발자라면 이런 경험을 했을 겁니다: 특정 도메인의 작업을 할 때 에이전트가 너무 일반적으로만 접근한다는 것입니다. 이것이 바로 Agent Skill이 필요한 이유입니다.
1. Agent Skill이란? Agent Skill은 특정 도메인의 전문 지식을 패키징한 재사용 가능한 모듈입니다. 2025년 Anthropic이 정식으로 도입한 이 기술은 에이전트에게 단순한 명령이 아닌 진정한 전문성을 제공합니다.
더 정확히는:
구조: SKILL.md 파일과 지침, 스크립트, 참고 자료를 포함하는 폴더 작동: 에이전트가 관련성을 감지하면 자동으로 해당 Skill을 활성화하여 그 분야의 전문가처럼 행동 핵심 원리: 필요한 정보만 필요한 시점에 로드하는 Progressive Disclosure 일반 LLM은 비결정성 특성으로 같은 작업을 반복해도 결과가 달라질 수 있습니다. Agent Skill은 구조화된 절차와 리소스를 제공하여 이를 개선합니다.
...</p></div><footer class=entry-footer><span title='2026-01-20 00:00:00 +0900 KST'>January 20, 2026</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to Agent Skill 가이드: AI 에이전트의 전문성을 위한 모듈식 아키텍처" href=https://cdecl.github.io/devops/agent-skill-complete-guide/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>OpenCode: AI 코딩 에이전트 가이드</h2></header><div class=entry-content><p>OpenCode는 터미널 기반의 오픈소스 AI 코딩 에이전트로, 개발 생산성 향상을 목표로 합니다. LSP(Language Server Pro
OpenCode 핵심 기능 LSP (Language Server Protocol) LSP 서버란? LSP 자동 로드 OpenCode는 프로젝트를 열 때 .lsproj 파일이나 언어별 설정 파일을 자동으로 스캔하여 해당 프로젝트에 적합한 LSP 서버를 감지하고 설치 및 실행합니다. 예를 들어, TypeScript 프로젝트에서는 자동으로 TypeScript Language Server를 활성화합니다. 이 기능 덕분에 개발자는 별도의 수동 설정 없이 즉시 언어 서비스를 활용할 수 있으며, 에이전트는 LSP 서버와 통신하며 코드 분석, 편집, 리팩토링 등을 지원합니다.
...</p></div><footer class=entry-footer><span title='2026-01-12 00:00:00 +0900 KST'>January 12, 2026</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to OpenCode: AI 코딩 에이전트 가이드" href=https://cdecl.github.io/devops/opencode-ai-agent/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Git Worktree: 하나의 저장소, 여러 작업 공간</h2></header><div class=entry-content><p>Git Worktree란 무엇이며 왜 필요한가? Stash와의 차이점부터 주요 명령어까지, 효율적인 브랜치 관리
개요 개발을 하다 보면 현재 작업 중인 브랜치에서 아직 커밋하지 못한 변경 사항이 있는데, 긴급하게 다른 브랜치(예: 배포를 위한 핫픽스)로 전환해야 하는 상황을 자주 마주하게 됩니다. 보통은 git stash를 사용하거나 아직 완료되지 않은 코드를 임시 커밋(WIP)하고 브랜치를 전환하지만, 이러한 방식은 번거롭고 컨텍스트 전환에 비용이 듭니다.
Git Worktree는 이런 문제를 우아하게 해결해주는 Git의 강력한 기능입니다. 이 글에서는 Git Worktree의 개념과 필요성, 그리고 git stash와의 차이점과 사용법에 대해 알아봅니다.
...</p></div><footer class=entry-footer><span title='2026-01-07 00:00:00 +0900 KST'>January 7, 2026</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to Git Worktree: 하나의 저장소, 여러 작업 공간" href=https://cdecl.github.io/dev/git-worktree-guide/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>tmux 시작하기: 기본 개념, 필수 명령어</h2></header><div class=entry-content><p>tmux는 터미널 멀티플렉서로, 하나의 터미널 창에서 여러 세션, 윈도우, 패널을 관리하여 생산성을 극대화하는 강력한 도구입니다. 이 글에서는 tmux의 기본 개념, 설치 방법, 주요 용어 및 필수 명령어에 대해 알아봅니다.
개요 tmux는 ‘Terminal Multiplexer’의 약자로, 하나의 터미널 창(또는 원격 접속 세션) 내에서 여러 개의 독립적인 터미널 세션을 생성하고 관리할 수 있게 해주는 도구입니다. tmux를 사용하면 터미널 세션을 영구적으로 유지할 수 있어, 네트워크 연결이 끊어지더라도 실행 중이던 작업을 안전하게 보존하고 나중에 다시 접속하여 이어갈 수 있습니다.
...</p></div><footer class=entry-footer><span title='2026-01-07 00:00:00 +0900 KST'>January 7, 2026</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to tmux 시작하기: 기본 개념, 필수 명령어" href=https://cdecl.github.io/devops/tmux-guide/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Bitwarden Secrets Manager 시작하기 (bws CLI 가이드)</h2></header><div class=entry-content><p>애플리케이션 개발에서 API 키, DB 접속 정보 등 민감한 정보를 안전하게 관리하는 것은 매우 중요합니다. 많은 팀이 HashiCorp Vault나 클라우드 제공업체의 전용 Secret Manager를 사용하지만, 더 직관적이고 쉬운 솔루션을 찾는 경우도 많습니다.
Bitwarden Secrets Manager는 바로 이 지점을 파고드는 제품입니다. 개발자 친화적인 워크플로우와 쉬운 사용성으로, 애플리케이션의 비밀 정보를 중앙에서 안전하게 관리할 수 있도록 설계되었습니다.
이 글에서는 Bitwarden Secrets Manager의 전용 CLI 도구인 bws를 사용하여 비밀 정보를 관리하는 방법을 소개합니다.
Bitwarden Secrets Manager 핵심 개념 bws CLI를 사용하기 전에, Secrets Manager의 네 가지 핵심 개념을 이해해야 합니다.
...</p></div><footer class=entry-footer><span title='2025-12-30 00:00:00 +0900 KST'>December 30, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to Bitwarden Secrets Manager 시작하기 (bws CLI 가이드)" href=https://cdecl.github.io/devops/bitwarden-cli/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>사례로 보는 Git 트러블 슈팅</h2></header><div class=entry-content><p>Git은 강력하지만, 복잡한 상황에서는 개발자를 당황하게 만드는 경우가 많습니다. “앗, 방금 뭘 한 거지?” 싶은 순간은 누구에게나 찾아옵니다. 이 글에서는 checkout, stash, branch 등 핵심 명령어를 중심으로, 실제 현업에서 자주 겪는 20가지 트러블 슈팅 사례와 해결 방안을 구체적으로 정리했습니다.
Part 1: checkout 관련 문제 - “코드가 뒤섞였어요!” checkout은 브랜치를 바꾸거나 특정 버전으로 돌아갈 때 사용하지만, 이 과정에서 많은 실수가 발생합니다.
사례 1: 다른 브랜치로 이동하려는데, 작업하던 내용이 있어서 막힐 때 문제 상황: feature/new-login 브랜치에서 작업하던 중, 급하게 hotfix/bug-report 브랜치로 이동해야 합니다. git checkout hotfix/bug-report를 입력하니 “error: Your local changes to the following files would be overwritten by checkout…” 메시지가 나옵니다. 해결 방안: 아직 커밋하기 애매한 작업 내용을 임시 저장 공간(stash)에 저장합니다. # 현재 작업 내용을 스택에 임시 저장 git stash > `git stash`: 현재 작업 디렉터리의 변경된 파일(Tracked files)을 임시로 스택에 저장합니다. `push`, `pop`, `apply`, `list` 등의 하위 명령어를 통해 관리할 수 있습니다. # 원하는 브랜치로 이동하여 작업 수행 git checkout hotfix/bug-report # ... 핫픽스 작업 ... git commit -m "Fix: Critical bug" git push origin hotfix/bug-report # 원래 브랜치로 복귀 git checkout feature/new-login # 임시 저장했던 작업 내용 다시 적용 git stash pop 사례 2: 실수로 파일을 삭제했는데, 커밋은 아직 안 했을 때 (rm a.txt) 문제 상황: git rm이 아닌 rm 명령어로 파일을 삭제했습니다. git status에 “deleted: a.txt"로 표시됩니다. 해결 방안: checkout을 사용해 현재 브랜치(HEAD)의 마지막 커밋 상태에서 해당 파일을 복원합니다. # a.txt 파일을 마지막 커밋 상태로 복원 git checkout HEAD -- a.txt ```bash > `git checkout &lt;commit> -- &lt;file>`: 특정 커밋 상태의 특정 파일을 현재 작업 디렉터리로 복원합니다. `--`는 브랜치/커밋과 파일 경로를 명확하게 구분하는 역할을 합니다. # -- 를 사용하면 브랜치 이름과 파일 이름을 명확히 구분할 수 있어 안전합니다. 사례 3: 브랜치를 옮기지 않고 다른 브랜치의 파일 내용만 보고 싶을 때 문제 상황: 현재 브랜치는 feature인데, main 브랜치의 config.yml 파일 내용과 비교하고 싶습니다. 브랜치를 통째로 옮기기엔 부담스럽습니다. 해결 방안: git show 또는 git checkout을 특정 파일에 대해서만 실행합니다. # 1. git show 사용 (단순 조회) git show main:path/to/config.yml > `git show &lt;branch>:&lt;path/to/file>`: 브랜치를 변경하지 않고, 다른 브랜치에 있는 파일의 내용을 터미널에 출력합니다. # 2. git checkout 사용 (현재 작업 디렉터리로 가져오기) git checkout main -- path/to/config.yml # 위 명령은 `main` 브랜치의 `config.yml`을 현재 디렉터리로 가져와 덮어씁니다. # 주의: 현재 작업 디렉터리의 내용이 변경됩니다. 사례 4: “Detached HEAD” 상태가 되었을 때 문제 상황: git checkout &lt;commit-hash> 나 git checkout origin/main 처럼 브랜치가 아닌 포인터를 직접 체크아웃하면 “You are in ‘detached HEAD’ state.” 라는 메시지가 나옵니다. 이 상태에서 작업하고 커밋하면 해당 커밋은 어떤 브랜치에도 속하지 않게 되어 나중에 잃어버릴 수 있습니다. 해결 방안: 현재 “Detached HEAD” 상태에서 새로운 브랜치를 만들어 작업을 이어갑니다. # 현재 위치에서 'temp-work' 라는 새 브랜치를 생성 git checkout -b temp-work > `git checkout -b &lt;new-branch>`: 현재 위치(커밋)에서 새로운 브랜치를 생성하고, 즉시 해당 브랜치로 전환합니다. # 이제 'temp-work' 브랜치에서 안전하게 커밋을 이어갈 수 있습니다. git add . git commit -m "Add new feature from detached state" 사례 5: 과거의 특정 파일 버전 하나만 현재 브랜치로 가져오고 싶을 때 문제 상황: config.js 파일의 과거 버전이 필요합니다. 3개의 커밋 전(HEAD~3) 버전의 config.js만 현재 작업 내용에 덮어쓰고 싶습니다. 해결 방안: git checkout에 커밋 해시와 파일 경로를 지정합니다. # 3개 커밋 전 버전의 'config.js'를 현재 디렉터리로 가져옴 git checkout HEAD~3 -- src/config.js git checkout &lt;commit> -- &lt;file>: 특정 커밋에 해당하는 파일의 버전으로 현재 작업 디렉터리의 파일을 덮어씁니다.
...</p></div><footer class=entry-footer><span title='2025-12-30 00:00:00 +0900 KST'>December 30, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to 사례로 보는 Git 트러블 슈팅" href=https://cdecl.github.io/dev/git-troubleshooting-examples/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Supabase RLS와 anon 키: RLS Disabled in Public, 백엔드 개발자를 위한 보안 가이드</h2></header><div class=entry-content><p>Supabase는 편리한 기능과 자동화된 API 덕분에 많은 개발자에게 사랑받고 있지만, 간혹 대시보드에 나타나는 “RLS Disabled” 경고는 백엔드 개발자들을 혼란에 빠뜨리곤 합니다. “나는 백엔드에서만 안전하게 통신하는데, 이게 왜 문제지?“라고 생각했다면 이 글이 명쾌한 해답을 드릴 것입니다. 이 글에서는 RLS와 anon 키의 관계를 명확히 이해하고, 백엔드 중심 프로젝트에서 RLS를 어떻게 활용해야 하는지에 대한 모범 사례를 제시합니다.
1. 문제 상황: “RLS Disabled in Public” 경고의 의미 Supabase 대시보드에서 public.users 또는 public.notes와 같은 테이블에 대해 RLS Disabled 경고를 마주하는 것은 생각보다 흔한 일입니다. 이 경고의 진짜 의미는 무엇일까요?
...</p></div><footer class=entry-footer><span title='2025-12-23 00:00:00 +0900 KST'>December 23, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to Supabase RLS와 anon 키: RLS Disabled in Public, 백엔드 개발자를 위한 보안 가이드" href=https://cdecl.github.io/devops/supabase-rls-anon-key-security-guide/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Python Web 프레임워크 (Flask, FastAPI) Vercel로 배포하기</h2></header><div class=entry-content><p>Python 기반의 웹 프레임워크인 Flask나 FastAPI를 개발한 후, 이를 실제 서비스로 배포하는 방법은 여러 가지가 있습니다. (AWS EC2, Docker, Heroku 등) 그 중에서도 Vercel은 복잡한 서버 관리 없이 가장 간편하고 빠르게 배포할 수 있는 플랫폼 중 하나입니다. 이번 글에서는 Vercel을 사용하여 Python 웹 애플리케이션을 배포하는 전반적인 과정과 주요 개념들을 정리해 보겠습니다.
1. Vercel 서비스 개요 및 기능 Vercel은 개발자가 만든 웹 애플리케이션을 쉽고 빠르게 배포할 수 있도록 돕는 클라우드 플랫폼입니다. 초기에는 Next.js와 같은 프론트엔드 프레임워크 배포에 최적화된 서비스로 시작했으나, 현재는 Serverless Functions 기능을 통해 Python, Node.js, Go 등의 백엔드 언어도 지원합니다.
...</p></div><footer class=entry-footer><span title='2025-12-21 00:00:00 +0900 KST'>December 21, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to Python Web 프레임워크 (Flask, FastAPI) Vercel로 배포하기" href=https://cdecl.github.io/devops/python-web-framework-vercel-deploy/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>네트워크 패킷의 이동</h2></header><div class=entry-content><p>네트워크 상에서 데이터(패킷)가 출발지에서 목적지까지 어떻게 이동하는지, 그 과정을 단계별로 정리해 보았습니다. 우리가 인터넷을 통해 데이터를 보낼 때, 눈에 보이지 않는 수많은 장비들이 어떤 역할을 수행하는지 알아보겠습니다.
전체 흐름도 (Network Flow Diagram) 먼저 전체적인 흐름을 인포그래픽으로 살펴보겠습니다.
단계별 이동 과정 패킷이 목적지 IP로 이동하는 과정은 크게 4단계로 나눌 수 있습니다.
(1) 로컬 네트워크 확인 및 이동 (Routing Table & MAC) 컴퓨터나 네트워크 스위치는 패킷을 보낼 때 먼저 자신의 **라우팅 테이블(Routing Table)**을 확인합니다.
...</p></div><footer class=entry-footer><span title='2025-12-13 00:00:00 +0900 KST'>December 13, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to 네트워크 패킷의 이동" href=https://cdecl.github.io/devops/network-packet-flow/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Github에서 사용되는 주요 라이선스 종류 및 허용, 제약 사항</h2></header><div class=entry-content><p>오픈 소스 프로젝트를 시작하거나 기여할 때 가장 먼저 고려해야 할 것 중 하나는 **라이선스(License)**입니다. Github에는 수많은 프로젝트가 존재하며, 각 프로젝트는 코드 사용에 대한 권리와 의무를 규정하는 라이선스를 가지고 있습니다.
라이선스를 제대로 이해하지 못하고 코드를 사용하면 법적 분쟁에 휘말릴 수 있습니다. 이 글에서는 Github에서 가장 널리 사용되는 주요 오픈 소스 라이선스들의 특징과 허용 범위, 제약 사항을 정리해 봅니다.
1. MIT 라이선스 (MIT License) MIT 라이선스는 가장 단순하고 제한이 적은 라이선스 중 하나로, Github에서 가장 많이 사용되는 라이선스입니다.
...</p></div><footer class=entry-footer><span title='2025-12-11 00:00:00 +0900 KST'>December 11, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to Github에서 사용되는 주요 라이선스 종류 및 허용, 제약 사항" href=https://cdecl.github.io/dev/github-open-source-licenses/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://cdecl.github.io/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://cdecl.github.io/page/3/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2026 <a href=https://cdecl.github.io/>cdeclog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>