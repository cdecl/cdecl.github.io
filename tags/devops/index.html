<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Devops | cdeclog</title><meta name=keywords content><meta name=description content="cdecl's Dev.Ops Blog"><meta name=author content="Byung Kyu KIM"><link rel=canonical href=https://cdecl.github.io/tags/devops/><link crossorigin=anonymous href=/assets/css/stylesheet.f939c4ffefb264e6fe85e04352266f79db6bb1303c8e16ae9b6064c1247b5e32.css integrity="sha256-+TnE/++yZOb+heBDUiZvedtrsTA8jhaum2BkwSR7XjI=" rel="preload stylesheet" as=style><link rel=icon href=https://cdecl.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://cdecl.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://cdecl.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://cdecl.github.io/apple-touch-icon.png><link rel=mask-icon href=https://cdecl.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://cdecl.github.io/tags/devops/index.xml title=rss><link rel=alternate hreflang=en href=https://cdecl.github.io/tags/devops/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-VQQHHYPN7K"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VQQHHYPN7K")}</script><meta property="og:url" content="https://cdecl.github.io/tags/devops/"><meta property="og:site_name" content="cdeclog"><meta property="og:title" content="Devops"><meta property="og:description" content="cdecl's Dev.Ops Blog"><meta property="og:locale" content="ko-kr"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Devops"><meta name=twitter:description content="cdecl's Dev.Ops Blog"></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://cdecl.github.io/ accesskey=h title="cdeclog (Alt + H)">cdeclog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://cdecl.github.io/dev/ title=Dev><span>Dev</span></a></li><li><a href=https://cdecl.github.io/devops/ title=DevOps><span>DevOps</span></a></li><li><a href=https://cdecl.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://cdecl.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://cdecl.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://cdecl.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://cdecl.github.io/tags/>Tags</a></div><h1>Devops</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Lazygit 가이드: 설치부터 패널별 치트시트</h2></header><div class=entry-content><p>Git은 강력하지만 명령어 입력 방식은 때로 직관성이 떨어집니다. 특히 수많은 파일을 개별적으로 스테이징하거나 복잡한 인터랙티브 리베이스를 수행할 때 터미널 UI(TUI) 도구의 진가가 드러납니다. 그중에서도 가장 완성도 높은 도구인 Lazygit을 파헤쳐 봅니다.
1. Lazygit 설치 (Installation) 환경에 맞는 패키지 매니저를 사용하여 간단히 설치할 수 있습니다.
macOS brew install lazygit Windows # Scoop 사용 시 scoop bucket add extras scoop install lazygit # Winget 사용 시 winget install jesseduffield.lazygit Linux (Ubuntu/Debian 등) # 바이너리 직접 설치 예시 LAZYGIT_VERSION=$(curl -s "https://api.github.com/repos/jesseduffield/lazygit/releases/latest" | grep -Po '"tag_name": "v\K[^"]*') curl -Lo lazygit.tar.gz "https://github.com/jesseduffield/lazygit/releases/latest/download/lazygit_${LAZYGIT_VERSION}_Linux_x86_64.tar.gz" tar xf lazygit.tar.gz lazygit sudo install lazygit /usr/local/bin 2. TUI 구성 및 레이아웃 (Layout) Lazygit는 한 화면에서 Git의 모든 상태를 조망할 수 있는 대시보드형 레이아웃을 가지고 있습니다.
...</p></div><footer class=entry-footer><span title='2026-02-04 00:00:00 +0900 KST'>February 4, 2026</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to Lazygit 가이드: 설치부터 패널별 치트시트" href=https://cdecl.github.io/devops/lazygit-guide/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[AI 엔지니어링] 에이전트의 'Skills' 환상과 56%의 실패율: 왜 우리는 다시 시스템 프롬프트로 돌아가는가?</h2></header><div class=entry-content><p>최근 AI 개발자 커뮤니티, 특히 Vercel AI SDK와 Cursor 사용자들 사이에서 매우 흥미로운 화두가 던져졌습니다. Vercel의 소프트웨어 엔지니어 Jude Gao가 발표한 **"AGENTS.md outperforms skills in our agent evals"**라는 벤치마크 결과입니다.
많은 개발자가 프로젝트를 진행하며 직감적으로 느끼던 현상—“도구(Skills)를 쥐여주는 것보다, 그냥 문서를 통째로 읽게 시키는 게 훨씬 낫다”—가 실제 데이터로 증명되었습니다. 오늘은 이 벤치마크 데이터와 이를 둘러싼 ‘Skills vs Context vs Subagents’ 아키텍처의 변화를 심도 있게 분석해 봅니다.
1. 충격적인 데이터: 56%의 무시율 (Ignore Rate) 우리는 흔히 “LLM에게 도구(Tool/Skill/Function Calling)를 주면, 필요할 때마다 똑똑하게 꺼내 쓸 것"이라고 기대합니다. 하지만 Next.js 16 API(당시 미학습 데이터)를 대상으로 한 벤치마크 결과는 이 믿음을 배신했습니다.
...</p></div><footer class=entry-footer><span title='2026-01-30 00:00:00 +0900 KST'>January 30, 2026</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to [AI 엔지니어링] 에이전트의 'Skills' 환상과 56%의 실패율: 왜 우리는 다시 시스템 프롬프트로 돌아가는가?" href=https://cdecl.github.io/posts/ai-agent-skills-vs-context/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>macOS 시스템 최적화의 종결자: Mole 유틸리티와 Agent Skills 활용기</h2></header><div class=entry-content><p>서론 유료 앱들의 핵심 기능을 단 하나의 바이너리로 통합한 강력한 오픈소스 CLI 도구, Mole을 소개. 특히 최근 유행하는 AI Agent와 연계하여 시스템 관리를 자동화하는 방법까지 함께 살펴보겠습니다.
1. Mole 유틸리티란? Mole(tw93/Mole)은 tw93이 개발한 macOS용 올인원 시스템 유틸리티다. Go 언어와 셸 스크립트로 작성되어 매우 가볍고 빠르며, 터미널 환경에서 모든 시스템 최적화 작업을 통합 관리할 수 있다.
주요 특징 All-in-One: 청소, 앱 삭제, 최적화, 분석, 실시간 모니터링 기능을 단일 바이너리로 통합. 오픈소스: MIT 라이선스 기반의 무료 도구로, 상업용 앱의 광고나 구독 모델 없이 모든 기능 제공. 초경량: CLI 기반으로 동작하여 시스템 리소스 점유율이 매우 낮음. 2. 설치 방법 Homebrew를 통해 간단히 설치 가능하다.
...</p></div><footer class=entry-footer><span title='2026-01-29 00:00:00 +0900 KST'>January 29, 2026</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to macOS 시스템 최적화의 종결자: Mole 유틸리티와 Agent Skills 활용기" href=https://cdecl.github.io/devops/mole-utility-guide/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>웹에서 만나는 터미널, ttyd 가이드</h2></header><div class=entry-content><p>이 글에서는 ttyd의 개념부터 설치, 활용법, 그리고 보안 강화 방안까지 상세하게 알아보겠습니다.
1. ttyd란 무엇인가? 개발자, 시스템 관리자, 혹은 단순히 터미널 작업을 즐기는 분이라면 원격으로 shell에 접속해야 하는 경우가 많습니다. SSH가 가장 일반적인 해결책이지만, 웹 브라우저만 있다면 어디서든 터미널에 접속할 수 있는 더 가벼운 방법이 있습니다. 바로 ttyd입니다.
ttyd는 ‘TTY over Web’의 약자로, 명령줄 도구를 웹 애플리케이션으로 변환해 주는 간단하고 효율적인 C언어 기반 프로그램입니다. 내부적으로는 Libwebsockets를 사용하여 웹소켓 통신을 처리하고, 프론트엔드에서는 xterm.js를 통해 완벽한 기능의 터미널을 웹 브라우저에 구현합니다.
...</p></div><footer class=entry-footer><span title='2025-07-13 00:00:00 +0900 KST'>July 13, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to 웹에서 만나는 터미널, ttyd 가이드" href=https://cdecl.github.io/devops/ttyd/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>모던 쉘 명령어로 터미널 생산성 높이기</h2></header><div class=entry-content><p>모던 쉘 명령어: 전통적인 도구를 대체하는 강력한 대안
터미널은 개발자와 시스템 관리자의 핵심 도구입니다. 하지만 전통적인 쉘 명령어(grep, sed, find, cat, watch, top, du)는 속도, 가독성, 사용 편의성 면에서 한계가 있습니다. 2025년 기준, 이러한 명령어들을 대체하는 모던 대안들이 주목받고 있습니다. 이 포스트에서는 ripgrep, sd, fd, bat, hwatch, htop, dust를 전통 명령어와 비교하며 특징과 사용법을 소개합니다.
모던 쉘 명령어 요약 전통 명령어 모던 대안 주요 특징 설치 명령어 (Ubuntu/Debian) grep ripgrep (rg) 고속 검색, .gitignore 통합, 컬러 출력 sudo apt-get install ripgrep sed sd 간단한 치환 문법, 빠른 처리 sudo apt-get install sd find fd 직관적 검색, .gitignore 지원 sudo apt-get install fd-find cat bat 구문 강조, Git 통합, 페이징 sudo apt-get install bat watch hwatch 변경 강조, 로그 저장 sudo apt-get install hwatch top htop 컬러 UI, 프로세스 트리 뷰 sudo apt-get install htop du dust 트리 구조, 직관적 시각화 sudo apt-get install dust 왜 모던 쉘 명령어가 필요한가? 모던 쉘 명령어는 Rust, Go 같은 현대 언어로 작성되어 속도와 효율성이 뛰어나며, 사용자 친화적인 인터페이스를 제공합니다. 주요 장점은 다음과 같습니다:
...</p></div><footer class=entry-footer><span title='2025-05-25 00:00:00 +0900 KST'>May 25, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to 모던 쉘 명령어로 터미널 생산성 높이기" href=https://cdecl.github.io/devops/moden-shell-command/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>GitHub Actions YAML 사용법</h2></header><div class=entry-content><p>GitHub Actions YAML: CI/CD 워크플로우의 핵심
GitHub Actions는 CI/CD 및 자동화 워크플로우를 정의하는 강력한 도구로, YAML 파일을 통해 설정됩니다. 이 포스트에서는 GitHub Actions YAML의 주요 사용법, 실행 환경, 쉘 스크립트 활용 방법, 그리고 실무에서 유용한 팁을 정리합니다.
왜 GitHub Actions YAML이 중요한가? GitHub Actions는 코드 푸시, 풀 리퀘스트, 스케줄링 등 다양한 이벤트를 기반으로 자동화된 워크플로우를 실행할 수 있습니다. YAML 파일은 이를 직관적이고 선언적으로 정의하며, 다음과 같은 장점을 제공합니다:
가독성: 명확한 구조로 워크플로우 정의. 유연성: 다양한 환경과 도구 지원. 재사용성: 액션과 워크플로우를 모듈화해 생산성 향상. 2025년 기준: GitHub Actions는 대부분의 주요 언어와 배포 환경을 지원하며, 커뮤니티 액션으로 확장 가능. 1. GitHub Actions YAML 기본 구조 GitHub Actions 워크플로우는 .github/workflows/ 디렉토리에 .yml 파일로 저장됩니다. 기본 구조는 다음과 같습니다:
...</p></div><footer class=entry-footer><span title='2025-05-23 00:00:00 +0900 KST'>May 23, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to GitHub Actions YAML 사용법" href=https://cdecl.github.io/dev/github-actions-yaml/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>xargs - 효율적인 명령어 인수 처리와 병렬 실행</h2></header><div class=entry-content><p>xargs - 효율적인 명령어 인수 처리와 병렬 실행
xargs 명령어: 효율적인 명령어 확장과 파라미터 전달 xargs 명령어는 한 명령어의 출력을 다른 명령어의 인수로 전달할 때 유용하게 사용됩니다. 특히 명령어의 파라미터가 길어지거나 여러 파일, 디렉토리를 대상으로 명령어를 실행해야 할 때 xargs를 사용하면 성능과 효율성을 높일 수 있습니다.
주요 옵션과 활용 예시 1. 기본 사용법 xargs는 기본적으로 표준 입력에서 받은 데이터를 공백 또는 개행으로 구분하여 후속 명령어의 인수로 전달합니다.
예시:
echo "file1 file2 file3" | xargs ls -l file1, file2, file3을 ls -l의 인수로 전달하여 파일의 상세 정보를 출력합니다.
...</p></div><footer class=entry-footer><span title='2024-10-27 00:00:00 +0900 KST'>October 27, 2024</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to xargs - 효율적인 명령어 인수 처리와 병렬 실행" href=https://cdecl.github.io/devops/xargs-command-guide/></a></article></main><footer class=footer><span>&copy; 2026 <a href=https://cdecl.github.io/>cdeclog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>