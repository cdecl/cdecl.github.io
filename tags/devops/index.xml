<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>DevOps on cdeclog</title><link>https://cdecl.github.io/tags/devops/</link><description>Recent content in DevOps on cdeclog</description><generator>Hugo -- 0.156.0</generator><language>ko-kr</language><lastBuildDate>Mon, 23 Feb 2026 00:00:00 +0900</lastBuildDate><atom:link href="https://cdecl.github.io/tags/devops/index.xml" rel="self" type="application/rss+xml"/><item><title>AI Agent 구현의 두 갈래: 일반 Tool Calling vs MCP 비교</title><link>https://cdecl.github.io/devops/ai-agent-tool-calling-vs-mcp/</link><pubDate>Mon, 23 Feb 2026 00:00:00 +0900</pubDate><guid>https://cdecl.github.io/devops/ai-agent-tool-calling-vs-mcp/</guid><description>&lt;p&gt;AI 에이전트를 구축할 때, LLM이 외부 도구를 사용하게 만드는 과정은 필수적입니다. 하지만 최근 등장한 **MCP(Model Context Protocol)**와 기존의 &lt;strong&gt;Function/Tool Calling&lt;/strong&gt;은 비슷해 보이면서도 구조적으로 큰 차이가 있습니다. 오늘은 이 두 방식의 특징과 실제 구현 관점에서의 차이를 상세히 비교해 보겠습니다.&lt;/p&gt;
&lt;h2 id="1-한눈에-보는-비교-요약"&gt;1. 한눈에 보는 비교 요약&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style="text-align: left"&gt;구분&lt;/th&gt;
&lt;th style="text-align: left"&gt;일반 Tool Calling (기존 방식)&lt;/th&gt;
&lt;th style="text-align: left"&gt;MCP (Model Context Protocol)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: left"&gt;&lt;strong&gt;핵심 개념&lt;/strong&gt;&lt;/td&gt;
&lt;td style="text-align: left"&gt;함수 정의와 실행 로직의 수동 연결&lt;/td&gt;
&lt;td style="text-align: left"&gt;도구의 정의와 실행이 결합된 표준화된 서버&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left"&gt;&lt;strong&gt;실행 주체&lt;/strong&gt;&lt;/td&gt;
&lt;td style="text-align: left"&gt;에이전트 애플리케이션 (Local, Tightly Coupled)&lt;/td&gt;
&lt;td style="text-align: left"&gt;독립된 MCP 서버 (Remote/Isolated)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left"&gt;&lt;strong&gt;통신 규격&lt;/strong&gt;&lt;/td&gt;
&lt;td style="text-align: left"&gt;모델별 전용 API (OpenAI, Anthropic 등)&lt;/td&gt;
&lt;td style="text-align: left"&gt;&lt;strong&gt;JSON-RPC 2.0&lt;/strong&gt; 표준 프로토콜&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left"&gt;&lt;strong&gt;툴 목록 관리&lt;/strong&gt;&lt;/td&gt;
&lt;td style="text-align: left"&gt;코드에 하드코딩, 앱 재배포 필요&lt;/td&gt;
&lt;td style="text-align: left"&gt;서버에서 동적으로 &lt;code&gt;list_tools()&lt;/code&gt; 조회&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left"&gt;&lt;strong&gt;확장성&lt;/strong&gt;&lt;/td&gt;
&lt;td style="text-align: left"&gt;새 툴 추가 시 앱 코드 수정 및 재배포&lt;/td&gt;
&lt;td style="text-align: left"&gt;MCP 서버만 추가·재시작하면 즉시 연동&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left"&gt;&lt;strong&gt;상호운용성&lt;/strong&gt;&lt;/td&gt;
&lt;td style="text-align: left"&gt;모델별 규격 변환 코드 직접 작성 필요&lt;/td&gt;
&lt;td style="text-align: left"&gt;MCP 지원 클라이언트라면 어떤 모델이든 재사용&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left"&gt;&lt;strong&gt;컨텍스트 제공&lt;/strong&gt;&lt;/td&gt;
&lt;td style="text-align: left"&gt;주로 &amp;lsquo;액션(함수 호출)&amp;lsquo;에 집중&lt;/td&gt;
&lt;td style="text-align: left"&gt;툴 + &lt;strong&gt;리소스(파일, DB)&lt;/strong&gt; + &lt;strong&gt;프롬프트 템플릿&lt;/strong&gt; 패키지&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left"&gt;&lt;strong&gt;보안/격리&lt;/strong&gt;&lt;/td&gt;
&lt;td style="text-align: left"&gt;에이전트 프로세스 내에서 직접 실행&lt;/td&gt;
&lt;td style="text-align: left"&gt;실행 로직이 서버에 캡슐화, 권한 경계 명확&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id="2-일반-tool-calling-직접-요리하기-방식"&gt;2. 일반 Tool Calling: &amp;ldquo;직접 요리하기&amp;rdquo; 방식&lt;/h2&gt;
&lt;p&gt;일반적인 방식에서 에이전트는 요리사(LLM)가 준 레시피(JSON)를 보고 **직접 요리(함수 실행)**를 합니다.&lt;br&gt;
실행 로직이 에이전트 코드 내부에 깊게 박혀 있는 구조(Tightly Coupled)입니다.&lt;/p&gt;</description></item><item><title>Claude Code 무료 플랜 활용 가이드 (Ollama, free-claude-code)</title><link>https://cdecl.github.io/devops/claude-code-free-plan-usage/</link><pubDate>Mon, 23 Feb 2026 00:00:00 +0900</pubDate><guid>https://cdecl.github.io/devops/claude-code-free-plan-usage/</guid><description>&lt;p&gt;Claude Code를 쓰고 싶은데 유료 API 비용이 부담될 때, 실무에서는 보통 두 가지 경로를 사용합니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Ollama&lt;/code&gt; 기반 로컬 모델 연결&lt;/li&gt;
&lt;li&gt;&lt;code&gt;free-claude-code&lt;/code&gt; 같은 호환 레이어를 통해 &lt;code&gt;NVIDIA NIM&lt;/code&gt;, &lt;code&gt;OpenRouter&lt;/code&gt;, &lt;code&gt;LM Studio&lt;/code&gt; 백엔드 연결&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이 글은 각 방식의 배경, 설치/설정 방법, 그리고 운영 시 주의점을 정리합니다.&lt;/p&gt;
&lt;h2 id="왜-무료-플랜-구성이-필요한가"&gt;왜 &amp;ldquo;무료 플랜&amp;rdquo; 구성이 필요한가&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;코드 에이전트는 반복 호출이 많아 토큰 비용이 빠르게 증가합니다.&lt;/li&gt;
&lt;li&gt;개인 프로젝트나 학습 단계에서는 응답 품질보다 비용 상한이 더 중요할 수 있습니다.&lt;/li&gt;
&lt;li&gt;팀 환경에서는 &amp;ldquo;무조건 최신 고가 모델&amp;quot;보다 &amp;ldquo;저비용 + 재현 가능한 워크플로&amp;quot;가 더 실용적입니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;핵심은, Claude Code UX를 유지하면서 백엔드를 교체하는 것입니다.&lt;/p&gt;</description></item><item><title>Shell 환경변수 정리: export 유효 범위, 인라인 변수, .env 파일</title><link>https://cdecl.github.io/devops/shell-environment-variables-guide/</link><pubDate>Mon, 23 Feb 2026 00:00:00 +0900</pubDate><guid>https://cdecl.github.io/devops/shell-environment-variables-guide/</guid><description>&lt;p&gt;셸에서 환경변수(Environment Variable)는 프로세스가 실행될 때 함께 전달되는 &lt;code&gt;key=value&lt;/code&gt; 형태의 설정값입니다.&lt;br&gt;
CLI 도구 동작 제어, API 키 전달, 실행 경로(PATH) 설정 등 DevOps 작업의 기본 단위로 쓰입니다.&lt;/p&gt;
&lt;h2 id="1-환경변수-정의와-셸에서의-사용-방법"&gt;1. 환경변수 정의와 셸에서의 사용 방법&lt;/h2&gt;
&lt;p&gt;환경변수는 보통 다음 형태를 사용합니다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#8be9fd;font-style:italic"&gt;export&lt;/span&gt; &lt;span style="color:#8be9fd;font-style:italic"&gt;APP_ENV&lt;/span&gt;&lt;span style="color:#ff79c6"&gt;=&lt;/span&gt;production
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#8be9fd;font-style:italic"&gt;export&lt;/span&gt; &lt;span style="color:#8be9fd;font-style:italic"&gt;API_URL&lt;/span&gt;&lt;span style="color:#ff79c6"&gt;=&lt;/span&gt;https://api.example.com
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;확인 방법:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#8be9fd;font-style:italic"&gt;echo&lt;/span&gt; &lt;span style="color:#f1fa8c"&gt;&amp;#34;&lt;/span&gt;&lt;span style="color:#8be9fd;font-style:italic"&gt;$APP_ENV&lt;/span&gt;&lt;span style="color:#f1fa8c"&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;printenv APP_ENV
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;env | rg &lt;span style="color:#f1fa8c"&gt;&amp;#39;^APP_ENV=&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;각 명령의 의미:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;echo &amp;quot;$APP_ENV&amp;quot;&lt;/code&gt;: 현재 셸이 가진 변수 값을 확인 (셸 변수/환경변수 모두 확인 가능)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;printenv APP_ENV&lt;/code&gt;: 현재 프로세스의 &lt;strong&gt;환경변수&lt;/strong&gt;만 확인 (&lt;code&gt;export&lt;/code&gt; 안 된 셸 변수는 안 보임)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;env | rg '^APP_ENV='&lt;/code&gt;: 현재 프로세스의 환경변수 목록에서 패턴 필터링&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;예시:&lt;/p&gt;</description></item><item><title>AI 에이전트(OpenClaw 등)의 LLM 인터페이스 구현 및 툴 콜링 기술 개요</title><link>https://cdecl.github.io/devops/ai-agent-openclaw-llm-interface/</link><pubDate>Sat, 21 Feb 2026 00:00:00 +0900</pubDate><guid>https://cdecl.github.io/devops/ai-agent-openclaw-llm-interface/</guid><description>&lt;p&gt;OpenClaw, Claude 데스크톱 앱, 혹은 로컬 기반의 여러 AI 에이전트들은 내부적으로 LLM(대형 언어 모델)과 어떻게 소통하고, 로컬 환경의 도구(Tool)들을 사용할까요? 이 글에서는 에이전트가 LLM과 인터페이스를 맺는 기술적 구현 내용과 핵심 요소들을 살펴봅니다.&lt;/p&gt;
&lt;h2 id="1-지침-파일agentmd-등-적용-방법"&gt;1. 지침 파일(&lt;code&gt;agent.md&lt;/code&gt; 등) 적용 방법&lt;/h2&gt;
&lt;p&gt;AI 에이전트의 페르소나, 역할, 기본 규칙을 정의하기 위해 주로 &lt;code&gt;.md&lt;/code&gt; 형태의 지침 파일을 사용합니다. (예: &lt;code&gt;agent.md&lt;/code&gt;, &lt;code&gt;system_prompt.txt&lt;/code&gt;, &lt;code&gt;SOUL.md&lt;/code&gt; 등)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;기술적 구현:&lt;/strong&gt;
이러한 지침 파일은 LLM에 전달되는 **시스템 프롬프트(System Prompt)**로 로드됩니다. 에이전트 프로그램이 실행될 때 혹은 세션이 시작될 때 파일 시스템에서 문서를 읽어 LLM의 &lt;code&gt;system&lt;/code&gt; 역할(role) 메시지에 주입합니다.&lt;/p&gt;</description></item><item><title>OpenClaw 용어집 및 운영 지침 가이드</title><link>https://cdecl.github.io/devops/openclaw-glossary-operation-guidelines/</link><pubDate>Tue, 17 Feb 2026 00:00:00 +0900</pubDate><guid>https://cdecl.github.io/devops/openclaw-glossary-operation-guidelines/</guid><description>&lt;p&gt;OpenClaw(ClawdBot 기반)는 개인 AI 에이전트를 메시징 채널과 연결해 운영하는 게이트웨이 중심 프레임워크입니다. 이 문서는 용어를 사람 친화적으로 정리하고, 운영 시 바로 적용할 수 있는 체크리스트와 최신 변경 사항(공식 소스 기준)까지 함께 제공합니다.&lt;/p&gt;
&lt;h2 id="개요"&gt;개요&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;문서 목적: 용어 설명 + 운영 지침 통합 가이드&lt;/li&gt;
&lt;li&gt;최신 정보 범위: 공식 문서와 공식 릴리스만 사용&lt;/li&gt;
&lt;li&gt;최신 반영 기준:
&lt;ul&gt;
&lt;li&gt;GitHub Release &lt;code&gt;v2026.2.15&lt;/code&gt; (게시일: &lt;strong&gt;2026-02-16&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;docs.openclaw.ai의 공식 업데이트 문서&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="핵심-개념-단순-설명"&gt;핵심 개념 (단순 설명)&lt;/h2&gt;
&lt;h3 id="gateway-게이트웨이"&gt;Gateway (게이트웨이)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;모든 메신저(WhatsApp, Telegram, Discord 등)와 에이전트를 연결해 주는 중앙 서버/데몬.&lt;/li&gt;
&lt;li&gt;기본 포트: &lt;code&gt;18789&lt;/code&gt; (WebSocket).&lt;/li&gt;
&lt;li&gt;한 개의 Gateway로 여러 채널과 여러 에이전트를 동시에 관리 가능.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="agent-에이전트"&gt;Agent (에이전트)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;AI 어시스턴트의 &amp;ldquo;뇌&amp;quot;에 해당.&lt;/li&gt;
&lt;li&gt;개별 성격, 메모리, 행동 방식을 가짐.&lt;/li&gt;
&lt;li&gt;각 Agent는 격리된 상태(&lt;code&gt;workspace&lt;/code&gt;, &lt;code&gt;auth&lt;/code&gt;, &lt;code&gt;sessions&lt;/code&gt;)를 유지.&lt;/li&gt;
&lt;li&gt;기본 에이전트 이름: &lt;code&gt;main&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="workspace-작업-폴더"&gt;Workspace (작업 폴더)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Agent의 &amp;ldquo;개인 폴더&amp;quot;로, 기본 경로: &lt;code&gt;~/.openclaw/workspace&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;주요 파일:
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;AGENTS.md&lt;/code&gt;: 동작 지시, 규칙, 메모리.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOUL.md&lt;/code&gt;: 성격, 말투, 경계.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;USER.md&lt;/code&gt;: 사용자 정보와 호칭.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TOOLS.md&lt;/code&gt;: 사용 가능한 도구/툴 설명.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BOOTSTRAP.md&lt;/code&gt;: 최초 실행 설정(한 번 실행 후 삭제).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;memory/YYYY-MM-DD.md&lt;/code&gt;: 일일 메모리 로그.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="agent-directory-agentdir"&gt;Agent Directory (&lt;code&gt;agentDir&lt;/code&gt;)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;에이전트의 기술 설정/인증 정보를 저장.&lt;/li&gt;
&lt;li&gt;기본 경로: &lt;code&gt;~/.openclaw/agents/&amp;lt;agentId&amp;gt;/agent&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;주요 파일:
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;auth-profiles.json&lt;/code&gt;: 모델 제공자(Anthropic, OpenAI 등) 인증 정보.&lt;/li&gt;
&lt;li&gt;에이전트별 모델 설정/구조 파일.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="통신-구조"&gt;통신 구조&lt;/h2&gt;
&lt;h3 id="channel-채널"&gt;Channel (채널)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;메신저 연결 단위.&lt;/li&gt;
&lt;li&gt;예: WhatsApp, Telegram, Discord 각각 하나의 관(pipe).&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="account-id-accountid"&gt;Account ID (&lt;code&gt;accountId&lt;/code&gt;)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;같은 채널 내 여러 계정을 구분.&lt;/li&gt;
&lt;li&gt;예: 개인 WhatsApp, 업무용 WhatsApp.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="session-key-sessionkey"&gt;Session Key (&lt;code&gt;sessionKey&lt;/code&gt;)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;대화 스레드를 구분하는 고유 이름/주소.&lt;/li&gt;
&lt;li&gt;예:
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;agent:main:main&lt;/code&gt; (기본 1:1 대화)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;agent:main:telegram:group:123&lt;/code&gt; (그룹 대화)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="session-id-sessionid"&gt;Session ID (&lt;code&gt;sessionId&lt;/code&gt;)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;실제 대화 기록 파일 ID.&lt;/li&gt;
&lt;li&gt;경로 예: &lt;code&gt;~/.openclaw/agents/&amp;lt;agentId&amp;gt;/sessions/&amp;lt;sessionId&amp;gt;.jsonl&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;세션 재설정 시 값이 바뀜.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="binding-바인딩"&gt;Binding (바인딩)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;라우팅 규칙.&lt;/li&gt;
&lt;li&gt;어떤 채널/계정/연락처에서 온 메시지를 어떤 Agent로 보낼지 결정.&lt;/li&gt;
&lt;li&gt;가장 구체적인 규칙이 우선 적용.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="세션-관리"&gt;세션 관리&lt;/h2&gt;
&lt;h3 id="main-session-기본-대화"&gt;Main Session (기본 대화)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;기본 1:1 대화 세션.&lt;/li&gt;
&lt;li&gt;예: &lt;code&gt;agent:&amp;lt;agentId&amp;gt;:main&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;모든 개인 대화를 한 세션으로 모아 유지할 수 있음.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="dm-scope-dmscope"&gt;DM Scope (&lt;code&gt;dmScope&lt;/code&gt;)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;DM(1:1) 분리 수준 설정.
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;main&lt;/code&gt;: 모든 DM 공유&lt;/li&gt;
&lt;li&gt;&lt;code&gt;per-peer&lt;/code&gt;: 사용자별 분리&lt;/li&gt;
&lt;li&gt;&lt;code&gt;per-channel-peer&lt;/code&gt;: 채널+사용자별 분리&lt;/li&gt;
&lt;li&gt;&lt;code&gt;per-account-channel-peer&lt;/code&gt;: 계정+채널+사용자별 최대 분리&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="session-reset-초기화"&gt;Session Reset (초기화)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;새 대화를 시작할 때 &lt;code&gt;sessionId&lt;/code&gt;를 새로 생성.&lt;/li&gt;
&lt;li&gt;방법:
&lt;ul&gt;
&lt;li&gt;수동: &lt;code&gt;openclaw new&lt;/code&gt;, &lt;code&gt;openclaw reset&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;자동: 지정 시각(예: 매일 04:00), 비활성 시간 기준 자동 리셋&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="compaction-압축요약"&gt;Compaction (압축/요약)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;긴 대화를 요약해 컨텍스트 한도 초과를 방지.&lt;/li&gt;
&lt;li&gt;핵심 맥락은 남기고 오래된 상세를 정리.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="memory-flush-메모리-저장"&gt;Memory Flush (메모리 저장)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Compaction 전에 중요한 정보를 영구 메모리로 기록.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;memory/YYYY-MM-DD.md&lt;/code&gt;에 저장.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NO_REPLY&lt;/code&gt; 내부 메시지로 사용자 노출 없이 처리 가능.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="접근-제어--보안"&gt;접근 제어 / 보안&lt;/h2&gt;
&lt;h3 id="pairing-페어링"&gt;Pairing (페어링)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;새 노드(장치) 연결 시 승인 절차.&lt;/li&gt;
&lt;li&gt;로컬(&lt;code&gt;127.0.0.1&lt;/code&gt;)은 자동 승인 옵션 가능.&lt;/li&gt;
&lt;li&gt;승인 후 토큰 발급으로 접근 허용.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="dm-policy-dmpolicy"&gt;DM Policy (&lt;code&gt;dmPolicy&lt;/code&gt;)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;DM 허용 범위 제어.
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;open&lt;/code&gt;: 누구나 가능(위험)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pairing&lt;/code&gt;: 승인 사용자만&lt;/li&gt;
&lt;li&gt;&lt;code&gt;allowlist&lt;/code&gt;: 허용 목록만&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="allow-from-allowfrom"&gt;Allow From (&lt;code&gt;allowFrom&lt;/code&gt;)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;허용 번호/ID 목록.&lt;/li&gt;
&lt;li&gt;예: &lt;code&gt;+15555550123&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="group-policy-grouppolicy"&gt;Group Policy (&lt;code&gt;groupPolicy&lt;/code&gt;)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;그룹 참여 범위 제어.
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;open&lt;/code&gt;: 모든 그룹(권장하지 않음)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;allowlist&lt;/code&gt;: 허용 그룹만&lt;/li&gt;
&lt;li&gt;&lt;code&gt;denylist&lt;/code&gt;: 차단 목록 제외&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="require-mention"&gt;Require Mention&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;그룹에서 &lt;code&gt;@멘션&lt;/code&gt;이 있을 때만 응답.&lt;/li&gt;
&lt;li&gt;불필요 응답/스팸 방지에 유효.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="gateway-token-openclaw_gateway_token"&gt;Gateway Token (&lt;code&gt;OPENCLAW_GATEWAY_TOKEN&lt;/code&gt;)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Gateway 접속용 공유 비밀.&lt;/li&gt;
&lt;li&gt;WebSocket 인증에 사용.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="sandbox-샌드박스"&gt;Sandbox (샌드박스)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;도구 실행 격리(도커 기반).&lt;/li&gt;
&lt;li&gt;모드:
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;off&lt;/code&gt;: 비격리(전체 시스템 접근)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;non-main&lt;/code&gt;: 메인 세션만 비격리&lt;/li&gt;
&lt;li&gt;&lt;code&gt;all&lt;/code&gt;: 모든 세션 격리&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;스코프: &lt;code&gt;session&lt;/code&gt;, &lt;code&gt;agent&lt;/code&gt;, &lt;code&gt;shared&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;주의&lt;/p&gt;</description></item><item><title>127.0.0.1 vs localhost: 차이와 함정</title><link>https://cdecl.github.io/devops/localhost/</link><pubDate>Sun, 08 Feb 2026 00:00:00 +0900</pubDate><guid>https://cdecl.github.io/devops/localhost/</guid><description>&lt;p&gt;작성일: 2026-02-08&lt;/p&gt;
&lt;p&gt;운영 환경에서 &amp;ldquo;localhost로 붙었는데 왜 안 되지?&amp;rdquo; 같은 문제는 자주 발생합니다. 결론부터 말하면 &lt;code&gt;127.0.0.1&lt;/code&gt;과 &lt;code&gt;localhost&lt;/code&gt;는 보통 같은 의미로 쓰이지만, &lt;strong&gt;항상 동일하게 해석되진 않습니다.&lt;/strong&gt; 이 미묘한 차이가 헬스체크 실패, 접근 불가, 보안 정책 충돌로 이어질 수 있습니다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="1-루프백loopback-정의"&gt;1. 루프백(Loopback) 정의&lt;/h2&gt;
&lt;p&gt;루프백은 &lt;strong&gt;자기 자신에게 되돌아오는 네트워크 경로&lt;/strong&gt;입니다. 물리 NIC 없이도 TCP/IP 스택을 테스트하거나 로컬 프로세스 간 통신을 가능하게 합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IPv4 루프백 대역: &lt;code&gt;127.0.0.0/8&lt;/code&gt; (대표 주소가 &lt;code&gt;127.0.0.1&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;IPv6 루프백 주소: &lt;code&gt;::1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;즉, &lt;code&gt;127.0.0.1&lt;/code&gt;은 &lt;strong&gt;항상 이 머신 자신&lt;/strong&gt;을 의미합니다. DNS나 이름 해석 과정과는 무관합니다.&lt;/p&gt;</description></item><item><title>SSH 리버스 프록시(Reverse Proxy) 네트워크 구성: 설정, 주의 사항, 운영 팁</title><link>https://cdecl.github.io/devops/ssh-reverse-proxy-guide/</link><pubDate>Sun, 08 Feb 2026 00:00:00 +0900</pubDate><guid>https://cdecl.github.io/devops/ssh-reverse-proxy-guide/</guid><description>&lt;p&gt;작성일: 2026-02-08&lt;/p&gt;
&lt;p&gt;SSH 리버스 프록시는 &lt;strong&gt;외부에서 내부로 직접 접근할 수 없는 환경&lt;/strong&gt;에서 유용한 연결 방식입니다. 내부 서버가 외부 서버로 &lt;strong&gt;역방향 터널을 먼저 열어두고&lt;/strong&gt;, 외부 사용자가 그 터널을 통해 내부 서비스에 접근하는 구조입니다. DevOps 환경에서 운영할 때 필요한 구성, 주의 사항, 네트워크 프록시 관점을 정리합니다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="1-개념-정리-ssh-리버스-프록시"&gt;1. 개념 정리: SSH 리버스 프록시&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;일반 SSH 포워딩(로컬 포워딩): &lt;strong&gt;로컬 -&amp;gt; 원격&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;리버스 포워딩(Reverse): &lt;strong&gt;원격 -&amp;gt; 로컬(내부)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;리버스 포워딩은 내부 서버가 먼저 외부(중계) 서버에 접속하고, 외부에서 그 연결을 통해 내부 서비스에 접근하는 방식입니다.&lt;/p&gt;</description></item><item><title>Lazygit 가이드: 설치부터 패널별 치트시트</title><link>https://cdecl.github.io/devops/lazygit-guide/</link><pubDate>Wed, 04 Feb 2026 00:00:00 +0900</pubDate><guid>https://cdecl.github.io/devops/lazygit-guide/</guid><description>&lt;p&gt;Git은 강력하지만 명령어 입력 방식은 때로 직관성이 떨어집니다. 특히 수많은 파일을 개별적으로 스테이징하거나 복잡한 인터랙티브 리베이스를 수행할 때 터미널 UI(TUI) 도구의 진가가 드러납니다. 그중에서도 가장 완성도 높은 도구인 &lt;strong&gt;Lazygit&lt;/strong&gt;을 파헤쳐 봅니다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="1-lazygit-설치-installation"&gt;1. Lazygit 설치 (Installation)&lt;/h2&gt;
&lt;p&gt;환경에 맞는 패키지 매니저를 사용하여 간단히 설치할 수 있습니다.&lt;/p&gt;
&lt;h3 id="macos"&gt;macOS&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;brew install lazygit
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="windows"&gt;Windows&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#6272a4"&gt;# Scoop 사용 시&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;scoop bucket add extras
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;scoop install lazygit
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#6272a4"&gt;# Winget 사용 시&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;winget install jesseduffield.lazygit
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="linux-ubuntudebian-등"&gt;Linux (Ubuntu/Debian 등)&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#6272a4"&gt;# 바이너리 직접 설치 예시&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#8be9fd;font-style:italic"&gt;LAZYGIT_VERSION&lt;/span&gt;&lt;span style="color:#ff79c6"&gt;=&lt;/span&gt;&lt;span style="color:#ff79c6"&gt;$(&lt;/span&gt;curl -s &lt;span style="color:#f1fa8c"&gt;&amp;#34;https://api.github.com/repos/jesseduffield/lazygit/releases/latest&amp;#34;&lt;/span&gt; | grep -Po &lt;span style="color:#f1fa8c"&gt;&amp;#39;&amp;#34;tag_name&amp;#34;: &amp;#34;v\K[^&amp;#34;]*&amp;#39;&lt;/span&gt;&lt;span style="color:#ff79c6"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;curl -Lo lazygit.tar.gz &lt;span style="color:#f1fa8c"&gt;&amp;#34;https://github.com/jesseduffield/lazygit/releases/latest/download/lazygit_&lt;/span&gt;&lt;span style="color:#f1fa8c"&gt;${&lt;/span&gt;&lt;span style="color:#8be9fd;font-style:italic"&gt;LAZYGIT_VERSION&lt;/span&gt;&lt;span style="color:#f1fa8c"&gt;}&lt;/span&gt;&lt;span style="color:#f1fa8c"&gt;_Linux_x86_64.tar.gz&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;tar xf lazygit.tar.gz lazygit
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;sudo install lazygit /usr/local/bin
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h2 id="2-tui-구성-및-레이아웃-layout"&gt;2. TUI 구성 및 레이아웃 (Layout)&lt;/h2&gt;
&lt;p&gt;Lazygit는 한 화면에서 Git의 모든 상태를 조망할 수 있는 &lt;strong&gt;대시보드형 레이아웃&lt;/strong&gt;을 가지고 있습니다.&lt;/p&gt;</description></item><item><title>[AI 엔지니어링] 에이전트의 'Skills' 환상과 56%의 실패율: 왜 우리는 다시 시스템 프롬프트로 돌아가는가?</title><link>https://cdecl.github.io/posts/ai-agent-skills-vs-context/</link><pubDate>Fri, 30 Jan 2026 00:00:00 +0900</pubDate><guid>https://cdecl.github.io/posts/ai-agent-skills-vs-context/</guid><description>&lt;p&gt;최근 AI 개발자 커뮤니티, 특히 Vercel AI SDK와 Cursor 사용자들 사이에서 매우 흥미로운 화두가 던져졌습니다. Vercel의 소프트웨어 엔지니어 Jude Gao가 발표한 **&amp;quot;&lt;a href="https://vercel.com/blog/agents-md-outperforms-skills-in-our-agent-evals"&gt;AGENTS.md outperforms skills in our agent evals&lt;/a&gt;&amp;quot;**라는 벤치마크 결과입니다.&lt;/p&gt;
&lt;p&gt;많은 개발자가 프로젝트를 진행하며 직감적으로 느끼던 현상—&amp;ldquo;도구(Skills)를 쥐여주는 것보다, 그냥 문서를 통째로 읽게 시키는 게 훨씬 낫다&amp;rdquo;—가 실제 데이터로 증명되었습니다. 오늘은 이 벤치마크 데이터와 이를 둘러싼 &amp;lsquo;Skills vs Context vs Subagents&amp;rsquo; 아키텍처의 변화를 심도 있게 분석해 봅니다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="1-충격적인-데이터-56의-무시율-ignore-rate"&gt;1. 충격적인 데이터: 56%의 무시율 (Ignore Rate)&lt;/h2&gt;
&lt;p&gt;우리는 흔히 &amp;ldquo;LLM에게 도구(Tool/Skill/Function Calling)를 주면, 필요할 때마다 똑똑하게 꺼내 쓸 것&amp;quot;이라고 기대합니다. 하지만 Next.js 16 API(당시 미학습 데이터)를 대상으로 한 벤치마크 결과는 이 믿음을 배신했습니다.&lt;/p&gt;</description></item><item><title>macOS 시스템 최적화의 종결자: Mole 유틸리티와 Agent Skills 활용기</title><link>https://cdecl.github.io/devops/mole-utility-guide/</link><pubDate>Thu, 29 Jan 2026 00:00:00 +0900</pubDate><guid>https://cdecl.github.io/devops/mole-utility-guide/</guid><description>&lt;h2 id="서론"&gt;서론&lt;/h2&gt;
&lt;p&gt;유료 앱들의 핵심 기능을 단 하나의 바이너리로 통합한 강력한 오픈소스 CLI 도구, &lt;strong&gt;Mole&lt;/strong&gt;을 소개. 특히 최근 유행하는 AI Agent와 연계하여 시스템 관리를 자동화하는 방법까지 함께 살펴보겠습니다.&lt;/p&gt;
&lt;h2 id="1-mole-유틸리티란"&gt;1. Mole 유틸리티란?&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Mole&lt;/strong&gt;(&lt;a href="https://github.com/tw93/Mole"&gt;tw93/Mole&lt;/a&gt;)은 tw93이 개발한 macOS용 올인원 시스템 유틸리티다. Go 언어와 셸 스크립트로 작성되어 매우 가볍고 빠르며, 터미널 환경에서 모든 시스템 최적화 작업을 통합 관리할 수 있다.&lt;/p&gt;
&lt;h3 id="주요-특징"&gt;주요 특징&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;All-in-One&lt;/strong&gt;: 청소, 앱 삭제, 최적화, 분석, 실시간 모니터링 기능을 단일 바이너리로 통합.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;오픈소스&lt;/strong&gt;: MIT 라이선스 기반의 무료 도구로, 상업용 앱의 광고나 구독 모델 없이 모든 기능 제공.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;초경량&lt;/strong&gt;: CLI 기반으로 동작하여 시스템 리소스 점유율이 매우 낮음.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="2-설치-방법"&gt;2. 설치 방법&lt;/h2&gt;
&lt;p&gt;Homebrew를 통해 간단히 설치 가능하다.&lt;/p&gt;</description></item><item><title>웹에서 만나는 터미널, ttyd 가이드</title><link>https://cdecl.github.io/devops/ttyd/</link><pubDate>Sun, 13 Jul 2025 00:00:00 +0900</pubDate><guid>https://cdecl.github.io/devops/ttyd/</guid><description>&lt;p&gt;이 글에서는 ttyd의 개념부터 설치, 활용법, 그리고 보안 강화 방안까지 상세하게 알아보겠습니다.&lt;/p&gt;
&lt;h3 id="1-ttyd란-무엇인가"&gt;1. ttyd란 무엇인가?&lt;/h3&gt;
&lt;p&gt;개발자, 시스템 관리자, 혹은 단순히 터미널 작업을 즐기는 분이라면 원격으로 &lt;code&gt;shell&lt;/code&gt;에 접속해야 하는 경우가 많습니다. SSH가 가장 일반적인 해결책이지만, 웹 브라우저만 있다면 어디서든 터미널에 접속할 수 있는 더 가벼운 방법이 있습니다. 바로 &lt;strong&gt;ttyd&lt;/strong&gt;입니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ttyd&lt;/strong&gt;는 &amp;lsquo;TTY over Web&amp;rsquo;의 약자로, 명령줄 도구를 웹 애플리케이션으로 변환해 주는 간단하고 효율적인 C언어 기반 프로그램입니다. 내부적으로는 Libwebsockets를 사용하여 웹소켓 통신을 처리하고, 프론트엔드에서는 xterm.js를 통해 완벽한 기능의 터미널을 웹 브라우저에 구현합니다.&lt;/p&gt;</description></item><item><title>모던 쉘 명령어로 터미널 생산성 높이기</title><link>https://cdecl.github.io/devops/moden-shell-command/</link><pubDate>Sun, 25 May 2025 00:00:00 +0900</pubDate><guid>https://cdecl.github.io/devops/moden-shell-command/</guid><description>&lt;p&gt;모던 쉘 명령어: 전통적인 도구를 대체하는 강력한 대안&lt;/p&gt;
&lt;p&gt;터미널은 개발자와 시스템 관리자의 핵심 도구입니다. 하지만 전통적인 쉘 명령어(&lt;code&gt;grep&lt;/code&gt;, &lt;code&gt;sed&lt;/code&gt;, &lt;code&gt;find&lt;/code&gt;, &lt;code&gt;cat&lt;/code&gt;, &lt;code&gt;watch&lt;/code&gt;, &lt;code&gt;top&lt;/code&gt;, &lt;code&gt;du&lt;/code&gt;)는 속도, 가독성, 사용 편의성 면에서 한계가 있습니다. 2025년 기준, 이러한 명령어들을 대체하는 모던 대안들이 주목받고 있습니다. 이 포스트에서는 &lt;code&gt;ripgrep&lt;/code&gt;, &lt;code&gt;sd&lt;/code&gt;, &lt;code&gt;fd&lt;/code&gt;, &lt;code&gt;bat&lt;/code&gt;, &lt;code&gt;hwatch&lt;/code&gt;, &lt;code&gt;htop&lt;/code&gt;, &lt;code&gt;dust&lt;/code&gt;를 전통 명령어와 비교하며 특징과 사용법을 소개합니다.&lt;/p&gt;
&lt;h2 id="모던-쉘-명령어-요약"&gt;모던 쉘 명령어 요약&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;전통 명령어&lt;/th&gt;
&lt;th&gt;모던 대안&lt;/th&gt;
&lt;th&gt;주요 특징&lt;/th&gt;
&lt;th&gt;설치 명령어 (Ubuntu/Debian)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;grep&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;ripgrep (rg)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;고속 검색, &lt;code&gt;.gitignore&lt;/code&gt; 통합, 컬러 출력&lt;/td&gt;
&lt;td&gt;&lt;code&gt;sudo apt-get install ripgrep&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;sed&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;sd&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;간단한 치환 문법, 빠른 처리&lt;/td&gt;
&lt;td&gt;&lt;code&gt;sudo apt-get install sd&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;find&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;fd&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;직관적 검색, &lt;code&gt;.gitignore&lt;/code&gt; 지원&lt;/td&gt;
&lt;td&gt;&lt;code&gt;sudo apt-get install fd-find&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cat&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;bat&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;구문 강조, Git 통합, 페이징&lt;/td&gt;
&lt;td&gt;&lt;code&gt;sudo apt-get install bat&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;watch&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;hwatch&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;변경 강조, 로그 저장&lt;/td&gt;
&lt;td&gt;&lt;code&gt;sudo apt-get install hwatch&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;top&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;htop&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;컬러 UI, 프로세스 트리 뷰&lt;/td&gt;
&lt;td&gt;&lt;code&gt;sudo apt-get install htop&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;du&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;dust&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;트리 구조, 직관적 시각화&lt;/td&gt;
&lt;td&gt;&lt;code&gt;sudo apt-get install dust&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="왜-모던-쉘-명령어가-필요한가"&gt;왜 모던 쉘 명령어가 필요한가?&lt;/h2&gt;
&lt;p&gt;모던 쉘 명령어는 Rust, Go 같은 현대 언어로 작성되어 속도와 효율성이 뛰어나며, 사용자 친화적인 인터페이스를 제공합니다. 주요 장점은 다음과 같습니다:&lt;/p&gt;</description></item><item><title>GitHub Actions YAML 사용법</title><link>https://cdecl.github.io/dev/github-actions-yaml/</link><pubDate>Fri, 23 May 2025 00:00:00 +0900</pubDate><guid>https://cdecl.github.io/dev/github-actions-yaml/</guid><description>&lt;p&gt;GitHub Actions YAML: CI/CD 워크플로우의 핵심&lt;/p&gt;
&lt;p&gt;GitHub Actions는 CI/CD 및 자동화 워크플로우를 정의하는 강력한 도구로, YAML 파일을 통해 설정됩니다. 이 포스트에서는 GitHub Actions YAML의 주요 사용법, 실행 환경, 쉘 스크립트 활용 방법, 그리고 실무에서 유용한 팁을 정리합니다.&lt;/p&gt;
&lt;h2 id="왜-github-actions-yaml이-중요한가"&gt;왜 GitHub Actions YAML이 중요한가?&lt;/h2&gt;
&lt;p&gt;GitHub Actions는 코드 푸시, 풀 리퀘스트, 스케줄링 등 다양한 이벤트를 기반으로 자동화된 워크플로우를 실행할 수 있습니다. YAML 파일은 이를 직관적이고 선언적으로 정의하며, 다음과 같은 장점을 제공합니다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;가독성&lt;/strong&gt;: 명확한 구조로 워크플로우 정의.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;유연성&lt;/strong&gt;: 다양한 환경과 도구 지원.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;재사용성&lt;/strong&gt;: 액션과 워크플로우를 모듈화해 생산성 향상.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;2025년 기준&lt;/strong&gt;: GitHub Actions는 대부분의 주요 언어와 배포 환경을 지원하며, 커뮤니티 액션으로 확장 가능.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="1-github-actions-yaml-기본-구조"&gt;1. GitHub Actions YAML 기본 구조&lt;/h2&gt;
&lt;p&gt;GitHub Actions 워크플로우는 &lt;code&gt;.github/workflows/&lt;/code&gt; 디렉토리에 &lt;code&gt;.yml&lt;/code&gt; 파일로 저장됩니다. 기본 구조는 다음과 같습니다:&lt;/p&gt;</description></item><item><title>xargs - 효율적인 명령어 인수 처리와 병렬 실행</title><link>https://cdecl.github.io/devops/xargs-command-guide/</link><pubDate>Sun, 27 Oct 2024 00:00:00 +0900</pubDate><guid>https://cdecl.github.io/devops/xargs-command-guide/</guid><description>&lt;p&gt;&lt;code&gt;xargs&lt;/code&gt; - 효율적인 명령어 인수 처리와 병렬 실행&lt;/p&gt;
&lt;h2 id="xargs-명령어-효율적인-명령어-확장과-파라미터-전달"&gt;xargs 명령어: 효율적인 명령어 확장과 파라미터 전달&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;xargs&lt;/code&gt; 명령어는 한 명령어의 출력을 다른 명령어의 인수로 전달할 때 유용하게 사용됩니다. 특히 명령어의 파라미터가 길어지거나 여러 파일, 디렉토리를 대상으로 명령어를 실행해야 할 때 &lt;code&gt;xargs&lt;/code&gt;를 사용하면 성능과 효율성을 높일 수 있습니다.&lt;/p&gt;
&lt;h2 id="주요-옵션과-활용-예시"&gt;주요 옵션과 활용 예시&lt;/h2&gt;
&lt;h3 id="1-기본-사용법"&gt;1. 기본 사용법&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;xargs&lt;/code&gt;는 기본적으로 표준 입력에서 받은 데이터를 공백 또는 개행으로 구분하여 후속 명령어의 인수로 전달합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;예시:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#8be9fd;font-style:italic"&gt;echo&lt;/span&gt; &lt;span style="color:#f1fa8c"&gt;&amp;#34;file1 file2 file3&amp;#34;&lt;/span&gt; | xargs ls -l
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;file1&lt;/code&gt;, &lt;code&gt;file2&lt;/code&gt;, &lt;code&gt;file3&lt;/code&gt;을 &lt;code&gt;ls -l&lt;/code&gt;의 인수로 전달하여 파일의 상세 정보를 출력합니다.&lt;/p&gt;</description></item></channel></rss>