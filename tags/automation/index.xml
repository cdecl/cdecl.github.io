<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Automation on cdeclog</title><link>https://cdecl.github.io/tags/automation/</link><description>Recent content in Automation on cdeclog</description><generator>Hugo -- 0.154.5</generator><language>ko-kr</language><lastBuildDate>Tue, 24 Jun 2025 00:00:00 +0900</lastBuildDate><atom:link href="https://cdecl.github.io/tags/automation/index.xml" rel="self" type="application/rss+xml"/><item><title>MCP-SuperAssistant 사용법</title><link>https://cdecl.github.io/dev/superassistant/</link><pubDate>Tue, 24 Jun 2025 00:00:00 +0900</pubDate><guid>https://cdecl.github.io/dev/superassistant/</guid><description>&lt;h2 id="model-context-pro"&gt;Model Context Pro&lt;/h2&gt;
&lt;p&gt;**Model Context Pro&lt;/p&gt;
&lt;h2 id="mcp-superassistant란"&gt;MCP-SuperAssistant란?&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;MCP-SuperAssistant&lt;/strong&gt;는 MCP를 활용해 AI 플랫폼(ChatGPT, Perplexity, Google Gemini, Grok 등)과 외부 데이터 및 도구를 연결하는 크롬 확장 프로그램입니다. 이 도구는 AI 대화 내에서 MCP 도구 호출을 감지하고, 실행 결과를 자동 또는 수동으로 대화에 삽입하여 워크플로우를 간소화합니다. MCP-SuperAssistant는 다양한 AI 플랫폼과의 호환성과 유연한 설정을 통해 개발자와 비즈니스 사용자의 생산성을 극대화합니다.&lt;/p&gt;
&lt;h3 id="mcp-superassistant의-주요-기능"&gt;MCP-SuperAssistant의 주요 기능&lt;/h3&gt;
&lt;p&gt;MCP-SuperAssistant는 다음과 같은 기능을 제공합니다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;다양한 AI 플랫폼 지원&lt;/strong&gt;: ChatGPT, Perplexity, Google Gemini, Grok, Google AI Studio, OpenRouter, DeepSeek 등에서 MCP 도구 실행 가능&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MCP 도구 실행 및 결과 삽입&lt;/strong&gt;: AI 대화 내 도구 호출을 감지해 실행하고 결과를 대화에 삽입&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;실시간 데이터 연결&lt;/strong&gt;: MCP를 통해 콘텐츠 저장소, 비즈니스 앱, 개발 환경 등과 안전하게 연결&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;자동/수동 모드&lt;/strong&gt;: 자동 모드(도구 실행 및 결과 제출 자동화)와 수동 모드(사용자 제어) 지원&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;확장성과 모듈성&lt;/strong&gt;: 플러그인 기반 아키텍처로 새로운 플랫폼 및 도구 추가 가능, WebSocket 및 SSE 지원&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;보안 및 접근성&lt;/strong&gt;: 복잡한 API 키 설정 없이 기존 AI 구독 활용, 최소 설정으로 사용 가능&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;6000+ MCP 서버 지원&lt;/strong&gt;: 다양한 MCP 서버와 통합해 AI 워크플로우 강화&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;특징&lt;/strong&gt;: 확장 프로그램은 간단한 설치로 즉시 사용 가능하며, 샌드박스 환경에서 실행되어 보안성을 유지합니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;제약사항&lt;/strong&gt;: 일부 복잡한 도구 호출은 MCP 서버 설정이 필요하며, AI 모델의 프롬프트 이해도에 따라 결과 정확도가 달라질 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="초기-설치-및-세팅-실행-준비"&gt;초기 설치 및 세팅, 실행 준비&lt;/h2&gt;
&lt;p&gt;MCP-SuperAssistant를 사용하려면 크롬 확장 프로그램 설치와 MCP 프록시 서버 설정이 필요합니다. 아래는 단계별 설치 및 실행 준비 과정입니다.&lt;/p&gt;</description></item><item><title>Gemini CLI의 MCP(Model Context Pro</title><link>https://cdecl.github.io/dev/gemini-cli-mcp-101/</link><pubDate>Mon, 23 Jun 2025 00:00:00 +0900</pubDate><guid>https://cdecl.github.io/dev/gemini-cli-mcp-101/</guid><description>&lt;p&gt;Gemini CLI의 MCP(Model Context Pro&lt;/p&gt;
&lt;h2 id="model-context-pro"&gt;Model Context Pro&lt;/h2&gt;
&lt;p&gt;**Model Context Pro&lt;/p&gt;
&lt;h2 id="gemini-cli와-mcp-지원-개요"&gt;Gemini CLI와 MCP 지원 개요&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Gemini CLI&lt;/strong&gt;는 Google의 생성형 AI 모델인 Gemini를 터미널에서 활용할 수 있는 오픈소스 도구로, MCP를 통해 내장 및 외부 도구와의 통합을 지원합니다. MCP를 활용하면 Gemini CLI는 파일 시스템 작업, 웹 검색, 버전 관리 시스템(Git 등)과의 연동, 또는 사용자 정의 API와의 상호작용과 같은 다양한 기능을 수행할 수 있습니다. Gemini CLI는 MCP를 통해 모델의 컨텍스트를 확장하여 복잡한 작업을 처리하거나, 외부 시스템과의 실시간 데이터 교환을 가능하게 합니다.&lt;/p&gt;</description></item><item><title>GitHub Actions YAML 사용법</title><link>https://cdecl.github.io/dev/github-actions-yaml/</link><pubDate>Fri, 23 May 2025 00:00:00 +0900</pubDate><guid>https://cdecl.github.io/dev/github-actions-yaml/</guid><description>&lt;p&gt;GitHub Actions YAML: CI/CD 워크플로우의 핵심&lt;/p&gt;
&lt;p&gt;GitHub Actions는 CI/CD 및 자동화 워크플로우를 정의하는 강력한 도구로, YAML 파일을 통해 설정됩니다. 이 포스트에서는 GitHub Actions YAML의 주요 사용법, 실행 환경, 쉘 스크립트 활용 방법, 그리고 실무에서 유용한 팁을 정리합니다.&lt;/p&gt;
&lt;h2 id="왜-github-actions-yaml이-중요한가"&gt;왜 GitHub Actions YAML이 중요한가?&lt;/h2&gt;
&lt;p&gt;GitHub Actions는 코드 푸시, 풀 리퀘스트, 스케줄링 등 다양한 이벤트를 기반으로 자동화된 워크플로우를 실행할 수 있습니다. YAML 파일은 이를 직관적이고 선언적으로 정의하며, 다음과 같은 장점을 제공합니다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;가독성&lt;/strong&gt;: 명확한 구조로 워크플로우 정의.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;유연성&lt;/strong&gt;: 다양한 환경과 도구 지원.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;재사용성&lt;/strong&gt;: 액션과 워크플로우를 모듈화해 생산성 향상.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;2025년 기준&lt;/strong&gt;: GitHub Actions는 대부분의 주요 언어와 배포 환경을 지원하며, 커뮤니티 액션으로 확장 가능.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="1-github-actions-yaml-기본-구조"&gt;1. GitHub Actions YAML 기본 구조&lt;/h2&gt;
&lt;p&gt;GitHub Actions 워크플로우는 &lt;code&gt;.github/workflows/&lt;/code&gt; 디렉토리에 &lt;code&gt;.yml&lt;/code&gt; 파일로 저장됩니다. 기본 구조는 다음과 같습니다:&lt;/p&gt;</description></item><item><title>MCP 101</title><link>https://cdecl.github.io/dev/mcp-101/</link><pubDate>Thu, 10 Apr 2025 00:00:00 +0900</pubDate><guid>https://cdecl.github.io/dev/mcp-101/</guid><description>&lt;p&gt;Model Context Pro&lt;/p&gt;
&lt;h2 id="mcp-101-model-context-pro"&gt;MCP 101: Model Context Pro&lt;/h2&gt;
&lt;p&gt;Model Context Pro&lt;/p&gt;
&lt;h2 id="1-mcp란-무엇인가"&gt;1. MCP란 무엇인가?&lt;/h2&gt;
&lt;p&gt;MCP(Model Context Pro&lt;/p&gt;
&lt;h3 id="주요-기능"&gt;주요 기능&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;동적 도구 탐색&lt;/strong&gt;: 도구가 JSON 메타데이터로 자신의 기능을 제공하여 AI가 자동으로 이해하고 활용.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;양방향 통신&lt;/strong&gt;: WebSocket 또는 SSE(Server-Sent Events)를 통해 실시간 상호작용 지원.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AI 중심 설계&lt;/strong&gt;: AI의 의도(intent)를 기반으로 적합한 도구를 동적으로 호출.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="사용-시기"&gt;사용 시기&lt;/h3&gt;
&lt;p&gt;MCP는 다음과 같은 경우에 적합합니다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AI가 외부 리소스(예: GitHub, Google Drive)에 접근하거나 작업을 수행할 때.&lt;/li&gt;
&lt;li&gt;새로운 도구를 동적으로 추가하거나 복잡한 워크플로우를 자동화할 때.&lt;/li&gt;
&lt;li&gt;예: AI가 &amp;ldquo;파일을 읽고 Slack에 공유&amp;quot;하거나 &amp;ldquo;GitHub에서 코드 검색&amp;quot;하는 작업.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="2-mcp와-다른-api의-차이점"&gt;2. MCP와 다른 API의 차이점&lt;/h2&gt;
&lt;p&gt;MCP는 REST API, SOAP와 비교해 AI 중심의 유연성을 제공합니다. 아래는 셀프 디스크립션(self-description)을 중심으로 주요 차이점입니다.&lt;/p&gt;</description></item><item><title>Playwright `page.get_by_role`</title><link>https://cdecl.github.io/dev/playwright-get_by_role/</link><pubDate>Thu, 20 Mar 2025 00:00:00 +0900</pubDate><guid>https://cdecl.github.io/dev/playwright-get_by_role/</guid><description>&lt;p&gt;Playwright &lt;code&gt;page.get_by_role&lt;/code&gt; 역할 기반 요소 탐색&lt;/p&gt;
&lt;h2 id="playwright-pageget_by_role-가이드"&gt;Playwright &lt;code&gt;page.get_by_role&lt;/code&gt; 가이드&lt;/h2&gt;
&lt;h3 id="1-pageget_by_role이란"&gt;1. &lt;code&gt;page.get_by_role&lt;/code&gt;이란?&lt;/h3&gt;
&lt;p&gt;Playwright의 &lt;code&gt;page.get_by_role&lt;/code&gt; 메서드는 웹 페이지에서 요소를 역할(role)에 기반하여 탐색하는 강력한 도구입니다. 이는 접근성(Accessibility) 표준인 ARIA(Accessible Rich Internet Applications)를 활용하여 요소를 식별하며, HTML 태그 대신 사용자가 인식하는 기능적 역할을 기준으로 동작합니다.&lt;/p&gt;
&lt;p&gt;**역할(role)**이란 요소가 웹 페이지에서 수행하는 목적을 정의하는 속성으로, 예를 들어 버튼(&lt;code&gt;button&lt;/code&gt;), 링크(&lt;code&gt;link&lt;/code&gt;), 입력 필드(&lt;code&gt;textbox&lt;/code&gt;) 등이 이에 해당합니다. &lt;code&gt;get_by_role&lt;/code&gt;는 이러한 역할과 선택적으로 &lt;code&gt;name&lt;/code&gt; 속성을 결합하여 요소를 정확히 찾아냅니다.&lt;/p&gt;
&lt;h4 id="주요-기능"&gt;주요 기능&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;접근성 기반 탐색:&lt;/strong&gt; ARIA 표준을 준수하여 요소를 식별.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;직관적 사용:&lt;/strong&gt; 개발자가 요소의 시각적 표현이나 태그 구조 대신 기능적 역할을 지정.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;유연성:&lt;/strong&gt; &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;checked&lt;/code&gt;, &lt;code&gt;disabled&lt;/code&gt; 등의 추가 옵션으로 세부 조정 가능.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이 메서드는 Playwright의 테스트 자동화 및 웹 스크래핑 작업에서 신뢰성과 유지보수성을 높이는 데 적합합니다.&lt;/p&gt;</description></item><item><title>xargs - 효율적인 명령어 인수 처리와 병렬 실행</title><link>https://cdecl.github.io/devops/xargs-command-guide/</link><pubDate>Sun, 27 Oct 2024 00:00:00 +0900</pubDate><guid>https://cdecl.github.io/devops/xargs-command-guide/</guid><description>&lt;p&gt;&lt;code&gt;xargs&lt;/code&gt; - 효율적인 명령어 인수 처리와 병렬 실행&lt;/p&gt;
&lt;h2 id="xargs-명령어-효율적인-명령어-확장과-파라미터-전달"&gt;xargs 명령어: 효율적인 명령어 확장과 파라미터 전달&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;xargs&lt;/code&gt; 명령어는 한 명령어의 출력을 다른 명령어의 인수로 전달할 때 유용하게 사용됩니다. 특히 명령어의 파라미터가 길어지거나 여러 파일, 디렉토리를 대상으로 명령어를 실행해야 할 때 &lt;code&gt;xargs&lt;/code&gt;를 사용하면 성능과 효율성을 높일 수 있습니다.&lt;/p&gt;
&lt;h2 id="주요-옵션과-활용-예시"&gt;주요 옵션과 활용 예시&lt;/h2&gt;
&lt;h3 id="1-기본-사용법"&gt;1. 기본 사용법&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;xargs&lt;/code&gt;는 기본적으로 표준 입력에서 받은 데이터를 공백 또는 개행으로 구분하여 후속 명령어의 인수로 전달합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;예시:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#8be9fd;font-style:italic"&gt;echo&lt;/span&gt; &lt;span style="color:#f1fa8c"&gt;&amp;#34;file1 file2 file3&amp;#34;&lt;/span&gt; | xargs ls -l
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;file1&lt;/code&gt;, &lt;code&gt;file2&lt;/code&gt;, &lt;code&gt;file3&lt;/code&gt;을 &lt;code&gt;ls -l&lt;/code&gt;의 인수로 전달하여 파일의 상세 정보를 출력합니다.&lt;/p&gt;</description></item></channel></rss>