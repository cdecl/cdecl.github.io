<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Ai | cdeclog</title><meta name=keywords content><meta name=description content="cdecl's Dev.Ops Blog"><meta name=author content="Byung Kyu KIM"><link rel=canonical href=https://cdecl.github.io/tags/ai/><link crossorigin=anonymous href=/assets/css/stylesheet.f939c4ffefb264e6fe85e04352266f79db6bb1303c8e16ae9b6064c1247b5e32.css integrity="sha256-+TnE/++yZOb+heBDUiZvedtrsTA8jhaum2BkwSR7XjI=" rel="preload stylesheet" as=style><link rel=icon href=https://cdecl.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://cdecl.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://cdecl.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://cdecl.github.io/apple-touch-icon.png><link rel=mask-icon href=https://cdecl.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://cdecl.github.io/tags/ai/index.xml title=rss><link rel=alternate hreflang=en href=https://cdecl.github.io/tags/ai/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-VQQHHYPN7K"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VQQHHYPN7K")}</script><meta property="og:url" content="https://cdecl.github.io/tags/ai/"><meta property="og:site_name" content="cdeclog"><meta property="og:title" content="Ai"><meta property="og:description" content="cdecl's Dev.Ops Blog"><meta property="og:locale" content="ko-kr"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Ai"><meta name=twitter:description content="cdecl's Dev.Ops Blog"></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://cdecl.github.io/ accesskey=h title="cdeclog (Alt + H)">cdeclog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://cdecl.github.io/dev/ title=Dev><span>Dev</span></a></li><li><a href=https://cdecl.github.io/devops/ title=DevOps><span>DevOps</span></a></li><li><a href=https://cdecl.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://cdecl.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://cdecl.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://cdecl.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://cdecl.github.io/tags/>Tags</a></div><h1>Ai</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>클라우드 2.0의 의의 - AI 시대를 위한 차세대 컴퓨팅</h2></header><div class=entry-content><p>클라우드 컴퓨팅은 IT 인프라의 핵심으로 자리 잡았지만, AI의 급속한 발전과 함께 새로운 진화 단계에 접어들고 있습니다. 클라우드 2.0은 이러한 변화의 중심에 있으며, 기존 클라우드의 한계를 넘어 더 지능적이고 분산된 형태로 발전하고 있습니다. 이 글에서는 온프레미스와 클라우드의 기본 정의 및 비교를 시작으로 클라우드 1.0과 2.0의 정의, 특징, 비교를 살펴보고, AI 시대에서 클라우드 2.0의 의의를 자세히 탐구
온프레미스와 클라우드의 정의 및 비교 온프레미스(On-Premises)와 클라우드 컴퓨팅은 IT 인프라를 구축하는 두 가지 주요 접근 방식입니다. 이 둘의 차이를 이해하는 것은 클라우드 2.0의 맥락을 파악하는 데 필수적입니다.
...</p></div><footer class=entry-footer><span title='2025-10-01 00:00:00 +0900 KST'>October 1, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to 클라우드 2.0의 의의 - AI 시대를 위한 차세대 컴퓨팅" href=https://cdecl.github.io/devops/cloud-2/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Obsidian Smart Composer - 내 모든 노트를 아는 AI 글쓰기 비서</h2></header><div class=entry-content><p>Obsidian은 강력한 노트 테이킹 앱이지만, 방대하게 쌓인 노트를 활용해 새로운 콘텐츠를 만드는 것은 종종 어려운 과제입니다. Obsidian Smart Composer는 이러한 문제를 해결하기 위해 등장한 플러그인으로, 내 볼트(Vault)의 모든 콘텐츠를 이해하는 개인 AI 비서처럼 작동합니다. 이 글에서는 Smart Composer의 핵심 기능과 함께, 실제 시나리오 기반의 효율적인 활용법을 자세히 알아보겠습니다.
Smart Composer란? Smart Composer(GitHub)는 Obsidian 내에서 AI를 활용하여 글쓰기 효율을 극대화하는 플러그인입니다. 단순히 ChatGPT를 연동하는 것을 넘어, 특정 노트나 폴더, 심지어 웹사이트와 유튜브 영상까지 ‘컨텍스트’로 참조하여 AI와 대화할 수 있습니다. 이를 통해 내 지식 기반 위에서 더욱 정확하고 맥락에 맞는 결과물을 얻을 수 있습니다.
...</p></div><footer class=entry-footer><span title='2025-07-24 00:00:00 +0900 KST'>July 24, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to Obsidian Smart Composer - 내 모든 노트를 아는 AI 글쓰기 비서" href=https://cdecl.github.io/devops/obsidian-smart-composer-guide/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Obsidian - Smart Connections 플러그인</h2></header><div class=entry-content><p>이 글에서는 Obsidian Smart Connections 플러그인의 개념부터 기능, 설정 방법, 주요 기능과 예제, 그리고 비슷한 플러그인까지 상세히 알아보겠습니다.
1. Obsidian Smart Connections 플러그인이란? Smart Connections는 Obsidian에서 AI 임베딩을 활용해 노트 간의 의미적 연결을 찾아주는 강력한 플러그인입니다. 사용자의 노트를 분석하여 관련된 콘텐츠를 실시간으로 추천하거나, 노트를 기반으로 대화형 AI와 상호작용할 수 있게 합니다. 블로그 작성, 연구, 지식 관리 등에서 생산성을 높여주며, 특히 대규모 노트 저장소에서 유용합니다.
주요 특징:
의미적 검색: 키워드가 아닌 노트의 의미를 기반으로 관련 노트를 찾아줍니다. 로컬 및 클라우드 AI 지원: Ollama, LM Studio 같은 로컬 모델과 OpenAI, Gemini, Claude 등 100개 이상의 API를 지원합니다. Smart Chat: 노트를 기반으로 AI와 대화하며 질문에 답변하거나 콘텐츠를 생성합니다. 컨텍스트 인식: 현재 노트나 선택한 텍스트를 활용해 관련 콘텐츠를 제안합니다. 오프라인 지원: 로컬 임베딩 모델을 사용해 데이터 프라이버시를 보장합니다. 2. 설치 및 설정 Smart Connections 플러그인은 Obsidian의 커뮤니티 플러그인 마켓에서 설치할 수 있습니다. 아래는 기본 설치 및 설정 방법입니다.
...</p></div><footer class=entry-footer><span title='2025-07-20 00:00:00 +0900 KST'>July 20, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to Obsidian - Smart Connections 플러그인" href=https://cdecl.github.io/devops/obsidian-smart-connections-plugin/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Obsidian Text Generator 플러그인 가이드 (selected_text, context)</h2></header><div class=entry-content><p>이 글에서는 Obsidian Text Generator 플러그인의 개념부터 기능, 설정 방법, 명령어, 예약어 사용법, 그리고 유용한 추가 기능까지 상세히 알아보겠습니다.
1. Obsidian Text Generator 플러그인이란? Obsidian Text Generator 플러그인은 Obsidian에서 AI를 활용해 텍스트를 생성하는 강력한 도구입니다. 노트 작성, 아이디어 생성, 콘텐츠 요약 등 다양한 작업을 자동화하여 생산성을 높여줍니다. 이 플러그인은 사용자가 선택한 텍스트나 노트의 컨텍스트를 기반으로 AI 모델을 통해 문장을 완성하거나 새로운 콘텐츠를 생성합니다.
주요 특징:
다양한 AI 지원: OpenAI(GPT-3, GPT-4), Google Gemini, Anthropic Claude, 그리고 LM Studio와 같은 로컬 모델을 지원합니다. 템플릿 엔진: 반복 작업을 간소화하는 사용자 정의 템플릿을 제공합니다. 컨텍스트 인식: 현재 노트, 선택한 텍스트, 링크된 노트를 활용해 문맥에 맞는 텍스트를 생성합니다. 커뮤니티 템플릿: 다른 사용자의 템플릿을 공유하거나 가져와 다양한 활용 사례를 탐색할 수 있습니다. 유연한 설정: Frontmatter를 통해 AI 모델, 토큰 수, 온도 등을 세부적으로 조정 가능합니다. 2. 설치 및 Gemini 기반 설정 Text Generator 플러그인은 Obsidian의 커뮤니티 플러그인 마켓에서 설치할 수 있습니다. Google Gemini를 사용한 설정 예시는 다음과 같습니다.
...</p></div><footer class=entry-footer><span title='2025-07-17 00:00:00 +0900 KST'>July 17, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to Obsidian Text Generator 플러그인 가이드 (selected_text, context)" href=https://cdecl.github.io/devops/obsidian-text-generator-plugin/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>MCP-SuperAssistant 사용법</h2></header><div class=entry-content><p>Model Context Pro **Model Context Pro
MCP-SuperAssistant란? MCP-SuperAssistant는 MCP를 활용해 AI 플랫폼(ChatGPT, Perplexity, Google Gemini, Grok 등)과 외부 데이터 및 도구를 연결하는 크롬 확장 프로그램입니다. 이 도구는 AI 대화 내에서 MCP 도구 호출을 감지하고, 실행 결과를 자동 또는 수동으로 대화에 삽입하여 워크플로우를 간소화합니다. MCP-SuperAssistant는 다양한 AI 플랫폼과의 호환성과 유연한 설정을 통해 개발자와 비즈니스 사용자의 생산성을 극대화합니다.
MCP-SuperAssistant의 주요 기능 MCP-SuperAssistant는 다음과 같은 기능을 제공합니다:
다양한 AI 플랫폼 지원: ChatGPT, Perplexity, Google Gemini, Grok, Google AI Studio, OpenRouter, DeepSeek 등에서 MCP 도구 실행 가능 MCP 도구 실행 및 결과 삽입: AI 대화 내 도구 호출을 감지해 실행하고 결과를 대화에 삽입 실시간 데이터 연결: MCP를 통해 콘텐츠 저장소, 비즈니스 앱, 개발 환경 등과 안전하게 연결 자동/수동 모드: 자동 모드(도구 실행 및 결과 제출 자동화)와 수동 모드(사용자 제어) 지원 확장성과 모듈성: 플러그인 기반 아키텍처로 새로운 플랫폼 및 도구 추가 가능, WebSocket 및 SSE 지원 보안 및 접근성: 복잡한 API 키 설정 없이 기존 AI 구독 활용, 최소 설정으로 사용 가능 6000+ MCP 서버 지원: 다양한 MCP 서버와 통합해 AI 워크플로우 강화 특징: 확장 프로그램은 간단한 설치로 즉시 사용 가능하며, 샌드박스 환경에서 실행되어 보안성을 유지합니다. 제약사항: 일부 복잡한 도구 호출은 MCP 서버 설정이 필요하며, AI 모델의 프롬프트 이해도에 따라 결과 정확도가 달라질 수 있습니다. 초기 설치 및 세팅, 실행 준비 MCP-SuperAssistant를 사용하려면 크롬 확장 프로그램 설치와 MCP 프록시 서버 설정이 필요합니다. 아래는 단계별 설치 및 실행 준비 과정입니다.
...</p></div><footer class=entry-footer><span title='2025-06-24 00:00:00 +0900 KST'>June 24, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to MCP-SuperAssistant 사용법" href=https://cdecl.github.io/dev/superassistant/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Gemini CLI의 MCP(Model Context Pro</h2></header><div class=entry-content><p>Gemini CLI의 MCP(Model Context Pro
Model Context Pro **Model Context Pro
Gemini CLI와 MCP 지원 개요 Gemini CLI는 Google의 생성형 AI 모델인 Gemini를 터미널에서 활용할 수 있는 오픈소스 도구로, MCP를 통해 내장 및 외부 도구와의 통합을 지원합니다. MCP를 활용하면 Gemini CLI는 파일 시스템 작업, 웹 검색, 버전 관리 시스템(Git 등)과의 연동, 또는 사용자 정의 API와의 상호작용과 같은 다양한 기능을 수행할 수 있습니다. Gemini CLI는 MCP를 통해 모델의 컨텍스트를 확장하여 복잡한 작업을 처리하거나, 외부 시스템과의 실시간 데이터 교환을 가능하게 합니다.
...</p></div><footer class=entry-footer><span title='2025-06-23 00:00:00 +0900 KST'>June 23, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to Gemini CLI의 MCP(Model Context Pro" href=https://cdecl.github.io/dev/gemini-cli-mcp-101/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Gemini CLI 툴 소개</h2></header><div class=entry-content><p>Gemini CLI 툴: VSCode 플러그인과의 차이, 활용법, 실전 시나리오
Gemini CLI 이란? Gemini CLI는 Google의 생성형 AI 모델인 Gemini를 터미널 환경에서 직접 사용할 수 있도록 지원하는 커맨드라인 도구입니다. 이 도구를 활용하여 코드 생성, 요약, 번역, 문서화 등 다양한 AI 기능을 명령어 한 줄로 빠르게 수행할 수 있습니다. 특히, 별도의 통합 개발 환경(IDE) 없이도 쉘 스크립트, 자동화, 지속적 통합(CI)과 같은 다양한 환경에서 AI 기능을 활용할 수 있다는 점이 큰 특징입니다. Gemini CLI는 또한 **mcp(Model Context Pro
...</p></div><footer class=entry-footer><span title='2025-06-22 00:00:00 +0900 KST'>June 22, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to Gemini CLI 툴 소개" href=https://cdecl.github.io/dev/gemini-cli/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>MCP 101</h2></header><div class=entry-content><p>Model Context Pro
MCP 101: Model Context Pro Model Context Pro
1. MCP란 무엇인가? MCP(Model Context Pro
주요 기능 동적 도구 탐색: 도구가 JSON 메타데이터로 자신의 기능을 제공하여 AI가 자동으로 이해하고 활용. 양방향 통신: WebSocket 또는 SSE(Server-Sent Events)를 통해 실시간 상호작용 지원. AI 중심 설계: AI의 의도(intent)를 기반으로 적합한 도구를 동적으로 호출. 사용 시기 MCP는 다음과 같은 경우에 적합합니다:
AI가 외부 리소스(예: GitHub, Google Drive)에 접근하거나 작업을 수행할 때. 새로운 도구를 동적으로 추가하거나 복잡한 워크플로우를 자동화할 때. 예: AI가 “파일을 읽고 Slack에 공유"하거나 “GitHub에서 코드 검색"하는 작업. 2. MCP와 다른 API의 차이점 MCP는 REST API, SOAP와 비교해 AI 중심의 유연성을 제공합니다. 아래는 셀프 디스크립션(self-description)을 중심으로 주요 차이점입니다.
...</p></div><footer class=entry-footer><span title='2025-04-10 00:00:00 +0900 KST'>April 10, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to MCP 101" href=https://cdecl.github.io/dev/mcp-101/></a></article></main><footer class=footer><span>&copy; 2026 <a href=https://cdecl.github.io/>cdeclog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>