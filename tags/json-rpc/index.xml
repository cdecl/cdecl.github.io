<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Json-Rpc on cdeclog</title><link>https://cdecl.github.io/tags/json-rpc/</link><description>Recent content in Json-Rpc on cdeclog</description><generator>Hugo -- 0.156.0</generator><language>ko-kr</language><lastBuildDate>Mon, 23 Feb 2026 00:00:00 +0900</lastBuildDate><atom:link href="https://cdecl.github.io/tags/json-rpc/index.xml" rel="self" type="application/rss+xml"/><item><title>AI Agent 구현의 두 갈래: 일반 Tool Calling vs MCP 비교</title><link>https://cdecl.github.io/devops/ai-agent-tool-calling-vs-mcp/</link><pubDate>Mon, 23 Feb 2026 00:00:00 +0900</pubDate><guid>https://cdecl.github.io/devops/ai-agent-tool-calling-vs-mcp/</guid><description>&lt;p&gt;AI 에이전트를 구축할 때, LLM이 외부 도구를 사용하게 만드는 과정은 필수적입니다. 하지만 최근 등장한 **MCP(Model Context Protocol)**와 기존의 &lt;strong&gt;Function/Tool Calling&lt;/strong&gt;은 비슷해 보이면서도 구조적으로 큰 차이가 있습니다. 오늘은 이 두 방식의 특징과 실제 구현 관점에서의 차이를 상세히 비교해 보겠습니다.&lt;/p&gt;
&lt;h2 id="1-한눈에-보는-비교-요약"&gt;1. 한눈에 보는 비교 요약&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style="text-align: left"&gt;구분&lt;/th&gt;
&lt;th style="text-align: left"&gt;일반 Tool Calling (기존 방식)&lt;/th&gt;
&lt;th style="text-align: left"&gt;MCP (Model Context Protocol)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: left"&gt;&lt;strong&gt;핵심 개념&lt;/strong&gt;&lt;/td&gt;
&lt;td style="text-align: left"&gt;함수 정의와 실행 로직의 수동 연결&lt;/td&gt;
&lt;td style="text-align: left"&gt;도구의 정의와 실행이 결합된 표준화된 서버&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left"&gt;&lt;strong&gt;실행 주체&lt;/strong&gt;&lt;/td&gt;
&lt;td style="text-align: left"&gt;에이전트 애플리케이션 (Local, Tightly Coupled)&lt;/td&gt;
&lt;td style="text-align: left"&gt;독립된 MCP 서버 (Remote/Isolated)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left"&gt;&lt;strong&gt;통신 규격&lt;/strong&gt;&lt;/td&gt;
&lt;td style="text-align: left"&gt;모델별 전용 API (OpenAI, Anthropic 등)&lt;/td&gt;
&lt;td style="text-align: left"&gt;&lt;strong&gt;JSON-RPC 2.0&lt;/strong&gt; 표준 프로토콜&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left"&gt;&lt;strong&gt;툴 목록 관리&lt;/strong&gt;&lt;/td&gt;
&lt;td style="text-align: left"&gt;코드에 하드코딩, 앱 재배포 필요&lt;/td&gt;
&lt;td style="text-align: left"&gt;서버에서 동적으로 &lt;code&gt;list_tools()&lt;/code&gt; 조회&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left"&gt;&lt;strong&gt;확장성&lt;/strong&gt;&lt;/td&gt;
&lt;td style="text-align: left"&gt;새 툴 추가 시 앱 코드 수정 및 재배포&lt;/td&gt;
&lt;td style="text-align: left"&gt;MCP 서버만 추가·재시작하면 즉시 연동&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left"&gt;&lt;strong&gt;상호운용성&lt;/strong&gt;&lt;/td&gt;
&lt;td style="text-align: left"&gt;모델별 규격 변환 코드 직접 작성 필요&lt;/td&gt;
&lt;td style="text-align: left"&gt;MCP 지원 클라이언트라면 어떤 모델이든 재사용&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left"&gt;&lt;strong&gt;컨텍스트 제공&lt;/strong&gt;&lt;/td&gt;
&lt;td style="text-align: left"&gt;주로 &amp;lsquo;액션(함수 호출)&amp;lsquo;에 집중&lt;/td&gt;
&lt;td style="text-align: left"&gt;툴 + &lt;strong&gt;리소스(파일, DB)&lt;/strong&gt; + &lt;strong&gt;프롬프트 템플릿&lt;/strong&gt; 패키지&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left"&gt;&lt;strong&gt;보안/격리&lt;/strong&gt;&lt;/td&gt;
&lt;td style="text-align: left"&gt;에이전트 프로세스 내에서 직접 실행&lt;/td&gt;
&lt;td style="text-align: left"&gt;실행 로직이 서버에 캡슐화, 권한 경계 명확&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id="2-일반-tool-calling-직접-요리하기-방식"&gt;2. 일반 Tool Calling: &amp;ldquo;직접 요리하기&amp;rdquo; 방식&lt;/h2&gt;
&lt;p&gt;일반적인 방식에서 에이전트는 요리사(LLM)가 준 레시피(JSON)를 보고 **직접 요리(함수 실행)**를 합니다.&lt;br&gt;
실행 로직이 에이전트 코드 내부에 깊게 박혀 있는 구조(Tightly Coupled)입니다.&lt;/p&gt;</description></item></channel></rss>