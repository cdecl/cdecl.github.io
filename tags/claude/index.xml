<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Claude on cdeclog</title><link>https://cdecl.github.io/tags/claude/</link><description>Recent content in Claude on cdeclog</description><generator>Hugo -- 0.156.0</generator><language>ko-kr</language><lastBuildDate>Mon, 23 Feb 2026 00:00:00 +0900</lastBuildDate><atom:link href="https://cdecl.github.io/tags/claude/index.xml" rel="self" type="application/rss+xml"/><item><title>Claude Code 무료 플랜 활용 가이드 (Ollama, free-claude-code)</title><link>https://cdecl.github.io/devops/claude-code-free-plan-usage/</link><pubDate>Mon, 23 Feb 2026 00:00:00 +0900</pubDate><guid>https://cdecl.github.io/devops/claude-code-free-plan-usage/</guid><description>&lt;p&gt;Claude Code를 쓰고 싶은데 유료 API 비용이 부담될 때, 실무에서는 보통 두 가지 경로를 사용합니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Ollama&lt;/code&gt; 기반 로컬 모델 연결&lt;/li&gt;
&lt;li&gt;&lt;code&gt;free-claude-code&lt;/code&gt; 같은 호환 레이어를 통해 &lt;code&gt;NVIDIA NIM&lt;/code&gt;, &lt;code&gt;OpenRouter&lt;/code&gt;, &lt;code&gt;LM Studio&lt;/code&gt; 백엔드 연결&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이 글은 각 방식의 배경, 설치/설정 방법, 그리고 운영 시 주의점을 정리합니다.&lt;/p&gt;
&lt;h2 id="왜-무료-플랜-구성이-필요한가"&gt;왜 &amp;ldquo;무료 플랜&amp;rdquo; 구성이 필요한가&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;코드 에이전트는 반복 호출이 많아 토큰 비용이 빠르게 증가합니다.&lt;/li&gt;
&lt;li&gt;개인 프로젝트나 학습 단계에서는 응답 품질보다 비용 상한이 더 중요할 수 있습니다.&lt;/li&gt;
&lt;li&gt;팀 환경에서는 &amp;ldquo;무조건 최신 고가 모델&amp;quot;보다 &amp;ldquo;저비용 + 재현 가능한 워크플로&amp;quot;가 더 실용적입니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;핵심은, Claude Code UX를 유지하면서 백엔드를 교체하는 것입니다.&lt;/p&gt;</description></item><item><title>OpenRouter - 모든 AI 모델을 하나로 연결하는 관문</title><link>https://cdecl.github.io/devops/openrouter-ai-gateway-guide/</link><pubDate>Wed, 23 Jul 2025 00:00:00 +0900</pubDate><guid>https://cdecl.github.io/devops/openrouter-ai-gateway-guide/</guid><description>&lt;p&gt;수많은 대규모 언어 모델(LLM)이 등장하면서, 개발자와 기획자들은 프로젝트에 가장 적합한 모델을 선택하고 연동하는 데 많은 시간과 노력을 쏟고 있습니다. OpenRouter는 이러한 문제를 해결하기 위해 등장한 플랫폼으로, 다양한 AI 모델을 단일 API로 통합하여 제공하는 &amp;lsquo;AI의 관문(Gateway)&amp;rsquo; 역할을 합니다. 이 글에서는 OpenRouter의 핵심 기능부터 요금 체계, 활용 방법까지 자세히 알아보겠습니다.&lt;/p&gt;
&lt;h2 id="openrouter란"&gt;OpenRouter란?&lt;/h2&gt;
&lt;p&gt;OpenRouter(&lt;a href="https://openrouter.ai/"&gt;https://openrouter.ai/&lt;/a&gt;)는 GPT-4, Claude 3.5 Sonnet, Gemini 2.5 Flash, Llama 3.1 등 여러 제공업체의 최신 AI 모델들을 하나의 표준화된 API 엔드포인트로 묶어 제공하는 서비스입니다. 개발자는 더 이상 각 모델의 API 문서를 따로 학습하거나, 여러 결제 시스템을 관리할 필요 없이 OpenRouter를 통해 원하는 모델을 손쉽게 테스트하고 실제 프로덕션에 적용할 수 있습니다.&lt;/p&gt;</description></item><item><title>MCP 101</title><link>https://cdecl.github.io/dev/mcp-101/</link><pubDate>Thu, 10 Apr 2025 00:00:00 +0900</pubDate><guid>https://cdecl.github.io/dev/mcp-101/</guid><description>&lt;p&gt;Model Context Pro&lt;/p&gt;
&lt;h2 id="mcp-101-model-context-pro"&gt;MCP 101: Model Context Pro&lt;/h2&gt;
&lt;p&gt;Model Context Pro&lt;/p&gt;
&lt;h2 id="1-mcp란-무엇인가"&gt;1. MCP란 무엇인가?&lt;/h2&gt;
&lt;p&gt;MCP(Model Context Pro&lt;/p&gt;
&lt;h3 id="주요-기능"&gt;주요 기능&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;동적 도구 탐색&lt;/strong&gt;: 도구가 JSON 메타데이터로 자신의 기능을 제공하여 AI가 자동으로 이해하고 활용.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;양방향 통신&lt;/strong&gt;: WebSocket 또는 SSE(Server-Sent Events)를 통해 실시간 상호작용 지원.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AI 중심 설계&lt;/strong&gt;: AI의 의도(intent)를 기반으로 적합한 도구를 동적으로 호출.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="사용-시기"&gt;사용 시기&lt;/h3&gt;
&lt;p&gt;MCP는 다음과 같은 경우에 적합합니다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AI가 외부 리소스(예: GitHub, Google Drive)에 접근하거나 작업을 수행할 때.&lt;/li&gt;
&lt;li&gt;새로운 도구를 동적으로 추가하거나 복잡한 워크플로우를 자동화할 때.&lt;/li&gt;
&lt;li&gt;예: AI가 &amp;ldquo;파일을 읽고 Slack에 공유&amp;quot;하거나 &amp;ldquo;GitHub에서 코드 검색&amp;quot;하는 작업.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="2-mcp와-다른-api의-차이점"&gt;2. MCP와 다른 API의 차이점&lt;/h2&gt;
&lt;p&gt;MCP는 REST API, SOAP와 비교해 AI 중심의 유연성을 제공합니다. 아래는 셀프 디스크립션(self-description)을 중심으로 주요 차이점입니다.&lt;/p&gt;</description></item></channel></rss>