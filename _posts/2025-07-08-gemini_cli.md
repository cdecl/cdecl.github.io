---
title: 구글의 AI 코딩 어시스턴트, Gemini CLI 사용 가이드

toc: true
toc_sticky: true

categories:
  - devops

tags:
  - gemini-cli
  - ai-coding
  - google-gemini
  - cli
  - developer-tools
  - autonomous-coding

---

Gemini CLI의 핵심 개념, 주요 기능, 설치 및 구성 방법, 그리고 다른 AI 코딩 도우미와의 비교를 통해 Gemini CLI를 효과적으로 활용하는 방법을 알아봅니다.

## Gemini CLI란?

Gemini CLI는 구글에서 개발한 대화형 AI 코딩 어시스턴트로, 터미널 환경에서 직접 작동합니다. 개발자는 자연어 명령을 통해 복잡한 개발 작업을 Gemini에게 위임할 수 있습니다. 파일 시스템 조작, 코드 리팩토링, 셸 명령어 실행, Git 버전 관리 등 다양한 작업을 자동화하여 개발 생산성을 크게 향상시킵니다. 이 포스트에서는 Gemini CLI의 핵심 철학, 주요 기능, 설치 및 구성, 그리고 GitHub Copilot CLI와의 비교를 통해 그 차이점을 명확히 설명합니다.

## Gemini CLI의 핵심 개념

Gemini CLI를 이해하기 위한 주요 개념은 다음과 같습니다:

- **에이전트 기반 워크플로우**: Gemini CLI는 단순한 명령어 제안을 넘어, 사용자의 요청을 이해하고 스스로 계획을 세워 작업을 수행하는 **자율 에이전트**처럼 작동합니다. 사용자는 목표를 제시하고, Gemini는 그 목표를 달성하기 위해 필요한 도구를 순차적으로 사용합니다.
- **도구(Tools)와 MCP 지원**: Gemini CLI는 강력한 **기본 도구 세트**와 함께, **MCP(Model Context Protocol)를 직접 지원**하여 사용자 정의 도구를 통한 무한한 확장성을 제공합니다. 이를 통해 개발자는 자신만의 도구를 만들어 Gemini CLI의 능력을 특정 도메인이나 워크플로우에 맞게 확장할 수 있습니다.
  - **기본 제공 도구 (Built-in Tools)**:
    Gemini CLI는 로컬 환경과 상호작용하고, 정보를 가져오며, 다양한 작업을 수행하기 위해 Gemini 모델이 사용하는 강력한 내장 도구 세트를 포함하고 있습니다. 이 도구들은 단순한 텍스트 생성을 넘어 광범위한 개발 작업을 지원합니다.

    - **파일 시스템 도구 (`read_file`, `write_file`, `replace`, `list_directory`, `glob`, `search_file_content`)**:
      로컬 파일 시스템과 직접 상호작용하여 파일을 읽고, 쓰고, 수정하며, 디렉토리 내용을 나열하고, 특정 패턴과 일치하는 파일을 찾거나 파일 내용 내에서 특정 문자열을 검색합니다. 이를 통해 코드베이스를 탐색하고 수정하는 대부분의 작업을 자동화할 수 있습니다.

    - **셸 도구 (`run_shell_command`)**:
      사용자의 명시적인 승인 하에 터미널 명령을 직접 실행합니다. `npm install`, `pytest`, `git commit` 등 모든 종류의 스크립트와 명령을 실행할 수 있어, 빌드, 테스트, 배포 파이프라인을 완벽하게 자동화할 수 있습니다. 모든 민감한 작업 전에는 사용자에게 실행할 명령을 보여주고 확인을 받으므로 안전하게 사용할 수 있습니다.

    - **웹 도구 (`web_fetch`, `google_web_search`)**:
      URL에서 직접 콘텐츠를 가져오거나, Google 검색을 통해 웹에서 최신 정보를 찾습니다. "최신 버전의 React 문서를 요약해줘" 와 같은 요청을 처리하여, 개발자가 브라우저를 열지 않고도 필요한 정보를 얻을 수 있도록 돕습니다.

    - **멀티 파일 읽기 도구 (`read_many_files`)**:
      여러 파일이나 디렉토리의 내용을 한 번에 읽어오는 특수 도구입니다. `@` 명령과 함께 자주 사용되며, 프로젝트의 여러 부분에 대한 컨텍스트를 한 번에 파악해야 하는 복잡한 작업에 매우 유용합니다.

    - **메모리 도구 (`save_memory`)**:
      세션 간에 정보를 저장하고 불러오는 데 사용됩니다. `gemini.md` 파일과 연동하여 프로젝트의 중요한 규칙이나 사용자의 선호도를 영구적으로 기억하게 만드는 핵심 도구입니다.
  - **커스텀 도구 (MCP 지원)**:
    Gemini CLI는 `.gemini/settings.json` 파일을 통해 MCP 서버를 등록하고, 이를 커스텀 도구로 활용할 수 있습니다.
    - **설정 방법 (`.gemini/settings.json`)**:
      ```json
      {
        "mcpServers": {
          "filesystem": {
            "command": "npx",
            "args": ["-y", "@modelcontextprotocol/server-filesystem", "./"]
          },
          "github": {
            "command": "npx",
            "args": ["-y", "@modelcontextprotocol/server-github"],
            "env": {
              "GITHUB_TOKEN": "your_github_token"
            }
          },
          "playwright": {
            "command": "npx",
            "args": ["-y", "@playwright/mcp"]
          }
        }
      }
      ```
    - **사용 예시**:
      위와 같이 `github` MCP 서버가 설정된 상태에서, 다음과 같이 자연어로 명령할 수 있습니다.
      > **gemini-cli> "이 저장소에서 'refactor' 라벨이 붙은 가장 오래된 이슈를 찾아줘."**
      Gemini는 등록된 `github` MCP 서버를 통해 GitHub API와 상호작용하여 해당 이슈를 찾아 사용자에게 보여줍니다.

- **영구적인 메모리 (`gemini.md`)**: Gemini CLI는 프로젝트 루트 디렉토리에 있는 `gemini.md` 파일을 **영구적인 메모리**로 활용합니다. 사용자가 "이 내용을 기억해줘"라고 말하거나, 대화 중 중요한 정보(예: 아키텍처 결정, 코딩 스타일 가이드라인, 팀의 규칙)가 발생하면 Gemini는 이를 `gemini.md` 파일에 요약하여 저장합니다.
  - **작동 방식**:
    1. 사용자가 "우리 팀은 모든 API 응답을 Zod 스키마로 검증해야 한다고 기억해줘" 라고 요청합니다.
    2. Gemini는 해당 내용을 `gemini.md` 파일에 다음과 같이 추가합니다.
   
       ```text
       ## Project Guidelines
       - All API responses must be validated using Zod schemas.
       ```

    3. 이후의 모든 대화와 작업에서, Gemini는 `gemini.md` 파일을 먼저 참조하여 프로젝트의 규칙과 맥락을 벗어나지 않는 결과물을 생성합니다. 이를 통해 일관성 있는 개발을 유지할 수 있습니다.
- **컨텍스트 인식**: Gemini CLI는 현재 작업 중인 디렉토리의 파일 구조와 내용을 파악하여 사용자의 요청에 대한 깊은 문맥을 이해합니다. 이를 통해 더 정확하고 관련성 높은 응답을 제공합니다.
- **사용자 승인 기반의 안전성**: 파일 시스템을 변경하거나 명령어를 실행하는 등 중요한 작업을 수행하기 전에는 항상 사용자에게 실행 여부를 묻고 **명시적인 승인**을 받습니다. 이는 잠재적인 위험을 방지하고 사용자가 모든 과정을 제어할 수 있도록 보장합니다.

### Gemini CLI의 역할
Gemini CLI는 개발자와 소통하며 복잡한 문제를 해결하는 **AI 페어 프로그래머** 역할을 합니다. 주요 역할은 다음과 같습니다:
- **코드베이스 탐색 및 이해**: "이 프로젝트에서 'User' 모델이 어떻게 사용되는지 알려줘"와 같은 질문에 답하기 위해 코드를 검색하고 분석합니다.
- **자동화된 코드 수정**: "모든 API 요청에 타임아웃 로직을 추가해줘"와 같은 복잡한 리팩토링 작업을 여러 파일에 걸쳐 자동으로 수행합니다.
- **개발 환경 설정**: "이 프로젝트에 필요한 의존성을 설치하고 데이터베이스를 마이그레이션해줘" 같은 요청을 받아 `package.json`을 읽고 필요한 셸 명령을 실행합니다.
- **테스트 및 디버깅**: "이 함수에 대한 테스트 코드를 작성하고 실행해줘"라는 요청에 따라 테스트 파일을 생성하고 테스트 명령을 실행하여 결과를 보고합니다.

## Gemini CLI 설치 및 구성

Gemini CLI는 간단한 절차를 통해 설치하고 바로 사용할 수 있습니다.

### 1. 설치 및 구성
- **필수 요구사항**:
  - Node.js 및 npm (또는 해당 패키지 매니저) 설치.
  - Google AI Studio에서 Gemini API 키 발급.

- **설치 단계 (예시)**:
  1. 터미널에서 다음 명령을 실행하여 Gemini CLI를 전역으로 설치합니다.
     ```bash
     npm install -g @google/gemini-cli
     ```
  2. 설치가 완료되면 API 키를 설정합니다.
     ```bash
     gemini config set api_key YOUR_GOOGLE_API_KEY
     ```
  3. (선택) 선호하는 Gemini 모델을 기본값으로 설정할 수 있습니다.
     ```bash
     gemini config set model gemini-1.5-pro-latest
     ```

### 2. 기본 사용
- **Gemini CLI 실행**: 터미널에서 `gemini-cli` 또는 `gcli`와 같은 명령어로 세션을 시작합니다.
- **자연어 요청**:
  - 프롬프트에 원하는 작업을 자유롭게 입력합니다.
  - 예: "현재 디렉토리에 있는 `main.py` 파일을 읽고, PEP 8 스타일 가이드에 맞게 수정해줘."
- **도구 사용 승인**: Gemini가 파일 수정이나 명령어 실행과 같은 도구를 사용하려고 할 때, 사용자에게 승인을 요청하는 프롬프트가 표시됩니다. `y`를 눌러 승인하거나 `n`을 눌러 취소할 수 있습니다.
- **대화 지속**: Gemini는 이전 대화와 작업 내용을 기억하므로, "방금 수정한 파일에 대한 커밋 메시지를 작성해줘"와 같이 연속적인 요청을 할 수 있습니다.

## 지원 AI 모델

Gemini CLI는 구글의 최신 Gemini 모델들을 활용하여 강력한 성능을 제공합니다.

- **Gemini 1.5 Pro**: 방대한 컨텍스트 창(최대 100만 토큰)과 멀티모달 이해 능력을 갖춘 플래그십 모델입니다. 복잡한 코드베이스 분석 및 대규모 리팩토링에 가장 적합합니다.
- **Gemini 1.5 Flash**: Pro 모델보다 빠르고 비용 효율적인 모델입니다. 일반적인 코드 생성, 파일 조작, 간단한 스크립팅 작업에 이상적입니다.
- **기타 모델**: 사용자는 필요에 따라 다른 Gemini 모델 버전도 선택하여 사용할 수 있습니다.

**모델 선택 팁**:
- **일상적인 작업**: Gemini 1.5 Flash는 빠른 응답 속도와 낮은 비용으로 대부분의 개발 작업을 처리하기에 충분합니다.
- **복잡한 분석 및 대규모 변경**: 프로젝트 전체에 대한 깊은 이해가 필요하거나 여러 파일에 걸친 대규모 변경이 필요할 때는 Gemini 1.5 Pro를 사용하는 것이 좋습니다.

## 유용한 기능 리스트

Gemini CLI는 개발 워크플로우를 가속화하는 다양한 기능을 제공합니다.

1. **대화형 코드 생성 및 수정**: 자연어 대화를 통해 코드를 생성하고 즉시 파일에 쓰거나 기존 코드를 수정합니다.
2. **파일 시스템과의 완벽한 통합**: `ls -R`, `cat`, `mkdir`과 같은 파일 시스템 명령을 자연어로 요청하고 Gemini가 대신 실행하도록 할 수 있습니다.
3. **셸 명령어 실행 및 결과 분석**: 테스트 실행, 패키지 설치, 빌드 등 모든 셸 명령을 실행하고, 그 결과를 바탕으로 다음 작업을 이어나갈 수 있습니다. (예: 테스트 실패 시 자동으로 디버깅 시작)
4. **Git 워크플로우 자동화**: `git status`로 변경 사항을 확인하고, `git add`로 파일을 스테이징한 후, 의미 있는 커밋 메시지를 생성하여 `git commit`까지 한 번에 처리할 수 있습니다.
5. **웹 검색 통합**: "최신 React 버전의 주요 변경 사항을 알려줘"와 같이 외부 정보가 필요한 경우, 웹 검색을 통해 최신 정보를 찾아 요약해줍니다.
6. **프로젝트 컨텍스트 자동 로드**: CLI가 시작될 때 현재 디렉토리 구조를 파악하여, 사용자가 파일 경로를 일일이 지정하지 않아도 문맥에 맞는 작업을 수행합니다.
7. **안전 모드**: 사용자의 명시적인 승인 없이는 어떠한 파일도 변경하거나 명령을 실행하지 않아 시스템을 안전하게 보호합니다.

## Gemini CLI와 Gemini Code Assist 비교

Gemini CLI와 Google의 Gemini Code Assist는 모두 Gemini 모델을 기반으로 개발자의 생산성을 높이는 AI 코딩 도우미이지만, 작동 환경과 핵심 철학에서 중요한 차이를 보입니다.

- **Gemini Code Assist란?**
  Google Cloud에서 제공하는 AI 기반 코딩 어시스턴트로, VS Code 및 JetBrains IDEs와 같은 통합 개발 환경(IDE)에서 확장 프로그램 형태로 작동합니다. 코드 완성, 버그 수정, 테스트 케이스 생성 등 개발 워크플로우에 직접 통합되어 개발자의 생산성을 높이는 데 중점을 둡니다.

- **주요 차이점 요약**

| 기능/특징 | Gemini CLI | Gemini Code Assist |
| :--- | :--- | :--- |
| **핵심 철학** | **터미널 기반 자율 에이전트**: 복잡한 작업을 **계획하고 실행**하는 데 중점을 둔 대화형 에이전트 | **IDE 통합 보조 도구**: 코드 완성, 인라인 채팅 등 IDE 내에서 개발자의 작업을 **보조**하는 데 중점을 둔 도구 |
| **작동 환경** | **터미널 (CLI)** | **통합 개발 환경 (IDE)** |
| **주요 기능** | 파일 시스템 조작, 셸 명령어 실행, Git 워크플로우 자동화 등 **환경과 상호작용**하는 작업 | 전체 코드 블록 완성, 스마트 액션, 채팅 기반 질의응답 등 **코드 중심**의 작업 |
| **컨텍스트 범위** | 프로젝트 전체 파일 시스템, 터미널 환경 | 열려 있는 파일 및 코드 일부, 더 넓은 컨텍스트를 위한 채팅 기능 |
| **확장성** | **도구(Tools)**를 통해 외부 스크립트나 API와 자유롭게 연동 가능 | IDE 확장 기능에 의존하며, 외부 도구 연동은 제한적 |
| **대상 사용자** | 터미널 환경에서 복잡한 워크플로우를 자동화하고 싶은 개발자, DevOps 엔지니어 | IDE 내에서 코드 작성 생산성을 높이고 싶은 모든 개발자 |
| **가격 정책** | Google AI API 토큰 기반 사용량 과금 (Pay-as-you-go) | Google Cloud 구독 기반 (주로 엔터프라이즈 대상) |

## 결론

Gemini CLI는 **자율적인 에이전트**로서 **도구 사용 능력**과 **깊은 문맥 이해**를 바탕으로 개발자의 생산성을 극대화하는 강력한 도구입니다. 단순한 코드 제안을 넘어, 실제 개발 환경과 상호작용하며 복잡한 작업을 자동화합니다. **설치와 구성**이 간편하며, **사용자 승인 기반의 안전장치**를 통해 안심하고 사용할 수 있습니다. 터미널 환경에서 AI의 능력을 최대한 활용하고 싶은 개발자라면 Gemini CLI는 최고의 선택이 될 것입니다.

## 추가 리소스

* [Google AI for Developers](https://ai.google.dev/)
* [Gemini API 문서](https://ai.google.dev/docs)
* [Gemini CLI 공식 GitHub 저장소 (가상)](https://github.com/google/gemini-cli)
