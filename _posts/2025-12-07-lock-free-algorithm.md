---
title: 락프리(Lock-Free) 알고리즘 이해하기
categories:
  - dev

tags:
  - lock-free
  - c++
  - performance
  - multithreading
---

멀티스레드 프로그래밍 환경에서 동시성 제어는 성능과 직결되는 매우 중요한 문제입니다. 이번 글에서는 전통적인 락 기반 동시성 제어의 한계를 극복하기 위해 등장한 **락프리(Lock-Free) 알고리즘**에 대해 알아보고, 그 개념과 구현 방법, 그리고 장단점을 살펴보겠습니다.

## 락프리 알고리즘이란?

**락프리(Lock-Free)**는 이름 그대로 **"자물쇠(Lock) 없이"** 여러 스레드가 동시에 데이터를 처리하는 기술입니다.

쉽게 비유하자면 **회전문**과 같습니다.
- **락(Lock)**: 한 번에 한 명만 들어갈 수 있는 화장실입니다. 누군가 안에 있으면 밖에서 열쇠를 받을 때까지 마냥 기다려야 합니다.
- **락프리(Lock-Free)**: 여러 사람이 동시에 지나갈 수 있는 회전문입니다. 가끔 문이 꽉 차서 한 바퀴 더 돌아야 할 수도 있지만, 멈추지 않고 계속 움직일 수 있습니다.

락프리는 시스템 전체가 멈추는 일(Deadlock) 없이, 누군가는 반드시 작업을 완료한다는 것을 보장합니다.

## 락프리 알고리즘을 사용하지 않는 일반적인 방법 (Lock-Based)

락프리 기법을 사용하지 않는 경우, 우리는 데이터 경쟁(Data Race)을 막기 위해 **상호 배제(Mutual Exclusion)** 메커니즘을 사용합니다.

- **Mutex (뮤텍스)**: 공유 자원에 접근하기 전 락을 획득하고, 사용 후 반납합니다.
- **Semaphore (세마포어)**: 정해진 수의 스레드만 자원에 접근하도록 제한합니다.

이 방식은 직관적이고 구현이 쉽지만 다음과 같은 문제점이 발생할 수 있습니다.

1.  **Deadlock (교착 상태)**: 두 스레드가 서로의 자원을 기다리며 영원히 멈추는 현상.
2.  **Priority Inversion (우선순위 역전)**: 낮은 우선순위의 스레드가 락을 잡고 있어 높은 우선순위의 스레드가 실행되지 못하는 현상.
3.  **Convoying (컨보이 현상)**: 락을 쥐고 있는 스레드가 스케줄링에서 배제되면, 해당 락을 기다리는 모든 스레드가 대기하게 되어 성능이 저하되는 현상.

## 락프리 알고리즘 구현 내용: 컨셉 및 의사코드

락프리 알고리즘의 핵심은 **원자적 연산(Atomic Operation)**, 특히 **CAS (Compare-And-Swap)** 연산입니다.

### 핵심 컨셉: CAS (Compare-And-Swap)

CAS는 **"이 자리가 비어있으면 제가 앉을게요, 아니면 다시 올게요"**라고 말하는 것과 같습니다.

하드웨어 수준에서 단숨에(원자적으로) 처리되는 이 명령어는 다음과 같은 로직을 가집니다.

1.  **확인**: "지금 내 데이터가 A가 맞니?"
2.  **변경**: "맞다면 B로 바꿔줘."
3.  **실패**: "아니라고? (누가 벌써 바꿨네) 그럼 다시 시도할게."

```cpp
// 가상의 CAS 함수 설명
bool CAS(int* addr, int expected, int new_value) {
    if (*addr == expected) { // 1. 값이 내가 알던거랑 똑같으면
        *addr = new_value;   // 2. 새 값으로 바꿈
        return true;         // 성공!
    }
    return false;            // 실패! (누가 그새 바꿨음)
}
```

락프리 알고리즘은 보통 다음과 같은 패턴을 따릅니다.
1. 변경하려는 값을 읽어옵니다 (`expected`).
2. 변경할 새로운 값을 계산합니다 (`new_value`).
3. CAS를 시도합니다. 만약 실패했다면(다른 스레드가 먼저 값을 바꿨다면), 1번부터 다시 시도합니다.

### 구현 예시: 락프리 스택 (C++ 스타일)

복잡한 템플릿 대신, 간단한 **정수형(int) 스택**으로 예시를 들어보겠습니다.

```cpp
#include <atomic>

struct Node {
    int data;
    Node* next;
};

class LockFreeIntStack {
    std::atomic<Node*> head; // 스택의 맨 위(Top)를 가리키는 포인터

public:
    void push(int value) {
        Node* new_node = new Node{value, nullptr};
        
        // 1. 현재 head 값을 읽어서 '다음 갈 곳'으로 지정합니다.
        // [상황: 준비 단계]
        // 새로만든노드(30) -> ?
        // 현재스택: Head -> [20] -> [10]
        new_node->next = head.load();

        // 2 & 3. CAS 루프: "Head가 내가 방금 본 거랑 여전히 똑같니?"
        // 맞다면 -> Head를 new_node로 바꿈 (성공)
        // 틀리다면 -> 누군가 새 노드를 넣어서 Head가 변함 (실패 -> 다시 시도)
        while (!head.compare_exchange_weak(new_node->next, new_node)) {
             // [상황: 실패 (누가 먼저 선수침!)]
             // Head가 [40]으로 변해 있었음!
             // 현재스택: Head -> [40] -> [20] -> [10]
             //
             // 내 노드(30)의 다음 위치를 [40]으로 고쳐 잡고 다시 줄을 섭니다.
             // new_node(30) -> [40] ... 재시도!
        }
        
        // [상황: 성공]
        // Head -> [내노드 30] -> [40] -> [20] -> ...
    }
};
```

## 일반 락 알고리즘과 장단점 비교

| 구분 | 락 기반 (Lock-Based) | 락프리 (Lock-Free) |
| :--- | :--- | :--- |
| **구현 난이도** | 비교적 쉬움 | 매우 어려움 (ABA 문제, 메모리 관리 등 고려 필요) |
| **데드락** | 발생 가능 | 구조적으로 발생하지 않음 |
| **컨텍스트 스위칭** | 락 대기 시 발생 (Overhead 큼) | 없음 (또는 매우 적음) |
| **경합 상황 성능** | 경합이 심하면 급격히 저하 | 경합이 심해도 전체 시스템 처리량은 유지될 가능성이 높음 |
| **디버깅** | 어려움 | 매우 어려움 |

## 각각의 알고리즘의 성능상 베스트 케이스와 최악의 상황

### 락프리 알고리즘 (Lock-Free)
- **Best Case**: 경합이 전혀 없을 때. CAS 연산이 한 번에 성공하며, 락을 획득/해제하는 오버헤드 없이 매우 빠르게 동작합니다.
- **Worst Case**: 경합이 극심할 때. 수많은 스레드가 동시에 CAS를 시도하면, 대부분 실패하고 `while` 루프를 계속 돌게 됩니다. 이 경우 CPU 자원만 소모하고 실제 작업 진행은 더딜 수 있습니다 (Live-lock과 유사한 상황).

### 락 기반 알고리즘 (Lock-Based)
- **Best Case**: 경합이 없을 때. 뮤텍스 획득/해제가 빠르게 이루어지지만, 락프리의 원자적 연산보다는 약간의 오버헤드가 더 있을 수 있습니다.
- **Worst Case**: 경합이 많고, 락을 보유한 스레드가 컨텍스트 스위칭으로 쫓겨날 때(Preemption). 락을 기다리는 모든 스레드가 멈추고(Blocking), 운영체제의 스케줄러가 개입하여 컨텍스트 스위칭 비용이 크게 발생합니다.

---

락프리 알고리즘은 고성능 시스템에 필수적일 수 있지만, 그 복잡도로 인해 신중하게 도입해야 합니다. 무조건적인 락프리 전환보다는 프로파일링을 통해 병목 구간을 확인하고 적용하는 것이 바람직합니다.
