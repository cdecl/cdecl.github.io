---
title: "Linux vs Windows 쓰레딩 모델 비교"

toc: true
toc_sticky: true

categories:
  - dev

tags: 
  - linux
  - windows
  - thread
  - kernel
---

쓰레드는 운영체제가 프로세스 내에서 작업을 병렬로 실행하기 위해 사용하는 **기본 실행 단위**입니다. 리눅스와 윈도우는 이 쓰레드를 관리하고 스케줄링하는 방식에서 서로 다른 모델을 채택하고 있으며, 이러한 차이는 시스템 성능과 프로그래밍 방식에 영향을 미칩니다.

## 🐧 리눅스 쓰레딩 모델: N:1 및 1:1 혼합 (NPTL)

리눅스는 역사적으로 다양한 쓰레딩 모델을 거쳐왔으나, 현재는 **NPTL(Native POSIX Thread Library)**이라는 1:1 모델과 N:1 모델의 장점을 결합한 형태가 주류입니다.

### 1. 핵심 개념: 경량 프로세스 (LWP, LightWeight Process)

* **리눅스 커널의 관점:** 리눅스 커널은 **프로세스와 쓰레드를 구분하지 않고**, 모두 **태스크(Task)** 또는 **경량 프로세스(LWP)**로 취급하고 스케줄링합니다.
* **쓰레드의 생성:** POSIX 쓰레드(pthreads) 라이브러리를 통해 쓰레드를 생성하면, 커널에 새로운 LWP가 생성됩니다. 이 LWP들은 부모 프로세스의 주소 공간, 파일 디스크립터 등을 공유하며, 각자의 실행 문맥(Context)을 가집니다.

### 2. 모델 유형: 1:1 모델

* **특징:** 사용자 공간의 **각 쓰레드(N)**가 커널 공간의 **각각의 스케줄링 가능한 엔티티(1)**, 즉 LWP에 **직접적으로 대응**됩니다.
* **장점:**
    * **진정한 병렬성:** 멀티 코어 환경에서 여러 쓰레드가 **동시에 병렬**로 실행될 수 있습니다.
    * **커널 지원:** 특정 쓰레드가 I/O 작업 등으로 **블록(Block)** 상태가 되더라도, 커널은 해당 프로세스의 다른 쓰레드들을 계속 스케줄링할 수 있습니다.
* **단점:** 쓰레드 생성 및 컨텍스트 전환 시 **커널 오버헤드**가 발생합니다.

> **요약:** 리눅스는 **POSIX 표준**을 따르며, 사용자 레벨의 쓰레드가 커널 레벨의 프로세스와 유사한 경량 프로세스로 매핑되는 **1:1 모델**에 가깝습니다.

## 🖼️ 윈도우 쓰레딩 모델: 1:1 (일대일)

윈도우 운영체제는 초기부터 현재까지 비교적 **명확한 1:1 쓰레딩 모델**을 사용하고 있습니다.

### 1. 핵심 개념: 쓰레드 오브젝트 (Thread Object)

* **윈도우 커널의 관점:** 윈도우 커널은 **프로세스**와 그 프로세스 내의 **쓰레드**를 명확히 구분하여 관리합니다.
* **쓰레드의 생성:** **쓰레드 오브젝트(Thread Object)**는 윈도우 커널의 기본 스케줄링 단위입니다. 프로세스는 하나 이상의 쓰레드를 가집니다.

### 2. 모델 유형: 1:1 모델

* **특징:** 사용자 공간의 **모든 쓰레드(N)**는 윈도우 커널의 **고유한 쓰레드 오브젝트(1)**에 **직접적으로 매핑**됩니다.
* **장점:**
    * **단순하고 예측 가능:** 구현이 단순하고 스케줄링 동작을 예측하기 쉽습니다.
    * **강력한 커널 관리:** 모든 쓰레드 활동은 커널에 의해 직접 관리되므로, 시스템 수준의 동시성 제어가 용이합니다.
* **단점:** 리눅스와 마찬가지로, 쓰레드 생성 및 스케줄링에 **커널 오버헤드**가 수반됩니다.

> **요약:** 윈도우는 프로세스 내의 모든 쓰레드가 커널의 고유한 쓰레드 오브젝트로 매핑되는 **순수한 1:1 모델**을 채택하고 있습니다.

## 🗓️ 스케줄링 (Scheduling)

### Linux
*   **CFS (Completely Fair Scheduler)**를 사용합니다. 쓰레드별로 공평한 CPU 시간을 분배하는 데 초점을 둡니다.
*   SMP(대칭형 다중 처리) 환경에서 코어 간 부하 분산을 효율적으로 처리하며, 특정 코어에 쓰레드를 오래 머물게 하여 캐시 효율을 높이는 경향이 있습니다.

### Windows
*   **우선순위 기반(Priority-based) 선점형 스케줄링**을 사용합니다.
*   쓰레드의 우선순위가 매우 중요하게 작용하며, 포그라운드 작업(사용자가 보고 있는 창)의 쓰레드에 더 긴 타임 슬라이스(Quantum)를 할당하여 **반응성(Responsiveness)**을 높이는 데 최적화되어 있습니다.

## 🔒 동기화 및 성능 (Synchronization & Performance)

### Linux
*   동기화를 위해 **Futex (Fast Userspace Mutex)**를 사용하여, 경합이 없을 때는 커널 모드로 전환하지 않고 사용자 모드에서 빠르게 처리합니다. 이로 인해 문맥 교환(Context Switch) 오버헤드가 적은 편입니다.
*   쓰레드 생성과 소멸 속도가 매우 빠르며, 서버 사이드 및 대규모 병렬 처리에 유리합니다.

### Windows
*   동기화를 위해 **Critical Section**(사용자 모드), **Mutex/Event/Semaphore**(커널 모드) 등 다양한 객체를 제공합니다.
*   커널 객체를 사용하는 동기화는 무겁지만, 기능이 강력합니다.
*   일반적으로 Linux보다 쓰레드 생성 비용이 다소 높다고 평가받지만, GUI 애플리케이션 환경에서의 반응성은 매우 뛰어납니다.

## 📊 주요 비교 정리

| 특징 | 🐧 리눅스 (NPTL) | 🖼️ 윈도우 |
| :--- | :--- | :--- |
| **기본 스케줄링 단위** | 경량 프로세스 (LWP, LightWeight Process) / 태스크 | 쓰레드 오브젝트 (Thread Object) |
| **모델 유형** | 1:1 모델 기반 (LWP 이용) | 1:1 모델 |
| **프로세스/쓰레드 구분** | 커널은 **구분하지 않음** (모두 LWP) | 커널은 **명확하게 구분함** |
| **표준 채택** | POSIX Threads (pthreads) | 독자적인 Win32 Thread API |
| **병렬 실행 능력** | 높음 (멀티 코어 활용) | 높음 (멀티 코어 활용) |
| **주 용도** | 서버, 고성능 연산, 대규모 병렬 처리 | 데스크톱, GUI, 복합 응용 프로그램 |

## 🧐 결론

리눅스와 윈도우 모두 현대적인 운영체제로서 **1:1 쓰레딩 모델**을 채택하고 있으며, 이는 멀티 코어 CPU 환경에서 **진정한 병렬 처리**를 가능하게 합니다.

* **리눅스**는 모든 실행 단위를 **LWP**로 통일하여 유연한 태스크 관리를 지향합니다.
* **윈도우**는 **프로세스와 쓰레드를 명확히 분리**하고 쓰레드 오브젝트를 통해 세밀한 커널 관리를 제공합니다.

대부분의 현대 애플리케이션 개발자에게 이 모델 차이가 직접적인 코딩 방식에 큰 영향을 주지는 않지만, 각 운영체제가 어떻게 자원을 관리하는지 이해하는 것은 **성능 튜닝** 및 **시스템 프로그래밍** 시 매우 중요합니다.
