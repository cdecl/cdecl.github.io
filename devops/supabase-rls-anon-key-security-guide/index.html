<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Supabase RLS와 anon 키: RLS Disabled in Public, 백엔드 개발자를 위한 보안 가이드 | cdeclog</title><meta name=keywords content="Supabase,PostgreSQL,Security,RLS,Backend"><meta name=description content="Supabase는 편리한 기능과 자동화된 API 덕분에 많은 개발자에게 사랑받고 있지만, 간혹 대시보드에 나타나는 &ldquo;RLS Disabled&rdquo; 경고는 백엔드 개발자들을 혼란에 빠뜨리곤 합니다. &ldquo;나는 백엔드에서만 안전하게 통신하는데, 이게 왜 문제지?&ldquo;라고 생각했다면 이 글이 명쾌한 해답을 드릴 것입니다. 이 글에서는 RLS와 anon 키의 관계를 명확히 이해하고, 백엔드 중심 프로젝트에서 RLS를 어떻게 활용해야 하는지에 대한 모범 사례를 제시합니다.
1. 문제 상황: &ldquo;RLS Disabled in Public&rdquo; 경고의 의미
Supabase 대시보드에서 public.users 또는 public.notes와 같은 테이블에 대해 RLS Disabled 경고를 마주하는 것은 생각보다 흔한 일입니다. 이 경고의 진짜 의미는 무엇일까요?"><meta name=author content="Byung Kyu KIM"><link rel=canonical href=https://cdecl.github.io/devops/supabase-rls-anon-key-security-guide/><link crossorigin=anonymous href=/assets/css/stylesheet.d980bb9fb2cba61af0aead0606b5eb221d7e358748ac394b60233d95d626c563.css integrity="sha256-2YC7n7LLphrwrq0GBrXrIh1+NYdIrDlLYCM9ldYmxWM=" rel="preload stylesheet" as=style><link rel=icon href=https://cdecl.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://cdecl.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://cdecl.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://cdecl.github.io/apple-touch-icon.png><link rel=mask-icon href=https://cdecl.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://cdecl.github.io/devops/supabase-rls-anon-key-security-guide/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-VQQHHYPN7K"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VQQHHYPN7K")}</script><meta property="og:url" content="https://cdecl.github.io/devops/supabase-rls-anon-key-security-guide/"><meta property="og:site_name" content="cdeclog"><meta property="og:title" content="Supabase RLS와 anon 키: RLS Disabled in Public, 백엔드 개발자를 위한 보안 가이드"><meta property="og:description" content="Supabase는 편리한 기능과 자동화된 API 덕분에 많은 개발자에게 사랑받고 있지만, 간혹 대시보드에 나타나는 “RLS Disabled” 경고는 백엔드 개발자들을 혼란에 빠뜨리곤 합니다. “나는 백엔드에서만 안전하게 통신하는데, 이게 왜 문제지?“라고 생각했다면 이 글이 명쾌한 해답을 드릴 것입니다. 이 글에서는 RLS와 anon 키의 관계를 명확히 이해하고, 백엔드 중심 프로젝트에서 RLS를 어떻게 활용해야 하는지에 대한 모범 사례를 제시합니다.
1. 문제 상황: “RLS Disabled in Public” 경고의 의미 Supabase 대시보드에서 public.users 또는 public.notes와 같은 테이블에 대해 RLS Disabled 경고를 마주하는 것은 생각보다 흔한 일입니다. 이 경고의 진짜 의미는 무엇일까요?"><meta property="og:locale" content="ko-kr"><meta property="og:type" content="article"><meta property="article:section" content="devops"><meta property="article:published_time" content="2025-12-23T00:00:00+09:00"><meta property="article:modified_time" content="2025-12-23T00:00:00+09:00"><meta property="article:tag" content="Supabase"><meta property="article:tag" content="PostgreSQL"><meta property="article:tag" content="Security"><meta property="article:tag" content="RLS"><meta property="article:tag" content="Backend"><meta name=twitter:card content="summary"><meta name=twitter:title content="Supabase RLS와 anon 키: RLS Disabled in Public, 백엔드 개발자를 위한 보안 가이드"><meta name=twitter:description content="Supabase는 편리한 기능과 자동화된 API 덕분에 많은 개발자에게 사랑받고 있지만, 간혹 대시보드에 나타나는 &ldquo;RLS Disabled&rdquo; 경고는 백엔드 개발자들을 혼란에 빠뜨리곤 합니다. &ldquo;나는 백엔드에서만 안전하게 통신하는데, 이게 왜 문제지?&ldquo;라고 생각했다면 이 글이 명쾌한 해답을 드릴 것입니다. 이 글에서는 RLS와 anon 키의 관계를 명확히 이해하고, 백엔드 중심 프로젝트에서 RLS를 어떻게 활용해야 하는지에 대한 모범 사례를 제시합니다.
1. 문제 상황: &ldquo;RLS Disabled in Public&rdquo; 경고의 의미
Supabase 대시보드에서 public.users 또는 public.notes와 같은 테이블에 대해 RLS Disabled 경고를 마주하는 것은 생각보다 흔한 일입니다. 이 경고의 진짜 의미는 무엇일까요?"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Devops","item":"https://cdecl.github.io/devops/"},{"@type":"ListItem","position":2,"name":"Supabase RLS와 anon 키: RLS Disabled in Public, 백엔드 개발자를 위한 보안 가이드","item":"https://cdecl.github.io/devops/supabase-rls-anon-key-security-guide/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Supabase RLS와 anon 키: RLS Disabled in Public, 백엔드 개발자를 위한 보안 가이드","name":"Supabase RLS와 anon 키: RLS Disabled in Public, 백엔드 개발자를 위한 보안 가이드","description":"Supabase는 편리한 기능과 자동화된 API 덕분에 많은 개발자에게 사랑받고 있지만, 간혹 대시보드에 나타나는 \u0026ldquo;RLS Disabled\u0026rdquo; 경고는 백엔드 개발자들을 혼란에 빠뜨리곤 합니다. \u0026ldquo;나는 백엔드에서만 안전하게 통신하는데, 이게 왜 문제지?\u0026ldquo;라고 생각했다면 이 글이 명쾌한 해답을 드릴 것입니다. 이 글에서는 RLS와 anon 키의 관계를 명확히 이해하고, 백엔드 중심 프로젝트에서 RLS를 어떻게 활용해야 하는지에 대한 모범 사례를 제시합니다.\n1. 문제 상황: \u0026ldquo;RLS Disabled in Public\u0026rdquo; 경고의 의미 Supabase 대시보드에서 public.users 또는 public.notes와 같은 테이블에 대해 RLS Disabled 경고를 마주하는 것은 생각보다 흔한 일입니다. 이 경고의 진짜 의미는 무엇일까요?\n","keywords":["Supabase","PostgreSQL","Security","RLS","Backend"],"articleBody":"Supabase는 편리한 기능과 자동화된 API 덕분에 많은 개발자에게 사랑받고 있지만, 간혹 대시보드에 나타나는 “RLS Disabled” 경고는 백엔드 개발자들을 혼란에 빠뜨리곤 합니다. “나는 백엔드에서만 안전하게 통신하는데, 이게 왜 문제지?“라고 생각했다면 이 글이 명쾌한 해답을 드릴 것입니다. 이 글에서는 RLS와 anon 키의 관계를 명확히 이해하고, 백엔드 중심 프로젝트에서 RLS를 어떻게 활용해야 하는지에 대한 모범 사례를 제시합니다.\n1. 문제 상황: “RLS Disabled in Public” 경고의 의미 Supabase 대시보드에서 public.users 또는 public.notes와 같은 테이블에 대해 RLS Disabled 경고를 마주하는 것은 생각보다 흔한 일입니다. 이 경고의 진짜 의미는 무엇일까요?\n원인: Supabase는 public 스키마에 생성된 테이블을 PostgREST를 통해 외부에서 접근 가능한 API URL로 자동 노출합니다. 진단: 경고의 핵심은 “외부로 향하는 API 문은 열려 있는데, 정작 테이블 자체에는 아무런 보안 정책(RLS)이 없어 누구나 데이터를 열람하거나 조작할 수 있는 위험한 상태\"라는 뜻입니다. 백엔드 서버에서만 DB에 접근한다고 해서 이 경고를 무시해서는 안 됩니다. 우리가 사용하지 않는 ‘앞문’이 활짝 열려있는 것과 같기 때문입니다.\n2. 핵심 개념: 용어 정리 이 문제를 제대로 이해하려면 세 가지 핵심 개념을 알아야 합니다.\n① anon 키 (Anonymous Key) 정체: 프론트엔드(클라이언트) 환경에서 데이터베이스에 직접 접속하기 위해 설계된 공개용 키입니다. 위험성: 이름처럼 익명 사용자를 위한 키이므로, 웹사이트의 소스 코드나 브라우저의 네트워크 탭을 통해 누구나 쉽게 획득할 수 있습니다. 만약 RLS가 비활성화되어 있다면, 이 anon 키 하나만으로 해커는 당신의 모든 데이터를 조회, 수정, 삭제할 수 있습니다. ② RLS (Row Level Security) 정체: PostgreSQL 데이터베이스의 각 행(Row) 단위로 정교한 접근 권한을 제어하는 강력한 보안 엔진입니다. 역할: “이 요청을 보낸 사용자가 이 데이터 행의 주인인가?” 혹은 “이 사용자가 이 데이터를 읽거나 쓸 자격이 있는가?“를 데이터베이스 수준에서 직접 검사하여 인가되지 않은 접근을 원천 차단합니다. ③ service_role 키 (Service Role Key) 정체: 백엔드 서버 환경에서 사용하는 관리자용 마스터 키입니다. 절대로 외부에 노출되어서는 안 됩니다. 특징: 이 키의 가장 중요한 특징은 **RLS를 우회(Bypass)**한다는 점입니다. 즉, RLS 정책이 아무리 촘촘하게 설정되어 있어도 service_role 키를 사용한 요청은 모든 데이터에 제약 없이 접근할 수 있습니다. 3. RLS, 왜 필요한가? (백엔드 개발자의 오해) 백엔드 개발자들 사이에서 가장 흔한 질문은 다음과 같습니다.\nQ: “저는 백엔드 서버에서 service_role 키나 DB connection string으로만 안전하게 통신하는데, 굳이 RLS를 켤 필요가 있나요?”\nA: 네, 반드시 켜야 합니다.\n백엔드와 DB 사이의 통신 채널이 안전한 것과 별개로, Supabase는 기본적으로 anon 키를 통한 **‘사용하지 않는 정문’**을 열어두고 있습니다. RLS를 활성화하는 것은 바로 이 정문을 잠그고, 오직 우리가 통제하는 백엔드라는 ‘뒷문’으로만 출입하도록 강제하는 행위입니다.\n4. 백엔드 중심 운영을 위한 RLS 보안 전략 (Best Practice) anon 키를 사용할 계획이 없는 백엔드 중심 프로젝트라면, 보안 설정은 매우 간단하고 명확합니다.\n단계 1: RLS 활성화 (앞문 잠그기) 가장 먼저 할 일은 사용하지 않을 anon 키의 접근 경로를 원천 차단하는 것입니다. 별도의 정책(Policy)을 만들 필요조차 없습니다. RLS만 활성화하면, 기본적으로 ‘DENY ALL’(모든 요청 거부) 정책이 적용되어 모든 익명 요청이 자동으로 차단됩니다.\n-- RLS를 활성화할 대상 테이블 지정 ALTER TABLE public.users ENABLE ROW LEVEL SECURITY; ALTER TABLE public.notes ENABLE ROW LEVEL SECURITY; -- 테이블에 강제로 RLS 적용 (이미 활성화된 경우에도 확인차 실행) ALTER TABLE public.users FORCE ROW LEVEL SECURITY; ALTER TABLE public.notes FORCE ROW LEVEL SECURITY; 이 두 줄의 SQL만으로 anon 키를 사용한 모든 API 요청은 실패하게 됩니다.\n단계 2: 백엔드는 기존 방식 그대로 운영 백엔드 서버에서는 기존처럼 service_role 키 또는 데이터베이스 비밀 연결 문자열을 그대로 사용하면 됩니다. 이 키들은 RLS를 우회하므로, RLS 활성화 여부와 관계없이 기존 백엔드 로직과 성능에 아무런 영향도 주지 않습니다.\n단계 3: 심층 방어 (Defense in Depth) RLS를 켜두면 얘기치 못한 상황에서 최후의 방어선 역할을 합니다. 예를 들어, 백엔드 서버가 해킹당하거나 코드 로직에 실수가 생겨 의도치 않은 데이터 변경이 발생하려 할 때, 데이터베이스 수준에 설정된 RLS가 2차적인 방어벽이 되어줄 수 있습니다.\n5. 프론트엔드 운영을 위한 RLS 정책 수립 (anon 키 활용) 백엔드만 사용하는 경우와 달리, 프론트엔드에서 Supabase를 직접 호출하려면 anon 키에 대한 접근을 허용해야 합니다. 이는 RLS를 끄는 것이 아니라, 어떤 조건에서 anon 키의 요청을 허용할지에 대한 구체적인 정책(Policy)을 정의하는 것을 의미합니다.\n5.1. RLS 정책의 기본 구조: USING과 WITH CHECK RLS 정책은 크게 USING 절과 WITH CHECK 절로 구성됩니다.\nUSING (읽기 접근 제어): SELECT 쿼리가 실행될 때 적용됩니다. 이 조건이 true를 반환하는 행(Row)만 사용자에게 보입니다. WITH CHECK (쓰기 접근 제어): INSERT 또는 UPDATE 쿼리가 실행될 때 적용됩니다. 이 조건이 true를 반환해야만 데이터의 삽입 또는 수정이 허용됩니다. DELETE는 USING 절의 규칙을 따릅니다. 5.2. 정책 예시 1: 인증된 사용자는 자신의 데이터만 관리 가장 흔한 시나리오입니다. 예를 들어 profiles 테이블이 있고, 사용자는 자신의 프로필만 보고 수정할 수 있어야 합니다.\n-- 이 정책은 'profiles' 테이블에 적용됩니다. CREATE POLICY \"Users can manage their own profile.\" -- 어떤 작업에 대해? SELECT, INSERT, UPDATE, DELETE 모두 ON public.profiles FOR ALL -- 누가 접근할 때? 인증된 모든 사용자 (anon 역할 아님) TO authenticated -- 읽기 조건: 행의 id가 현재 로그인한 사용자의 id와 같아야 함 USING ( auth.uid() = id ) -- 쓰기 조건: 삽입/수정하려는 행의 id가 현재 로그인한 사용자의 id와 같아야 함 WITH CHECK ( auth.uid() = id ); auth.uid()는 Supabase가 제공하는 헬퍼 함수로, 요청을 보낸 사용자의 고유 ID(UUID)를 반환합니다. 이 정책 덕분에 사용자는 anon 키로 API를 호출하더라도 데이터베이스 수준에서 자신의 데이터에만 안전하게 접근할 수 있습니다.\n5.3. 정책 예시 2: 공개 데이터와 개인 데이터 혼합 블로그 게시물을 생각해보겠습니다. 모든 게시물(posts)은 누구나 읽을 수 있지만, 작성은 인증된 사용자만 가능하고, 수정/삭제는 작성자 본인만 가능해야 합니다.\n-- 1. 모든 사용자가 게시물을 읽을 수 있도록 허용하는 정책 (SELECT) CREATE POLICY \"Public can read all posts.\" ON public.posts FOR SELECT TO public USING ( true ); -- 'true'는 항상 참이므로 모든 행을 볼 수 있음 -- 2. 인증된 사용자만 게시물을 작성할 수 있도록 허용하는 정책 (INSERT) CREATE POLICY \"Authenticated users can create posts.\" ON public.posts FOR INSERT TO authenticated WITH CHECK ( true ); -- 인증만 되었다면 누구나 작성 가능 -- 3. 작성자 본인만 게시물을 수정할 수 있도록 허용하는 정책 (UPDATE) CREATE POLICY \"Owners can update their own posts.\" ON public.posts FOR UPDATE TO authenticated USING ( auth.uid() = user_id ) -- 수정할 행을 찾는 조건 WITH CHECK ( auth.uid() = user_id ); -- 수정할 내용이 제약조건을 만족하는지 확인 -- 4. 작성자 본인만 게시물을 삭제할 수 있도록 허용하는 정책 (DELETE) CREATE POLICY \"Owners can delete their own posts.\" ON public.posts FOR DELETE TO authenticated USING ( auth.uid() = user_id ); -- 삭제할 행을 찾는 조건 이처럼 작업(SELECT, INSERT, UPDATE, DELETE)과 역할(public, authenticated)에 따라 여러 정책을 조합하여 매우 세분화된 규칙을 만들 수 있습니다.\n6. 좋은 RLS 정책을 설계하는 기준 효과적이고 안전한 RLS 정책을 만들려면 다음 기준을 따르는 것이 좋습니다. 이는 anon 키에 부여할 권한을 어떻게 잘게 나눌 것인가에 대한 기준, 즉 ‘anon 키 분해 기준’이 됩니다.\n기본적으로 거부 (Default Deny) 가장 중요한 원칙입니다. ALTER TABLE ... ENABLE ROW LEVEL SECURITY;를 실행하는 순간 모든 접근이 차단됩니다. 그 상태에서 꼭 필요한 권한만 정책을 통해 하나씩 허용해야 합니다.\n최소 권한의 원칙 (Principle of Least Privilege) 사용자에게 꼭 필요한 최소한의 권한만 부여합니다. 예를 들어, 단순히 게시물을 읽기만 하면 되는 익명 사용자(public)에게 UPDATE나 DELETE 권한을 줄 이유가 없습니다.\n역할과 행동에 따라 정책 분리 위의 게시물 예시처럼, 하나의 큰 정책을 만드는 대신 SELECT용, INSERT용, UPDATE용 정책을 명확하게 분리하는 것이 좋습니다. 이렇게 하면 정책을 이해하고 디버깅하기 쉬워집니다.\nUSING과 WITH CHECK를 명확히 이해하고 사용\n조회(View) 권한은 USING으로 제어합니다. 생성/수정(Mutation) 권한은 WITH CHECK로 제어하여 데이터 무결성을 보장해야 합니다. CHECK 조건을 누락하면 사용자가 다른 사람의 user_id로 데이터를 삽입하는 등의 문제가 발생할 수 있습니다. 7. 새로운 요약 및 결론 Supabase의 RLS는 단순히 anon 키를 차단하는 수단이 아니라, 프론트엔드와 직접 통신할 때 어떤 데이터를, 누구에게, 어떻게 허용할지를 정의하는 강력한 규칙 엔진입니다.\n구분 프론트엔드 (Client-Side) 백엔드 (Server-Side) 인증 수단 anon 키 (공개) service_role 키 (비밀) RLS 영향 강제 적용 (보안의 핵심) 우회 (성능/로직에 영향 없음) 보안 주체 데이터베이스(RLS) + 프론트 로직 백엔드 애플리케이션 로직 RLS 목적 세분화된 데이터 접근 규칙 정의 anon 키를 통한 비인가 접근 전면 차단 최종 결론: RLS는 백엔드만 사용하든, 프론트엔드와 함께 사용하든 반드시 활성화해야 하는 필수 보안 기능입니다. 백엔드 중심이라면 모든 접근을 차단하는 방화벽으로, 프론트엔드 중심이라면 데이터 접근 규칙을 정의하는 설계도로서 RLS를 적극 활용해야 합니다.\n","wordCount":"1243","inLanguage":"en","datePublished":"2025-12-23T00:00:00+09:00","dateModified":"2025-12-23T00:00:00+09:00","author":{"@type":"Person","name":"Byung Kyu KIM"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://cdecl.github.io/devops/supabase-rls-anon-key-security-guide/"},"publisher":{"@type":"Organization","name":"cdeclog","logo":{"@type":"ImageObject","url":"https://cdecl.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://cdecl.github.io/ accesskey=h title="cdeclog (Alt + H)">cdeclog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://cdecl.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://cdecl.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://cdecl.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Supabase RLS와 anon 키: RLS Disabled in Public, 백엔드 개발자를 위한 보안 가이드</h1><div class=post-meta><span title='2025-12-23 00:00:00 +0900 KST'>December 23, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#1-%eb%ac%b8%ec%a0%9c-%ec%83%81%ed%99%a9-rls-disabled-in-public-%ea%b2%bd%ea%b3%a0%ec%9d%98-%ec%9d%98%eb%af%b8 aria-label="1. 문제 상황: &ldquo;RLS Disabled in Public&rdquo; 경고의 의미">1. 문제 상황: &ldquo;RLS Disabled in Public&rdquo; 경고의 의미</a></li><li><a href=#2-%ed%95%b5%ec%8b%ac-%ea%b0%9c%eb%85%90-%ec%9a%a9%ec%96%b4-%ec%a0%95%eb%a6%ac aria-label="2. 핵심 개념: 용어 정리">2. 핵심 개념: 용어 정리</a><ul><li><a href=#-anon-%ed%82%a4-anonymous-key aria-label="① anon 키 (Anonymous Key)">① anon 키 (Anonymous Key)</a></li><li><a href=#-rls-row-level-security aria-label="② RLS (Row Level Security)">② RLS (Row Level Security)</a></li><li><a href=#-service_role-%ed%82%a4-service-role-key aria-label="③ service_role 키 (Service Role Key)">③ service_role 키 (Service Role Key)</a></li></ul></li><li><a href=#3-rls-%ec%99%9c-%ed%95%84%ec%9a%94%ed%95%9c%ea%b0%80-%eb%b0%b1%ec%97%94%eb%93%9c-%ea%b0%9c%eb%b0%9c%ec%9e%90%ec%9d%98-%ec%98%a4%ed%95%b4 aria-label="3. RLS, 왜 필요한가? (백엔드 개발자의 오해)">3. RLS, 왜 필요한가? (백엔드 개발자의 오해)</a></li><li><a href=#4-%eb%b0%b1%ec%97%94%eb%93%9c-%ec%a4%91%ec%8b%ac-%ec%9a%b4%ec%98%81%ec%9d%84-%ec%9c%84%ed%95%9c-rls-%eb%b3%b4%ec%95%88-%ec%a0%84%eb%9e%b5-best-practice aria-label="4. 백엔드 중심 운영을 위한 RLS 보안 전략 (Best Practice)">4. 백엔드 중심 운영을 위한 RLS 보안 전략 (Best Practice)</a><ul><li><a href=#%eb%8b%a8%ea%b3%84-1-rls-%ed%99%9c%ec%84%b1%ed%99%94-%ec%95%9e%eb%ac%b8-%ec%9e%a0%ea%b7%b8%ea%b8%b0 aria-label="단계 1: RLS 활성화 (앞문 잠그기)">단계 1: RLS 활성화 (앞문 잠그기)</a></li><li><a href=#%eb%8b%a8%ea%b3%84-2-%eb%b0%b1%ec%97%94%eb%93%9c%eb%8a%94-%ea%b8%b0%ec%a1%b4-%eb%b0%a9%ec%8b%9d-%ea%b7%b8%eb%8c%80%eb%a1%9c-%ec%9a%b4%ec%98%81 aria-label="단계 2: 백엔드는 기존 방식 그대로 운영">단계 2: 백엔드는 기존 방식 그대로 운영</a></li><li><a href=#%eb%8b%a8%ea%b3%84-3-%ec%8b%ac%ec%b8%b5-%eb%b0%a9%ec%96%b4-defense-in-depth aria-label="단계 3: 심층 방어 (Defense in Depth)">단계 3: 심층 방어 (Defense in Depth)</a></li></ul></li><li><a href=#5-%ed%94%84%eb%a1%a0%ed%8a%b8%ec%97%94%eb%93%9c-%ec%9a%b4%ec%98%81%ec%9d%84-%ec%9c%84%ed%95%9c-rls-%ec%a0%95%ec%b1%85-%ec%88%98%eb%a6%bd-anon-%ed%82%a4-%ed%99%9c%ec%9a%a9 aria-label="5. 프론트엔드 운영을 위한 RLS 정책 수립 (anon 키 활용)">5. 프론트엔드 운영을 위한 RLS 정책 수립 (anon 키 활용)</a><ul><li><a href=#51-rls-%ec%a0%95%ec%b1%85%ec%9d%98-%ea%b8%b0%eb%b3%b8-%ea%b5%ac%ec%a1%b0-using%ea%b3%bc-with-check aria-label="5.1. RLS 정책의 기본 구조: USING과 WITH CHECK">5.1. RLS 정책의 기본 구조: USING과 WITH CHECK</a></li><li><a href=#52-%ec%a0%95%ec%b1%85-%ec%98%88%ec%8b%9c-1-%ec%9d%b8%ec%a6%9d%eb%90%9c-%ec%82%ac%ec%9a%a9%ec%9e%90%eb%8a%94-%ec%9e%90%ec%8b%a0%ec%9d%98-%eb%8d%b0%ec%9d%b4%ed%84%b0%eb%a7%8c-%ea%b4%80%eb%a6%ac aria-label="5.2. 정책 예시 1: 인증된 사용자는 자신의 데이터만 관리">5.2. 정책 예시 1: 인증된 사용자는 자신의 데이터만 관리</a></li><li><a href=#53-%ec%a0%95%ec%b1%85-%ec%98%88%ec%8b%9c-2-%ea%b3%b5%ea%b0%9c-%eb%8d%b0%ec%9d%b4%ed%84%b0%ec%99%80-%ea%b0%9c%ec%9d%b8-%eb%8d%b0%ec%9d%b4%ed%84%b0-%ed%98%bc%ed%95%a9 aria-label="5.3. 정책 예시 2: 공개 데이터와 개인 데이터 혼합">5.3. 정책 예시 2: 공개 데이터와 개인 데이터 혼합</a></li></ul></li><li><a href=#6-%ec%a2%8b%ec%9d%80-rls-%ec%a0%95%ec%b1%85%ec%9d%84-%ec%84%a4%ea%b3%84%ed%95%98%eb%8a%94-%ea%b8%b0%ec%a4%80 aria-label="6. 좋은 RLS 정책을 설계하는 기준">6. 좋은 RLS 정책을 설계하는 기준</a></li><li><a href=#7-%ec%83%88%eb%a1%9c%ec%9a%b4-%ec%9a%94%ec%95%bd-%eb%b0%8f-%ea%b2%b0%eb%a1%a0 aria-label="7. 새로운 요약 및 결론">7. 새로운 요약 및 결론</a></li></ul></div></details></div><div class=post-content><p>Supabase는 편리한 기능과 자동화된 API 덕분에 많은 개발자에게 사랑받고 있지만, 간혹 대시보드에 나타나는 &ldquo;RLS Disabled&rdquo; 경고는 백엔드 개발자들을 혼란에 빠뜨리곤 합니다. &ldquo;나는 백엔드에서만 안전하게 통신하는데, 이게 왜 문제지?&ldquo;라고 생각했다면 이 글이 명쾌한 해답을 드릴 것입니다. 이 글에서는 RLS와 anon 키의 관계를 명확히 이해하고, 백엔드 중심 프로젝트에서 RLS를 어떻게 활용해야 하는지에 대한 모범 사례를 제시합니다.</p><h2 id=1-문제-상황-rls-disabled-in-public-경고의-의미>1. 문제 상황: &ldquo;RLS Disabled in Public&rdquo; 경고의 의미<a hidden class=anchor aria-hidden=true href=#1-문제-상황-rls-disabled-in-public-경고의-의미>#</a></h2><p>Supabase 대시보드에서 <code>public.users</code> 또는 <code>public.notes</code>와 같은 테이블에 대해 <strong>RLS Disabled</strong> 경고를 마주하는 것은 생각보다 흔한 일입니다. 이 경고의 진짜 의미는 무엇일까요?</p><ul><li><strong>원인</strong>: Supabase는 <code>public</code> 스키마에 생성된 테이블을 PostgREST를 통해 외부에서 접근 가능한 API URL로 자동 노출합니다.</li><li><strong>진단</strong>: 경고의 핵심은 &ldquo;외부로 향하는 API 문은 열려 있는데, 정작 테이블 자체에는 아무런 보안 정책(RLS)이 없어 누구나 데이터를 열람하거나 조작할 수 있는 위험한 상태"라는 뜻입니다.</li></ul><p>백엔드 서버에서만 DB에 접근한다고 해서 이 경고를 무시해서는 안 됩니다. 우리가 사용하지 않는 &lsquo;앞문&rsquo;이 활짝 열려있는 것과 같기 때문입니다.</p><h2 id=2-핵심-개념-용어-정리>2. 핵심 개념: 용어 정리<a hidden class=anchor aria-hidden=true href=#2-핵심-개념-용어-정리>#</a></h2><p>이 문제를 제대로 이해하려면 세 가지 핵심 개념을 알아야 합니다.</p><h3 id=-anon-키-anonymous-key>① anon 키 (Anonymous Key)<a hidden class=anchor aria-hidden=true href=#-anon-키-anonymous-key>#</a></h3><ul><li><strong>정체</strong>: 프론트엔드(클라이언트) 환경에서 데이터베이스에 직접 접속하기 위해 설계된 <strong>공개용</strong> 키입니다.</li><li><strong>위험성</strong>: 이름처럼 익명 사용자를 위한 키이므로, 웹사이트의 소스 코드나 브라우저의 네트워크 탭을 통해 누구나 쉽게 획득할 수 있습니다. 만약 RLS가 비활성화되어 있다면, 이 <code>anon</code> 키 하나만으로 해커는 당신의 모든 데이터를 조회, 수정, 삭제할 수 있습니다.</li></ul><h3 id=-rls-row-level-security>② RLS (Row Level Security)<a hidden class=anchor aria-hidden=true href=#-rls-row-level-security>#</a></h3><ul><li><strong>정체</strong>: PostgreSQL 데이터베이스의 각 행(Row) 단위로 정교한 접근 권한을 제어하는 강력한 보안 엔진입니다.</li><li><strong>역할</strong>: &ldquo;이 요청을 보낸 사용자가 이 데이터 행의 주인인가?&rdquo; 혹은 &ldquo;이 사용자가 이 데이터를 읽거나 쓸 자격이 있는가?&ldquo;를 데이터베이스 수준에서 직접 검사하여 인가되지 않은 접근을 원천 차단합니다.</li></ul><h3 id=-service_role-키-service-role-key>③ service_role 키 (Service Role Key)<a hidden class=anchor aria-hidden=true href=#-service_role-키-service-role-key>#</a></h3><ul><li><strong>정체</strong>: 백엔드 서버 환경에서 사용하는 <strong>관리자용 마스터 키</strong>입니다. 절대로 외부에 노출되어서는 안 됩니다.</li><li><strong>특징</strong>: 이 키의 가장 중요한 특징은 **RLS를 우회(Bypass)**한다는 점입니다. 즉, RLS 정책이 아무리 촘촘하게 설정되어 있어도 <code>service_role</code> 키를 사용한 요청은 모든 데이터에 제약 없이 접근할 수 있습니다.</li></ul><h2 id=3-rls-왜-필요한가-백엔드-개발자의-오해>3. RLS, 왜 필요한가? (백엔드 개발자의 오해)<a hidden class=anchor aria-hidden=true href=#3-rls-왜-필요한가-백엔드-개발자의-오해>#</a></h2><p>백엔드 개발자들 사이에서 가장 흔한 질문은 다음과 같습니다.</p><blockquote><p><strong>Q: &ldquo;저는 백엔드 서버에서 <code>service_role</code> 키나 DB connection string으로만 안전하게 통신하는데, 굳이 RLS를 켤 필요가 있나요?&rdquo;</strong></p></blockquote><p><strong>A: 네, 반드시 켜야 합니다.</strong></p><p>백엔드와 DB 사이의 통신 채널이 안전한 것과 별개로, Supabase는 기본적으로 <code>anon</code> 키를 통한 **&lsquo;사용하지 않는 정문&rsquo;**을 열어두고 있습니다. RLS를 활성화하는 것은 바로 이 정문을 잠그고, 오직 우리가 통제하는 백엔드라는 &lsquo;뒷문&rsquo;으로만 출입하도록 강제하는 행위입니다.</p><h2 id=4-백엔드-중심-운영을-위한-rls-보안-전략-best-practice>4. 백엔드 중심 운영을 위한 RLS 보안 전략 (Best Practice)<a hidden class=anchor aria-hidden=true href=#4-백엔드-중심-운영을-위한-rls-보안-전략-best-practice>#</a></h2><p><code>anon</code> 키를 사용할 계획이 없는 백엔드 중심 프로젝트라면, 보안 설정은 매우 간단하고 명확합니다.</p><h3 id=단계-1-rls-활성화-앞문-잠그기>단계 1: RLS 활성화 (앞문 잠그기)<a hidden class=anchor aria-hidden=true href=#단계-1-rls-활성화-앞문-잠그기>#</a></h3><p>가장 먼저 할 일은 사용하지 않을 <code>anon</code> 키의 접근 경로를 원천 차단하는 것입니다. 별도의 정책(Policy)을 만들 필요조차 없습니다. RLS만 활성화하면, 기본적으로 &lsquo;DENY ALL&rsquo;(모든 요청 거부) 정책이 적용되어 모든 익명 요청이 자동으로 차단됩니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#75715e>-- RLS를 활성화할 대상 테이블 지정
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>TABLE</span> <span style=color:#66d9ef>public</span>.users ENABLE <span style=color:#66d9ef>ROW</span> <span style=color:#66d9ef>LEVEL</span> <span style=color:#66d9ef>SECURITY</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>TABLE</span> <span style=color:#66d9ef>public</span>.notes ENABLE <span style=color:#66d9ef>ROW</span> <span style=color:#66d9ef>LEVEL</span> <span style=color:#66d9ef>SECURITY</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- 테이블에 강제로 RLS 적용 (이미 활성화된 경우에도 확인차 실행)
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>TABLE</span> <span style=color:#66d9ef>public</span>.users <span style=color:#66d9ef>FORCE</span> <span style=color:#66d9ef>ROW</span> <span style=color:#66d9ef>LEVEL</span> <span style=color:#66d9ef>SECURITY</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>TABLE</span> <span style=color:#66d9ef>public</span>.notes <span style=color:#66d9ef>FORCE</span> <span style=color:#66d9ef>ROW</span> <span style=color:#66d9ef>LEVEL</span> <span style=color:#66d9ef>SECURITY</span>;
</span></span></code></pre></div><p>이 두 줄의 SQL만으로 <code>anon</code> 키를 사용한 모든 API 요청은 실패하게 됩니다.</p><h3 id=단계-2-백엔드는-기존-방식-그대로-운영>단계 2: 백엔드는 기존 방식 그대로 운영<a hidden class=anchor aria-hidden=true href=#단계-2-백엔드는-기존-방식-그대로-운영>#</a></h3><p>백엔드 서버에서는 기존처럼 <code>service_role</code> 키 또는 데이터베이스 비밀 연결 문자열을 그대로 사용하면 됩니다. 이 키들은 RLS를 우회하므로, RLS 활성화 여부와 관계없이 기존 백엔드 로직과 성능에 <strong>아무런 영향도 주지 않습니다.</strong></p><h3 id=단계-3-심층-방어-defense-in-depth>단계 3: 심층 방어 (Defense in Depth)<a hidden class=anchor aria-hidden=true href=#단계-3-심층-방어-defense-in-depth>#</a></h3><p>RLS를 켜두면 얘기치 못한 상황에서 최후의 방어선 역할을 합니다. 예를 들어, 백엔드 서버가 해킹당하거나 코드 로직에 실수가 생겨 의도치 않은 데이터 변경이 발생하려 할 때, 데이터베이스 수준에 설정된 RLS가 2차적인 방어벽이 되어줄 수 있습니다.</p><h2 id=5-프론트엔드-운영을-위한-rls-정책-수립-anon-키-활용>5. 프론트엔드 운영을 위한 RLS 정책 수립 (anon 키 활용)<a hidden class=anchor aria-hidden=true href=#5-프론트엔드-운영을-위한-rls-정책-수립-anon-키-활용>#</a></h2><p>백엔드만 사용하는 경우와 달리, 프론트엔드에서 Supabase를 직접 호출하려면 <code>anon</code> 키에 대한 접근을 허용해야 합니다. 이는 RLS를 끄는 것이 아니라, <strong>어떤 조건에서 <code>anon</code> 키의 요청을 허용할지</strong>에 대한 구체적인 정책(Policy)을 정의하는 것을 의미합니다.</p><h3 id=51-rls-정책의-기본-구조-using과-with-check>5.1. RLS 정책의 기본 구조: <code>USING</code>과 <code>WITH CHECK</code><a hidden class=anchor aria-hidden=true href=#51-rls-정책의-기본-구조-using과-with-check>#</a></h3><p>RLS 정책은 크게 <code>USING</code> 절과 <code>WITH CHECK</code> 절로 구성됩니다.</p><ul><li><strong><code>USING</code> (읽기 접근 제어)</strong>: <code>SELECT</code> 쿼리가 실행될 때 적용됩니다. 이 조건이 <code>true</code>를 반환하는 행(Row)만 사용자에게 보입니다.</li><li><strong><code>WITH CHECK</code> (쓰기 접근 제어)</strong>: <code>INSERT</code> 또는 <code>UPDATE</code> 쿼리가 실행될 때 적용됩니다. 이 조건이 <code>true</code>를 반환해야만 데이터의 삽입 또는 수정이 허용됩니다. <code>DELETE</code>는 <code>USING</code> 절의 규칙을 따릅니다.</li></ul><h3 id=52-정책-예시-1-인증된-사용자는-자신의-데이터만-관리>5.2. 정책 예시 1: 인증된 사용자는 자신의 데이터만 관리<a hidden class=anchor aria-hidden=true href=#52-정책-예시-1-인증된-사용자는-자신의-데이터만-관리>#</a></h3><p>가장 흔한 시나리오입니다. 예를 들어 <code>profiles</code> 테이블이 있고, 사용자는 자신의 프로필만 보고 수정할 수 있어야 합니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#75715e>-- 이 정책은 &#39;profiles&#39; 테이블에 적용됩니다.
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> POLICY <span style=color:#e6db74>&#34;Users can manage their own profile.&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- 어떤 작업에 대해? SELECT, INSERT, UPDATE, DELETE 모두
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>ON</span> <span style=color:#66d9ef>public</span>.profiles <span style=color:#66d9ef>FOR</span> <span style=color:#66d9ef>ALL</span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- 누가 접근할 때? 인증된 모든 사용자 (anon 역할 아님)
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>TO</span> authenticated
</span></span><span style=display:flex><span><span style=color:#75715e>-- 읽기 조건: 행의 id가 현재 로그인한 사용자의 id와 같아야 함
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>USING</span> ( auth.uid() <span style=color:#f92672>=</span> id )
</span></span><span style=display:flex><span><span style=color:#75715e>-- 쓰기 조건: 삽입/수정하려는 행의 id가 현재 로그인한 사용자의 id와 같아야 함
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>WITH</span> <span style=color:#66d9ef>CHECK</span> ( auth.uid() <span style=color:#f92672>=</span> id );
</span></span></code></pre></div><p><code>auth.uid()</code>는 Supabase가 제공하는 헬퍼 함수로, 요청을 보낸 사용자의 고유 ID(UUID)를 반환합니다. 이 정책 덕분에 사용자는 <code>anon</code> 키로 API를 호출하더라도 데이터베이스 수준에서 자신의 데이터에만 안전하게 접근할 수 있습니다.</p><h3 id=53-정책-예시-2-공개-데이터와-개인-데이터-혼합>5.3. 정책 예시 2: 공개 데이터와 개인 데이터 혼합<a hidden class=anchor aria-hidden=true href=#53-정책-예시-2-공개-데이터와-개인-데이터-혼합>#</a></h3><p>블로그 게시물을 생각해보겠습니다. 모든 게시물(<code>posts</code>)은 누구나 읽을 수 있지만, 작성은 인증된 사용자만 가능하고, 수정/삭제는 작성자 본인만 가능해야 합니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#75715e>-- 1. 모든 사용자가 게시물을 읽을 수 있도록 허용하는 정책 (SELECT)
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> POLICY <span style=color:#e6db74>&#34;Public can read all posts.&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>ON</span> <span style=color:#66d9ef>public</span>.posts <span style=color:#66d9ef>FOR</span> <span style=color:#66d9ef>SELECT</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>TO</span> <span style=color:#66d9ef>public</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>USING</span> ( <span style=color:#66d9ef>true</span> ); <span style=color:#75715e>-- &#39;true&#39;는 항상 참이므로 모든 행을 볼 수 있음
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- 2. 인증된 사용자만 게시물을 작성할 수 있도록 허용하는 정책 (INSERT)
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> POLICY <span style=color:#e6db74>&#34;Authenticated users can create posts.&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>ON</span> <span style=color:#66d9ef>public</span>.posts <span style=color:#66d9ef>FOR</span> <span style=color:#66d9ef>INSERT</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>TO</span> authenticated
</span></span><span style=display:flex><span><span style=color:#66d9ef>WITH</span> <span style=color:#66d9ef>CHECK</span> ( <span style=color:#66d9ef>true</span> ); <span style=color:#75715e>-- 인증만 되었다면 누구나 작성 가능
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- 3. 작성자 본인만 게시물을 수정할 수 있도록 허용하는 정책 (UPDATE)
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> POLICY <span style=color:#e6db74>&#34;Owners can update their own posts.&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>ON</span> <span style=color:#66d9ef>public</span>.posts <span style=color:#66d9ef>FOR</span> <span style=color:#66d9ef>UPDATE</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>TO</span> authenticated
</span></span><span style=display:flex><span><span style=color:#66d9ef>USING</span> ( auth.uid() <span style=color:#f92672>=</span> user_id ) <span style=color:#75715e>-- 수정할 행을 찾는 조건
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>WITH</span> <span style=color:#66d9ef>CHECK</span> ( auth.uid() <span style=color:#f92672>=</span> user_id ); <span style=color:#75715e>-- 수정할 내용이 제약조건을 만족하는지 확인
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- 4. 작성자 본인만 게시물을 삭제할 수 있도록 허용하는 정책 (DELETE)
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> POLICY <span style=color:#e6db74>&#34;Owners can delete their own posts.&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>ON</span> <span style=color:#66d9ef>public</span>.posts <span style=color:#66d9ef>FOR</span> <span style=color:#66d9ef>DELETE</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>TO</span> authenticated
</span></span><span style=display:flex><span><span style=color:#66d9ef>USING</span> ( auth.uid() <span style=color:#f92672>=</span> user_id ); <span style=color:#75715e>-- 삭제할 행을 찾는 조건
</span></span></span></code></pre></div><p>이처럼 작업(<code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>)과 역할(<code>public</code>, <code>authenticated</code>)에 따라 여러 정책을 조합하여 매우 세분화된 규칙을 만들 수 있습니다.</p><h2 id=6-좋은-rls-정책을-설계하는-기준>6. 좋은 RLS 정책을 설계하는 기준<a hidden class=anchor aria-hidden=true href=#6-좋은-rls-정책을-설계하는-기준>#</a></h2><p>효과적이고 안전한 RLS 정책을 만들려면 다음 기준을 따르는 것이 좋습니다. 이는 <code>anon</code> 키에 부여할 권한을 어떻게 잘게 나눌 것인가에 대한 기준, 즉 &lsquo;anon 키 분해 기준&rsquo;이 됩니다.</p><ol><li><p><strong>기본적으로 거부 (Default Deny)</strong>
가장 중요한 원칙입니다. <code>ALTER TABLE ... ENABLE ROW LEVEL SECURITY;</code>를 실행하는 순간 모든 접근이 차단됩니다. 그 상태에서 꼭 필요한 권한만 정책을 통해 하나씩 허용해야 합니다.</p></li><li><p><strong>최소 권한의 원칙 (Principle of Least Privilege)</strong>
사용자에게 꼭 필요한 최소한의 권한만 부여합니다. 예를 들어, 단순히 게시물을 읽기만 하면 되는 익명 사용자(<code>public</code>)에게 <code>UPDATE</code>나 <code>DELETE</code> 권한을 줄 이유가 없습니다.</p></li><li><p><strong>역할과 행동에 따라 정책 분리</strong>
위의 게시물 예시처럼, 하나의 큰 정책을 만드는 대신 <code>SELECT</code>용, <code>INSERT</code>용, <code>UPDATE</code>용 정책을 명확하게 분리하는 것이 좋습니다. 이렇게 하면 정책을 이해하고 디버깅하기 쉬워집니다.</p></li><li><p><strong><code>USING</code>과 <code>WITH CHECK</code>를 명확히 이해하고 사용</strong></p><ul><li>조회(View) 권한은 <code>USING</code>으로 제어합니다.</li><li>생성/수정(Mutation) 권한은 <code>WITH CHECK</code>로 제어하여 데이터 무결성을 보장해야 합니다. <code>CHECK</code> 조건을 누락하면 사용자가 다른 사람의 <code>user_id</code>로 데이터를 삽입하는 등의 문제가 발생할 수 있습니다.</li></ul></li></ol><h2 id=7-새로운-요약-및-결론>7. 새로운 요약 및 결론<a hidden class=anchor aria-hidden=true href=#7-새로운-요약-및-결론>#</a></h2><p>Supabase의 RLS는 단순히 <code>anon</code> 키를 차단하는 수단이 아니라, 프론트엔드와 직접 통신할 때 <strong>어떤 데이터를, 누구에게, 어떻게 허용할지</strong>를 정의하는 강력한 규칙 엔진입니다.</p><table><thead><tr><th style=text-align:left>구분</th><th style=text-align:left>프론트엔드 (Client-Side)</th><th style=text-align:left>백엔드 (Server-Side)</th></tr></thead><tbody><tr><td style=text-align:left><strong>인증 수단</strong></td><td style=text-align:left><code>anon</code> 키 (공개)</td><td style=text-align:left><code>service_role</code> 키 (비밀)</td></tr><tr><td style=text-align:left><strong>RLS 영향</strong></td><td style=text-align:left><strong>강제 적용</strong> (보안의 핵심)</td><td style=text-align:left><strong>우회</strong> (성능/로직에 영향 없음)</td></tr><tr><td style=text-align:left><strong>보안 주체</strong></td><td style=text-align:left><strong>데이터베이스(RLS)</strong> + 프론트 로직</td><td style=text-align:left>백엔드 애플리케이션 로직</td></tr><tr><td style=text-align:left><strong>RLS 목적</strong></td><td style=text-align:left>세분화된 데이터 접근 규칙 정의</td><td style=text-align:left><code>anon</code> 키를 통한 비인가 접근 전면 차단</td></tr></tbody></table><p><strong>최종 결론</strong>: RLS는 백엔드만 사용하든, 프론트엔드와 함께 사용하든 <strong>반드시 활성화해야 하는 필수 보안 기능</strong>입니다. 백엔드 중심이라면 모든 접근을 차단하는 방화벽으로, 프론트엔드 중심이라면 데이터 접근 규칙을 정의하는 설계도로서 RLS를 적극 활용해야 합니다.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://cdecl.github.io/tags/supabase/>Supabase</a></li><li><a href=https://cdecl.github.io/tags/postgresql/>PostgreSQL</a></li><li><a href=https://cdecl.github.io/tags/security/>Security</a></li><li><a href=https://cdecl.github.io/tags/rls/>RLS</a></li><li><a href=https://cdecl.github.io/tags/backend/>Backend</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://cdecl.github.io/>cdeclog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>