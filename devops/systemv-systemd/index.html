<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>리눅스의 Init 시스템 | cdeclog</title><meta name=keywords content="linux,systemd,system v init,docker,init system,ubuntu,centos,service management"><meta name=description content="리눅스의 Init 시스템: System V Init와 Systemd 비교 분석 및 docker 활용
개요
리눅스 시스템에서 운영체제 부팅 시 초기화를 담당하는 프로그램을 init 시스템이라고 합니다.
전통적인 System V Init와 현대적인 Systemd를 비교 분석하여, 시스템 초기화 방식의 발전과 실무적 영향을 살펴보겠습니다.
System V Init와 Systemd의 역사적 배경
System V Init
1983년 Unix System V에서 처음 도입된 init 시스템으로, 당시 컴퓨팅 환경의 단순함에 맞춰 설계되었습니다. 이 시스템은 주로 서버와 메인프레임에서 사용되었으며, 런레벨 기반의 단순한 상태 전환을 제공했습니다."><meta name=author content="Byung Kyu KIM"><link rel=canonical href=https://cdecl.github.io/devops/systemv-systemd/><link crossorigin=anonymous href=/assets/css/stylesheet.f939c4ffefb264e6fe85e04352266f79db6bb1303c8e16ae9b6064c1247b5e32.css integrity="sha256-+TnE/++yZOb+heBDUiZvedtrsTA8jhaum2BkwSR7XjI=" rel="preload stylesheet" as=style><link rel=icon href=https://cdecl.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://cdecl.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://cdecl.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://cdecl.github.io/apple-touch-icon.png><link rel=mask-icon href=https://cdecl.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://cdecl.github.io/devops/systemv-systemd/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-VQQHHYPN7K"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VQQHHYPN7K")}</script><meta property="og:url" content="https://cdecl.github.io/devops/systemv-systemd/"><meta property="og:site_name" content="cdeclog"><meta property="og:title" content="리눅스의 Init 시스템"><meta property="og:description" content="리눅스의 Init 시스템: System V Init와 Systemd 비교 분석 및 docker 활용
개요 리눅스 시스템에서 운영체제 부팅 시 초기화를 담당하는 프로그램을 init 시스템이라고 합니다.
전통적인 System V Init와 현대적인 Systemd를 비교 분석하여, 시스템 초기화 방식의 발전과 실무적 영향을 살펴보겠습니다.
System V Init와 Systemd의 역사적 배경 System V Init 1983년 Unix System V에서 처음 도입된 init 시스템으로, 당시 컴퓨팅 환경의 단순함에 맞춰 설계되었습니다. 이 시스템은 주로 서버와 메인프레임에서 사용되었으며, 런레벨 기반의 단순한 상태 전환을 제공했습니다."><meta property="og:locale" content="ko-kr"><meta property="og:type" content="article"><meta property="article:section" content="devops"><meta property="article:published_time" content="2024-11-03T00:00:00+09:00"><meta property="article:modified_time" content="2024-11-03T00:00:00+09:00"><meta property="article:tag" content="Linux"><meta property="article:tag" content="Systemd"><meta property="article:tag" content="System v Init"><meta property="article:tag" content="Docker"><meta property="article:tag" content="Init System"><meta property="article:tag" content="Ubuntu"><meta name=twitter:card content="summary"><meta name=twitter:title content="리눅스의 Init 시스템"><meta name=twitter:description content="리눅스의 Init 시스템: System V Init와 Systemd 비교 분석 및 docker 활용
개요
리눅스 시스템에서 운영체제 부팅 시 초기화를 담당하는 프로그램을 init 시스템이라고 합니다.
전통적인 System V Init와 현대적인 Systemd를 비교 분석하여, 시스템 초기화 방식의 발전과 실무적 영향을 살펴보겠습니다.
System V Init와 Systemd의 역사적 배경
System V Init
1983년 Unix System V에서 처음 도입된 init 시스템으로, 당시 컴퓨팅 환경의 단순함에 맞춰 설계되었습니다. 이 시스템은 주로 서버와 메인프레임에서 사용되었으며, 런레벨 기반의 단순한 상태 전환을 제공했습니다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Devops","item":"https://cdecl.github.io/devops/"},{"@type":"ListItem","position":2,"name":"리눅스의 Init 시스템","item":"https://cdecl.github.io/devops/systemv-systemd/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"리눅스의 Init 시스템","name":"리눅스의 Init 시스템","description":"리눅스의 Init 시스템: System V Init와 Systemd 비교 분석 및 docker 활용\n개요 리눅스 시스템에서 운영체제 부팅 시 초기화를 담당하는 프로그램을 init 시스템이라고 합니다.\n전통적인 System V Init와 현대적인 Systemd를 비교 분석하여, 시스템 초기화 방식의 발전과 실무적 영향을 살펴보겠습니다.\nSystem V Init와 Systemd의 역사적 배경 System V Init 1983년 Unix System V에서 처음 도입된 init 시스템으로, 당시 컴퓨팅 환경의 단순함에 맞춰 설계되었습니다. 이 시스템은 주로 서버와 메인프레임에서 사용되었으며, 런레벨 기반의 단순한 상태 전환을 제공했습니다.\n","keywords":["linux","systemd","system v init","docker","init system","ubuntu","centos","service management"],"articleBody":"리눅스의 Init 시스템: System V Init와 Systemd 비교 분석 및 docker 활용\n개요 리눅스 시스템에서 운영체제 부팅 시 초기화를 담당하는 프로그램을 init 시스템이라고 합니다.\n전통적인 System V Init와 현대적인 Systemd를 비교 분석하여, 시스템 초기화 방식의 발전과 실무적 영향을 살펴보겠습니다.\nSystem V Init와 Systemd의 역사적 배경 System V Init 1983년 Unix System V에서 처음 도입된 init 시스템으로, 당시 컴퓨팅 환경의 단순함에 맞춰 설계되었습니다. 이 시스템은 주로 서버와 메인프레임에서 사용되었으며, 런레벨 기반의 단순한 상태 전환을 제공했습니다.\nSystemd 2010년대 초반, Linux 커뮤니티는 더 복잡한 현대 컴퓨팅 환경에 대응하기 위해 새로운 init 시스템이 필요하다고 인식했습니다. 이에 따라 Lennart Poettering과 Kay Sievers가 주도하여 Systemd가 개발되었습니다. Systemd는 병렬 실행 및 종합적인 시스템 관리 기능을 통해 현대 리눅스 시스템의 복잡성을 해결하고자 했습니다.\nSystem V Init의 이해 기본 개념과 역할 Unix System V에서 유래한 전통적인 초기화 시스템 PID 1 프로세스로 동작하며 시스템의 첫 번째 프로세스 런레벨(runlevel) 기반의 시스템 상태 관리 주요 특징 1. 런레벨 시스템 런레벨 0: 시스템 종료 런레벨 1: 단일 사용자 모드 런레벨 3: 멀티유저 모드 (CLI) 런레벨 5: 그래픽 사용자 인터페이스 모드 런레벨 6: 시스템 재부팅 2. 디렉토리 구조 /etc/init.d/: 서비스 스크립트 저장 /etc/rcN.d/: 각 런레벨(N)별 심볼릭 링크 /etc/inittab: 기본 런레벨 및 init 설정 3. 서비스 관리 명령어 service httpd start /etc/init.d/httpd stop chkconfig httpd on System V Init 제한사항 순차적 실행으로 인한 느린 부팅 속도 복잡한 의존성 관리의 어려움 동적 서비스 관리의 한계 Systemd의 등장 배경과 특징 등장 배경 현대 시스템의 복잡성 증가 병렬 처리를 통한 성능 개선 필요 더 나은 서비스 의존성 관리 요구 통합된 시스템 관리 도구의 필요성 주요 특징 시스템 초기화, 서비스 관리, 로그 관리, 시스템 상태 모니터링 등의 종합적인 기능 제공 부팅 과정에서 병렬 실행 지원 및 서비스 간 의존성 명시 Unit 파일 구조를 통한 서비스 구성과 제어의 용이성 다양한 유형의 리소스 관리 (서비스, 타이머, 장치 등) 1. Unit 시스템 [Unit] Description=My Web Service After=network.target Requires=mysql.service [Service] Type=simple ExecStart=/usr/bin/myapp Restart=always [Install] WantedBy=multi-user.target 2. 타겟(Target) 시스템 기존 런레벨을 대체하는 유연한 구조 다중 타겟 동시 활성화 가능 의존성 기반 서비스 그룹화 3. 주요 관리 명령어 # 서비스 관리 systemctl start httpd systemctl enable httpd systemctl status httpd # 로그 확인 journalctl -u httpd journalctl -f # 타겟 관리 systemctl isolate multi-user.target systemctl get-default 핵심 차이점 분석 아키텍처 비교 특징 System V Init Systemd 실행 방식 순차적 병렬 설정 방식 Shell 스크립트 Unit 파일 의존성 관리 번호 기반 순서 선언적 의존성 상태 관리 런레벨 타겟 로깅 syslog journald 기술적 비교 심화 의존성 관리 System V Init는 서비스 간 의존성을 명시적으로 관리하지 않으며, 스크립트 실행 순서로 의존성을 처리합니다. 반면, Systemd는 선언적 의존성 관리 시스템을 통해 서비스 간 의존성을 명확히 정의하고 자동으로 관리합니다.\n서비스 복구 Systemd는 서비스 실패 시 자동 재시작 기능을 제공하여 높은 가용성을 지원합니다. 이는 특히 서버 환경에서 중요한 기능으로, 서비스 중단 시 자동 복구를 통해 다운타임을 최소화할 수 있습니다.\n성능 차이 부팅 속도\nSystem V Init: 순차적 실행으로 느림 Systemd: 병렬 실행으로 최대 2-3배 빠름 리소스 사용\nSystem V Init: 경량화 Systemd: 추가 기능으로 인한 더 많은 리소스 사용 운영자/개발자 고려사항 구성 관리의 변화 Systemd의 Unit 파일은 서비스 관리 및 설정이 체계적이므로 학습 및 사용법 숙지가 필요합니다. Systemd는 타겟 기반 관리와 의존성 트리 구조를 통해 복잡한 서비스를 안정적으로 관리할 수 있습니다. 부팅 및 서비스 관리의 효율성 부팅 시간 단축, 의존성 설정, 동시 실행 지원은 운영 및 시스템 초기화 효율성을 크게 개선시킵니다. 단일 명령으로 전체 서비스를 제어하거나 로그를 분석할 수 있어, journalctl 같은 Systemd의 추가 도구를 익히면 편리합니다. 장기적인 지원 및 호환성 문제 대부분의 리눅스 배포판이 Systemd를 기본 init 시스템으로 채택했지만, 일부 배포판에서는 여전히 System V Init 또는 대체 init 시스템을 사용하기도 합니다. 일부 레거시 스크립트와의 호환성 문제가 발생할 수 있으므로, Systemd와 호환되도록 스크립트를 수정해야 할 수도 있습니다. 시스템 관리 서비스 설정\nSystem V Init: /etc/init.d/ 스크립트 수정 Systemd: Unit 파일 작성 및 관리 문제 해결\nSystem V Init: tail -f /var/log/messages Systemd: journalctl -xeu service-name 마이그레이션 고려사항 기존 Init 스크립트의 Systemd Unit 변환 의존성 관계 재정의 로깅 시스템 변경 대응 Docker 환경에서의 활용 Docker는 보통 단일 프로세스 실행을 목표로 설계되었기 때문에, init 시스템을 사용하는 대신 애플리케이션이 바로 실행됩니다. 하지만 컨테이너 내 여러 서비스 관리를 위해 systemd가 필요할 때 추가적인 설정을 통해 사용할 수 있습니다.\n1. Docker에서 System V Init 방식 사용 일반적인 Docker 컨테이너는 단일 프로세스 원칙에 따라 동작합니다. System V Init 방식으로 단일 프로세스만 실행하는 예제를 보겠습니다.\n예제: System V Init 방식으로 Nginx 실행 FROM nginx:alpine CMD [\"nginx\", \"-g\", \"daemon off;\"] 2. Docker에서 Systemd 사용 설정 Docker 컨테이너에서 Systemd를 사용하려면, cgroup 설정과 권한을 조정해야 합니다.\n예제: Systemd 사용하여 다중 서비스 실행 FROM ubuntu:20.04 RUN apt-get update \u0026\u0026 apt-get install -y systemd VOLUME [ \"/sys/fs/cgroup\" ] CMD [\"/lib/systemd/systemd\"] 실행 방법:\ndocker build -t myapp_systemd . docker run --privileged -v /sys/fs/cgroup:/sys/fs/cgroup:ro -d myapp_systemd 3. 권장 사항 컨테이너는 단일 프로세스 원칙을 준수: 여러 서비스를 실행할 경우 별도의 컨테이너를 사용하는 것이 좋습니다. 경량화된 init 시스템 사용: 여러 프로세스를 관리할 필요가 있다면 Tini와 같은 경량화된 init 시스템을 사용하는 것이 좋습니다. 필요한 경우에만 systemd 도입: 가능한 한 가벼운 구성을 유지하는 것이 컨테이너 환경에 유리합니다. 주요 리눅스 배포판의 Systemd 도입 현황 CentOS: CentOS 7부터 systemd 기본 도입 Ubuntu: Ubuntu 15.04부터 systemd 기본 도입 Red Hat Enterprise Linux (RHEL): RHEL 7부터 systemd 기본 도입 Fedora: Fedora 15부터 systemd 기본 도입 Debian: Debian 8 (Jessie)부터 systemd 기본 도입 openSUSE 및 SUSE Linux Enterprise (SLE): openSUSE 12.1부터 systemd 도입 결론 Systemd는 현대 리눅스 시스템의 요구사항을 잘 반영한 init 시스템으로, 대부분의 주요 배포판에서 채택하고 있습니다. 하지만 컨테이너와 같은 특수한 환경에서는 상황에 맞는 적절한 초기화 방식을 선택하는 것이 중요합니다. 시스템 관리자와 개발자는 각 환경에 맞는 init 시스템의 특징을 이해하고, 이를 효과적으로 활용할 수 있어야 합니다.\n","wordCount":"892","inLanguage":"en","datePublished":"2024-11-03T00:00:00+09:00","dateModified":"2024-11-03T00:00:00+09:00","author":{"@type":"Person","name":"Byung Kyu KIM"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://cdecl.github.io/devops/systemv-systemd/"},"publisher":{"@type":"Organization","name":"cdeclog","logo":{"@type":"ImageObject","url":"https://cdecl.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://cdecl.github.io/ accesskey=h title="cdeclog (Alt + H)">cdeclog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://cdecl.github.io/dev/ title=Dev><span>Dev</span></a></li><li><a href=https://cdecl.github.io/devops/ title=DevOps><span>DevOps</span></a></li><li><a href=https://cdecl.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://cdecl.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://cdecl.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">리눅스의 Init 시스템</h1><div class=post-meta><span title='2024-11-03 00:00:00 +0900 KST'>November 3, 2024</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%ea%b0%9c%ec%9a%94 aria-label=개요>개요</a></li><li><a href=#system-v-init%ec%99%80-systemd%ec%9d%98-%ec%97%ad%ec%82%ac%ec%a0%81-%eb%b0%b0%ea%b2%bd aria-label="System V Init와 Systemd의 역사적 배경">System V Init와 Systemd의 역사적 배경</a><ul><li><a href=#system-v-init aria-label="System V Init">System V Init</a></li><li><a href=#systemd aria-label=Systemd>Systemd</a></li></ul></li><li><a href=#system-v-init%ec%9d%98-%ec%9d%b4%ed%95%b4 aria-label="System V Init의 이해">System V Init의 이해</a><ul><li><a href=#%ea%b8%b0%eb%b3%b8-%ea%b0%9c%eb%85%90%ea%b3%bc-%ec%97%ad%ed%95%a0 aria-label="기본 개념과 역할">기본 개념과 역할</a></li><li><a href=#%ec%a3%bc%ec%9a%94-%ed%8a%b9%ec%a7%95 aria-label="주요 특징">주요 특징</a><ul><li><a href=#1-%eb%9f%b0%eb%a0%88%eb%b2%a8-%ec%8b%9c%ec%8a%a4%ed%85%9c aria-label="1. 런레벨 시스템">1. 런레벨 시스템</a></li><li><a href=#2-%eb%94%94%eb%a0%89%ed%86%a0%eb%a6%ac-%ea%b5%ac%ec%a1%b0 aria-label="2. 디렉토리 구조">2. 디렉토리 구조</a></li><li><a href=#3-%ec%84%9c%eb%b9%84%ec%8a%a4-%ea%b4%80%eb%a6%ac-%eb%aa%85%eb%a0%b9%ec%96%b4 aria-label="3. 서비스 관리 명령어">3. 서비스 관리 명령어</a></li></ul></li><li><a href=#system-v-init-%ec%a0%9c%ed%95%9c%ec%82%ac%ed%95%ad aria-label="System V Init 제한사항">System V Init 제한사항</a></li></ul></li><li><a href=#systemd%ec%9d%98-%eb%93%b1%ec%9e%a5-%eb%b0%b0%ea%b2%bd%ea%b3%bc-%ed%8a%b9%ec%a7%95 aria-label="Systemd의 등장 배경과 특징">Systemd의 등장 배경과 특징</a><ul><li><a href=#%eb%93%b1%ec%9e%a5-%eb%b0%b0%ea%b2%bd aria-label="등장 배경">등장 배경</a></li><li><a href=#%ec%a3%bc%ec%9a%94-%ed%8a%b9%ec%a7%95-1 aria-label="주요 특징">주요 특징</a><ul><li><a href=#1-unit-%ec%8b%9c%ec%8a%a4%ed%85%9c aria-label="1. Unit 시스템">1. Unit 시스템</a></li><li><a href=#2-%ed%83%80%ea%b2%9ftarget-%ec%8b%9c%ec%8a%a4%ed%85%9c aria-label="2. 타겟(Target) 시스템">2. 타겟(Target) 시스템</a></li><li><a href=#3-%ec%a3%bc%ec%9a%94-%ea%b4%80%eb%a6%ac-%eb%aa%85%eb%a0%b9%ec%96%b4 aria-label="3. 주요 관리 명령어">3. 주요 관리 명령어</a></li></ul></li></ul></li><li><a href=#%ed%95%b5%ec%8b%ac-%ec%b0%a8%ec%9d%b4%ec%a0%90-%eb%b6%84%ec%84%9d aria-label="핵심 차이점 분석">핵심 차이점 분석</a><ul><li><a href=#%ec%95%84%ed%82%a4%ed%85%8d%ec%b2%98-%eb%b9%84%ea%b5%90 aria-label="아키텍처 비교">아키텍처 비교</a></li><li><a href=#%ea%b8%b0%ec%88%a0%ec%a0%81-%eb%b9%84%ea%b5%90-%ec%8b%ac%ed%99%94 aria-label="기술적 비교 심화">기술적 비교 심화</a><ul><li><a href=#%ec%9d%98%ec%a1%b4%ec%84%b1-%ea%b4%80%eb%a6%ac aria-label="의존성 관리">의존성 관리</a></li><li><a href=#%ec%84%9c%eb%b9%84%ec%8a%a4-%eb%b3%b5%ea%b5%ac aria-label="서비스 복구">서비스 복구</a></li></ul></li><li><a href=#%ec%84%b1%eb%8a%a5-%ec%b0%a8%ec%9d%b4 aria-label="성능 차이">성능 차이</a></li></ul></li><li><a href=#%ec%9a%b4%ec%98%81%ec%9e%90%ea%b0%9c%eb%b0%9c%ec%9e%90-%ea%b3%a0%eb%a0%a4%ec%82%ac%ed%95%ad aria-label="운영자/개발자 고려사항">운영자/개발자 고려사항</a><ul><li><a href=#%ea%b5%ac%ec%84%b1-%ea%b4%80%eb%a6%ac%ec%9d%98-%eb%b3%80%ed%99%94 aria-label="구성 관리의 변화">구성 관리의 변화</a></li><li><a href=#%eb%b6%80%ed%8c%85-%eb%b0%8f-%ec%84%9c%eb%b9%84%ec%8a%a4-%ea%b4%80%eb%a6%ac%ec%9d%98-%ed%9a%a8%ec%9c%a8%ec%84%b1 aria-label="부팅 및 서비스 관리의 효율성">부팅 및 서비스 관리의 효율성</a></li><li><a href=#%ec%9e%a5%ea%b8%b0%ec%a0%81%ec%9d%b8-%ec%a7%80%ec%9b%90-%eb%b0%8f-%ed%98%b8%ed%99%98%ec%84%b1-%eb%ac%b8%ec%a0%9c aria-label="장기적인 지원 및 호환성 문제">장기적인 지원 및 호환성 문제</a></li><li><a href=#%ec%8b%9c%ec%8a%a4%ed%85%9c-%ea%b4%80%eb%a6%ac aria-label="시스템 관리">시스템 관리</a></li><li><a href=#%eb%a7%88%ec%9d%b4%ea%b7%b8%eb%a0%88%ec%9d%b4%ec%85%98-%ea%b3%a0%eb%a0%a4%ec%82%ac%ed%95%ad aria-label="마이그레이션 고려사항">마이그레이션 고려사항</a></li></ul></li><li><a href=#docker-%ed%99%98%ea%b2%bd%ec%97%90%ec%84%9c%ec%9d%98-%ed%99%9c%ec%9a%a9 aria-label="Docker 환경에서의 활용">Docker 환경에서의 활용</a><ul><li><a href=#1-docker%ec%97%90%ec%84%9c-system-v-init-%eb%b0%a9%ec%8b%9d-%ec%82%ac%ec%9a%a9 aria-label="1. Docker에서 System V Init 방식 사용">1. Docker에서 System V Init 방식 사용</a><ul><li><a href=#%ec%98%88%ec%a0%9c-system-v-init-%eb%b0%a9%ec%8b%9d%ec%9c%bc%eb%a1%9c-nginx-%ec%8b%a4%ed%96%89 aria-label="예제: System V Init 방식으로 Nginx 실행">예제: System V Init 방식으로 Nginx 실행</a></li></ul></li><li><a href=#2-docker%ec%97%90%ec%84%9c-systemd-%ec%82%ac%ec%9a%a9-%ec%84%a4%ec%a0%95 aria-label="2. Docker에서 Systemd 사용 설정">2. Docker에서 Systemd 사용 설정</a><ul><li><a href=#%ec%98%88%ec%a0%9c-systemd-%ec%82%ac%ec%9a%a9%ed%95%98%ec%97%ac-%eb%8b%a4%ec%a4%91-%ec%84%9c%eb%b9%84%ec%8a%a4-%ec%8b%a4%ed%96%89 aria-label="예제: Systemd 사용하여 다중 서비스 실행">예제: Systemd 사용하여 다중 서비스 실행</a></li></ul></li><li><a href=#3-%ea%b6%8c%ec%9e%a5-%ec%82%ac%ed%95%ad aria-label="3. 권장 사항">3. 권장 사항</a></li></ul></li><li><a href=#%ec%a3%bc%ec%9a%94-%eb%a6%ac%eb%88%85%ec%8a%a4-%eb%b0%b0%ed%8f%ac%ed%8c%90%ec%9d%98-systemd-%eb%8f%84%ec%9e%85-%ed%98%84%ed%99%a9 aria-label="주요 리눅스 배포판의 Systemd 도입 현황">주요 리눅스 배포판의 Systemd 도입 현황</a></li><li><a href=#%ea%b2%b0%eb%a1%a0 aria-label=결론>결론</a></li></ul></div></details></div><div class=post-content><p>리눅스의 Init 시스템: System V Init와 Systemd 비교 분석 및 docker 활용</p><h2 id=개요>개요<a hidden class=anchor aria-hidden=true href=#개요>#</a></h2><p>리눅스 시스템에서 운영체제 부팅 시 초기화를 담당하는 프로그램을 init 시스템이라고 합니다.<br>전통적인 System V Init와 현대적인 Systemd를 비교 분석하여, 시스템 초기화 방식의 발전과 실무적 영향을 살펴보겠습니다.</p><h2 id=system-v-init와-systemd의-역사적-배경>System V Init와 Systemd의 역사적 배경<a hidden class=anchor aria-hidden=true href=#system-v-init와-systemd의-역사적-배경>#</a></h2><h3 id=system-v-init>System V Init<a hidden class=anchor aria-hidden=true href=#system-v-init>#</a></h3><p>1983년 Unix System V에서 처음 도입된 init 시스템으로, 당시 컴퓨팅 환경의 단순함에 맞춰 설계되었습니다. 이 시스템은 주로 서버와 메인프레임에서 사용되었으며, 런레벨 기반의 단순한 상태 전환을 제공했습니다.</p><h3 id=systemd>Systemd<a hidden class=anchor aria-hidden=true href=#systemd>#</a></h3><p>2010년대 초반, Linux 커뮤니티는 더 복잡한 현대 컴퓨팅 환경에 대응하기 위해 새로운 init 시스템이 필요하다고 인식했습니다. 이에 따라 Lennart Poettering과 Kay Sievers가 주도하여 Systemd가 개발되었습니다. Systemd는 병렬 실행 및 종합적인 시스템 관리 기능을 통해 현대 리눅스 시스템의 복잡성을 해결하고자 했습니다.</p><h2 id=system-v-init의-이해>System V Init의 이해<a hidden class=anchor aria-hidden=true href=#system-v-init의-이해>#</a></h2><h3 id=기본-개념과-역할>기본 개념과 역할<a hidden class=anchor aria-hidden=true href=#기본-개념과-역할>#</a></h3><ul><li>Unix System V에서 유래한 전통적인 초기화 시스템</li><li>PID 1 프로세스로 동작하며 시스템의 첫 번째 프로세스</li><li>런레벨(runlevel) 기반의 시스템 상태 관리</li></ul><h3 id=주요-특징>주요 특징<a hidden class=anchor aria-hidden=true href=#주요-특징>#</a></h3><h4 id=1-런레벨-시스템>1. 런레벨 시스템<a hidden class=anchor aria-hidden=true href=#1-런레벨-시스템>#</a></h4><ul><li>런레벨 0: 시스템 종료</li><li>런레벨 1: 단일 사용자 모드</li><li>런레벨 3: 멀티유저 모드 (CLI)</li><li>런레벨 5: 그래픽 사용자 인터페이스 모드</li><li>런레벨 6: 시스템 재부팅</li></ul><h4 id=2-디렉토리-구조>2. 디렉토리 구조<a hidden class=anchor aria-hidden=true href=#2-디렉토리-구조>#</a></h4><ul><li><code>/etc/init.d/</code>: 서비스 스크립트 저장</li><li><code>/etc/rcN.d/</code>: 각 런레벨(N)별 심볼릭 링크</li><li><code>/etc/inittab</code>: 기본 런레벨 및 init 설정</li></ul><h4 id=3-서비스-관리-명령어>3. 서비스 관리 명령어<a hidden class=anchor aria-hidden=true href=#3-서비스-관리-명령어>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>service httpd start
</span></span><span style=display:flex><span>/etc/init.d/httpd stop
</span></span><span style=display:flex><span>chkconfig httpd on
</span></span></code></pre></div><h3 id=system-v-init-제한사항>System V Init 제한사항<a hidden class=anchor aria-hidden=true href=#system-v-init-제한사항>#</a></h3><ul><li>순차적 실행으로 인한 느린 부팅 속도</li><li>복잡한 의존성 관리의 어려움</li><li>동적 서비스 관리의 한계</li></ul><h2 id=systemd의-등장-배경과-특징>Systemd의 등장 배경과 특징<a hidden class=anchor aria-hidden=true href=#systemd의-등장-배경과-특징>#</a></h2><h3 id=등장-배경>등장 배경<a hidden class=anchor aria-hidden=true href=#등장-배경>#</a></h3><ol><li>현대 시스템의 복잡성 증가</li><li>병렬 처리를 통한 성능 개선 필요</li><li>더 나은 서비스 의존성 관리 요구</li><li>통합된 시스템 관리 도구의 필요성</li></ol><h3 id=주요-특징-1>주요 특징<a hidden class=anchor aria-hidden=true href=#주요-특징-1>#</a></h3><ul><li>시스템 초기화, 서비스 관리, 로그 관리, 시스템 상태 모니터링 등의 종합적인 기능 제공</li><li>부팅 과정에서 병렬 실행 지원 및 서비스 간 의존성 명시</li><li>Unit 파일 구조를 통한 서비스 구성과 제어의 용이성</li><li>다양한 유형의 리소스 관리 (서비스, 타이머, 장치 등)</li></ul><h4 id=1-unit-시스템>1. Unit 시스템<a hidden class=anchor aria-hidden=true href=#1-unit-시스템>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ini data-lang=ini><span style=display:flex><span><span style=color:#ff79c6>[Unit]</span>
</span></span><span style=display:flex><span><span style=color:#50fa7b>Description</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>My Web Service</span>
</span></span><span style=display:flex><span><span style=color:#50fa7b>After</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>network.target</span>
</span></span><span style=display:flex><span><span style=color:#50fa7b>Requires</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>mysql.service</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>[Service]</span>
</span></span><span style=display:flex><span><span style=color:#50fa7b>Type</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>simple</span>
</span></span><span style=display:flex><span><span style=color:#50fa7b>ExecStart</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>/usr/bin/myapp</span>
</span></span><span style=display:flex><span><span style=color:#50fa7b>Restart</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>always</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>[Install]</span>
</span></span><span style=display:flex><span><span style=color:#50fa7b>WantedBy</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>multi-user.target</span>
</span></span></code></pre></div><h4 id=2-타겟target-시스템>2. 타겟(Target) 시스템<a hidden class=anchor aria-hidden=true href=#2-타겟target-시스템>#</a></h4><ul><li>기존 런레벨을 대체하는 유연한 구조</li><li>다중 타겟 동시 활성화 가능</li><li>의존성 기반 서비스 그룹화</li></ul><h4 id=3-주요-관리-명령어>3. 주요 관리 명령어<a hidden class=anchor aria-hidden=true href=#3-주요-관리-명령어>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#6272a4># 서비스 관리</span>
</span></span><span style=display:flex><span>systemctl start httpd
</span></span><span style=display:flex><span>systemctl <span style=color:#8be9fd;font-style:italic>enable</span> httpd
</span></span><span style=display:flex><span>systemctl status httpd
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4># 로그 확인</span>
</span></span><span style=display:flex><span>journalctl -u httpd
</span></span><span style=display:flex><span>journalctl -f
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4># 타겟 관리</span>
</span></span><span style=display:flex><span>systemctl isolate multi-user.target
</span></span><span style=display:flex><span>systemctl get-default
</span></span></code></pre></div><h2 id=핵심-차이점-분석>핵심 차이점 분석<a hidden class=anchor aria-hidden=true href=#핵심-차이점-분석>#</a></h2><h3 id=아키텍처-비교>아키텍처 비교<a hidden class=anchor aria-hidden=true href=#아키텍처-비교>#</a></h3><table><thead><tr><th>특징</th><th>System V Init</th><th>Systemd</th></tr></thead><tbody><tr><td>실행 방식</td><td>순차적</td><td>병렬</td></tr><tr><td>설정 방식</td><td>Shell 스크립트</td><td>Unit 파일</td></tr><tr><td>의존성 관리</td><td>번호 기반 순서</td><td>선언적 의존성</td></tr><tr><td>상태 관리</td><td>런레벨</td><td>타겟</td></tr><tr><td>로깅</td><td>syslog</td><td>journald</td></tr></tbody></table><h3 id=기술적-비교-심화>기술적 비교 심화<a hidden class=anchor aria-hidden=true href=#기술적-비교-심화>#</a></h3><h4 id=의존성-관리>의존성 관리<a hidden class=anchor aria-hidden=true href=#의존성-관리>#</a></h4><p>System V Init는 서비스 간 의존성을 명시적으로 관리하지 않으며, 스크립트 실행 순서로 의존성을 처리합니다. 반면, Systemd는 선언적 의존성 관리 시스템을 통해 서비스 간 의존성을 명확히 정의하고 자동으로 관리합니다.</p><h4 id=서비스-복구>서비스 복구<a hidden class=anchor aria-hidden=true href=#서비스-복구>#</a></h4><p>Systemd는 서비스 실패 시 자동 재시작 기능을 제공하여 높은 가용성을 지원합니다. 이는 특히 서버 환경에서 중요한 기능으로, 서비스 중단 시 자동 복구를 통해 다운타임을 최소화할 수 있습니다.</p><h3 id=성능-차이>성능 차이<a hidden class=anchor aria-hidden=true href=#성능-차이>#</a></h3><ol><li><p><strong>부팅 속도</strong></p><ul><li>System V Init: 순차적 실행으로 느림</li><li>Systemd: 병렬 실행으로 최대 2-3배 빠름</li></ul></li><li><p><strong>리소스 사용</strong></p><ul><li>System V Init: 경량화</li><li>Systemd: 추가 기능으로 인한 더 많은 리소스 사용</li></ul></li></ol><h2 id=운영자개발자-고려사항>운영자/개발자 고려사항<a hidden class=anchor aria-hidden=true href=#운영자개발자-고려사항>#</a></h2><h3 id=구성-관리의-변화>구성 관리의 변화<a hidden class=anchor aria-hidden=true href=#구성-관리의-변화>#</a></h3><ul><li>Systemd의 Unit 파일은 서비스 관리 및 설정이 체계적이므로 학습 및 사용법 숙지가 필요합니다.</li><li>Systemd는 타겟 기반 관리와 의존성 트리 구조를 통해 복잡한 서비스를 안정적으로 관리할 수 있습니다.</li></ul><h3 id=부팅-및-서비스-관리의-효율성>부팅 및 서비스 관리의 효율성<a hidden class=anchor aria-hidden=true href=#부팅-및-서비스-관리의-효율성>#</a></h3><ul><li>부팅 시간 단축, 의존성 설정, 동시 실행 지원은 운영 및 시스템 초기화 효율성을 크게 개선시킵니다.</li><li>단일 명령으로 전체 서비스를 제어하거나 로그를 분석할 수 있어, journalctl 같은 Systemd의 추가 도구를 익히면 편리합니다.</li></ul><h3 id=장기적인-지원-및-호환성-문제>장기적인 지원 및 호환성 문제<a hidden class=anchor aria-hidden=true href=#장기적인-지원-및-호환성-문제>#</a></h3><ul><li>대부분의 리눅스 배포판이 Systemd를 기본 init 시스템으로 채택했지만, 일부 배포판에서는 여전히 System V Init 또는 대체 init 시스템을 사용하기도 합니다.</li><li>일부 레거시 스크립트와의 호환성 문제가 발생할 수 있으므로, Systemd와 호환되도록 스크립트를 수정해야 할 수도 있습니다.</li></ul><h3 id=시스템-관리>시스템 관리<a hidden class=anchor aria-hidden=true href=#시스템-관리>#</a></h3><ul><li><p><strong>서비스 설정</strong></p><ul><li>System V Init: <code>/etc/init.d/</code> 스크립트 수정</li><li>Systemd: Unit 파일 작성 및 관리</li></ul></li><li><p><strong>문제 해결</strong></p><ul><li>System V Init: <code>tail -f /var/log/messages</code></li><li>Systemd: <code>journalctl -xeu service-name</code></li></ul></li></ul><h3 id=마이그레이션-고려사항>마이그레이션 고려사항<a hidden class=anchor aria-hidden=true href=#마이그레이션-고려사항>#</a></h3><ul><li>기존 Init 스크립트의 Systemd Unit 변환</li><li>의존성 관계 재정의</li><li>로깅 시스템 변경 대응</li></ul><h2 id=docker-환경에서의-활용>Docker 환경에서의 활용<a hidden class=anchor aria-hidden=true href=#docker-환경에서의-활용>#</a></h2><p>Docker는 보통 단일 프로세스 실행을 목표로 설계되었기 때문에, init 시스템을 사용하는 대신 애플리케이션이 바로 실행됩니다. 하지만 컨테이너 내 여러 서비스 관리를 위해 <code>systemd</code>가 필요할 때 추가적인 설정을 통해 사용할 수 있습니다.</p><h3 id=1-docker에서-system-v-init-방식-사용>1. Docker에서 System V Init 방식 사용<a hidden class=anchor aria-hidden=true href=#1-docker에서-system-v-init-방식-사용>#</a></h3><p>일반적인 Docker 컨테이너는 단일 프로세스 원칙에 따라 동작합니다. System V Init 방식으로 단일 프로세스만 실행하는 예제를 보겠습니다.</p><h4 id=예제-system-v-init-방식으로-nginx-실행>예제: System V Init 방식으로 Nginx 실행<a hidden class=anchor aria-hidden=true href=#예제-system-v-init-방식으로-nginx-실행>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#ff79c6>FROM</span> <span style=color:#f1fa8c>nginx:alpine</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>CMD</span> [<span style=color:#f1fa8c>&#34;nginx&#34;</span>, <span style=color:#f1fa8c>&#34;-g&#34;</span>, <span style=color:#f1fa8c>&#34;daemon off;&#34;</span>]
</span></span></code></pre></div><h3 id=2-docker에서-systemd-사용-설정>2. Docker에서 Systemd 사용 설정<a hidden class=anchor aria-hidden=true href=#2-docker에서-systemd-사용-설정>#</a></h3><p>Docker 컨테이너에서 Systemd를 사용하려면, cgroup 설정과 권한을 조정해야 합니다.</p><h4 id=예제-systemd-사용하여-다중-서비스-실행>예제: Systemd 사용하여 다중 서비스 실행<a hidden class=anchor aria-hidden=true href=#예제-systemd-사용하여-다중-서비스-실행>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#ff79c6>FROM</span> <span style=color:#f1fa8c>ubuntu:20.04</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>RUN</span> apt-get update <span style=color:#ff79c6>&amp;&amp;</span> apt-get install -y systemd
</span></span><span style=display:flex><span><span style=color:#ff79c6>VOLUME</span> [ <span style=color:#f1fa8c>&#34;/sys/fs/cgroup&#34;</span> ]
</span></span><span style=display:flex><span><span style=color:#ff79c6>CMD</span> [<span style=color:#f1fa8c>&#34;/lib/systemd/systemd&#34;</span>]
</span></span></code></pre></div><p>실행 방법:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker build -t myapp_systemd .
</span></span><span style=display:flex><span>docker run --privileged -v /sys/fs/cgroup:/sys/fs/cgroup:ro -d myapp_systemd
</span></span></code></pre></div><h3 id=3-권장-사항>3. 권장 사항<a hidden class=anchor aria-hidden=true href=#3-권장-사항>#</a></h3><ol><li><strong>컨테이너는 단일 프로세스 원칙을 준수</strong>: 여러 서비스를 실행할 경우 별도의 컨테이너를 사용하는 것이 좋습니다.</li><li><strong>경량화된 init 시스템 사용</strong>: 여러 프로세스를 관리할 필요가 있다면 <code>Tini</code>와 같은 경량화된 init 시스템을 사용하는 것이 좋습니다.</li><li><strong>필요한 경우에만 systemd 도입</strong>: 가능한 한 가벼운 구성을 유지하는 것이 컨테이너 환경에 유리합니다.</li></ol><h2 id=주요-리눅스-배포판의-systemd-도입-현황>주요 리눅스 배포판의 Systemd 도입 현황<a hidden class=anchor aria-hidden=true href=#주요-리눅스-배포판의-systemd-도입-현황>#</a></h2><ol><li><strong>CentOS</strong>: CentOS 7부터 systemd 기본 도입</li><li><strong>Ubuntu</strong>: Ubuntu 15.04부터 systemd 기본 도입</li><li><strong>Red Hat Enterprise Linux (RHEL)</strong>: RHEL 7부터 systemd 기본 도입</li><li><strong>Fedora</strong>: Fedora 15부터 systemd 기본 도입</li><li><strong>Debian</strong>: Debian 8 (Jessie)부터 systemd 기본 도입</li><li><strong>openSUSE 및 SUSE Linux Enterprise (SLE)</strong>: openSUSE 12.1부터 systemd 도입</li></ol><h2 id=결론>결론<a hidden class=anchor aria-hidden=true href=#결론>#</a></h2><p>Systemd는 현대 리눅스 시스템의 요구사항을 잘 반영한 init 시스템으로, 대부분의 주요 배포판에서 채택하고 있습니다. 하지만 컨테이너와 같은 특수한 환경에서는 상황에 맞는 적절한 초기화 방식을 선택하는 것이 중요합니다. 시스템 관리자와 개발자는 각 환경에 맞는 init 시스템의 특징을 이해하고, 이를 효과적으로 활용할 수 있어야 합니다.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://cdecl.github.io/tags/linux/>Linux</a></li><li><a href=https://cdecl.github.io/tags/systemd/>Systemd</a></li><li><a href=https://cdecl.github.io/tags/system-v-init/>System v Init</a></li><li><a href=https://cdecl.github.io/tags/docker/>Docker</a></li><li><a href=https://cdecl.github.io/tags/init-system/>Init System</a></li><li><a href=https://cdecl.github.io/tags/ubuntu/>Ubuntu</a></li><li><a href=https://cdecl.github.io/tags/centos/>Centos</a></li><li><a href=https://cdecl.github.io/tags/service-management/>Service Management</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://cdecl.github.io/>cdeclog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>