<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>SSH 리버스 프록시(Reverse Proxy) 네트워크 구성: 설정, 주의 사항, 운영 팁 | cdeclog</title><meta name=keywords content="devops,ssh,reverse-proxy,networking,tunneling,security,bastion,firewall"><meta name=description content="작성일: 2026-02-08
SSH 리버스 프록시는 외부에서 내부로 직접 접근할 수 없는 환경에서 유용한 연결 방식입니다. 내부 서버가 외부 서버로 역방향 터널을 먼저 열어두고, 외부 사용자가 그 터널을 통해 내부 서비스에 접근하는 구조입니다. DevOps 환경에서 운영할 때 필요한 구성, 주의 사항, 네트워크 프록시 관점을 정리합니다.

1. 개념 정리: SSH 리버스 프록시

일반 SSH 포워딩(로컬 포워딩): 로컬 -> 원격
리버스 포워딩(Reverse): 원격 -> 로컬(내부)

리버스 포워딩은 내부 서버가 먼저 외부(중계) 서버에 접속하고, 외부에서 그 연결을 통해 내부 서비스에 접근하는 방식입니다."><meta name=author content="Byung Kyu KIM"><link rel=canonical href=https://cdecl.github.io/devops/ssh-reverse-proxy-guide/><link crossorigin=anonymous href=/assets/css/stylesheet.f939c4ffefb264e6fe85e04352266f79db6bb1303c8e16ae9b6064c1247b5e32.css integrity="sha256-+TnE/++yZOb+heBDUiZvedtrsTA8jhaum2BkwSR7XjI=" rel="preload stylesheet" as=style><link rel=icon href=https://cdecl.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://cdecl.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://cdecl.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://cdecl.github.io/apple-touch-icon.png><link rel=mask-icon href=https://cdecl.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://cdecl.github.io/devops/ssh-reverse-proxy-guide/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-VQQHHYPN7K"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VQQHHYPN7K")}</script><meta property="og:url" content="https://cdecl.github.io/devops/ssh-reverse-proxy-guide/"><meta property="og:site_name" content="cdeclog"><meta property="og:title" content="SSH 리버스 프록시(Reverse Proxy) 네트워크 구성: 설정, 주의 사항, 운영 팁"><meta property="og:description" content="작성일: 2026-02-08
SSH 리버스 프록시는 외부에서 내부로 직접 접근할 수 없는 환경에서 유용한 연결 방식입니다. 내부 서버가 외부 서버로 역방향 터널을 먼저 열어두고, 외부 사용자가 그 터널을 통해 내부 서비스에 접근하는 구조입니다. DevOps 환경에서 운영할 때 필요한 구성, 주의 사항, 네트워크 프록시 관점을 정리합니다.
1. 개념 정리: SSH 리버스 프록시 일반 SSH 포워딩(로컬 포워딩): 로컬 -> 원격 리버스 포워딩(Reverse): 원격 -> 로컬(내부) 리버스 포워딩은 내부 서버가 먼저 외부(중계) 서버에 접속하고, 외부에서 그 연결을 통해 내부 서비스에 접근하는 방식입니다."><meta property="og:locale" content="ko-kr"><meta property="og:type" content="article"><meta property="article:section" content="devops"><meta property="article:published_time" content="2026-02-08T00:00:00+09:00"><meta property="article:modified_time" content="2026-02-08T00:00:00+09:00"><meta property="article:tag" content="Devops"><meta property="article:tag" content="Ssh"><meta property="article:tag" content="Reverse Proxy"><meta property="article:tag" content="Networking"><meta property="article:tag" content="Tunneling"><meta property="article:tag" content="Security"><meta name=twitter:card content="summary"><meta name=twitter:title content="SSH 리버스 프록시(Reverse Proxy) 네트워크 구성: 설정, 주의 사항, 운영 팁"><meta name=twitter:description content="작성일: 2026-02-08
SSH 리버스 프록시는 외부에서 내부로 직접 접근할 수 없는 환경에서 유용한 연결 방식입니다. 내부 서버가 외부 서버로 역방향 터널을 먼저 열어두고, 외부 사용자가 그 터널을 통해 내부 서비스에 접근하는 구조입니다. DevOps 환경에서 운영할 때 필요한 구성, 주의 사항, 네트워크 프록시 관점을 정리합니다.

1. 개념 정리: SSH 리버스 프록시

일반 SSH 포워딩(로컬 포워딩): 로컬 -> 원격
리버스 포워딩(Reverse): 원격 -> 로컬(내부)

리버스 포워딩은 내부 서버가 먼저 외부(중계) 서버에 접속하고, 외부에서 그 연결을 통해 내부 서비스에 접근하는 방식입니다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Devops","item":"https://cdecl.github.io/devops/"},{"@type":"ListItem","position":2,"name":"SSH 리버스 프록시(Reverse Proxy) 네트워크 구성: 설정, 주의 사항, 운영 팁","item":"https://cdecl.github.io/devops/ssh-reverse-proxy-guide/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"SSH 리버스 프록시(Reverse Proxy) 네트워크 구성: 설정, 주의 사항, 운영 팁","name":"SSH 리버스 프록시(Reverse Proxy) 네트워크 구성: 설정, 주의 사항, 운영 팁","description":"작성일: 2026-02-08\nSSH 리버스 프록시는 외부에서 내부로 직접 접근할 수 없는 환경에서 유용한 연결 방식입니다. 내부 서버가 외부 서버로 역방향 터널을 먼저 열어두고, 외부 사용자가 그 터널을 통해 내부 서비스에 접근하는 구조입니다. DevOps 환경에서 운영할 때 필요한 구성, 주의 사항, 네트워크 프록시 관점을 정리합니다.\n1. 개념 정리: SSH 리버스 프록시 일반 SSH 포워딩(로컬 포워딩): 로컬 -\u0026gt; 원격 리버스 포워딩(Reverse): 원격 -\u0026gt; 로컬(내부) 리버스 포워딩은 내부 서버가 먼저 외부(중계) 서버에 접속하고, 외부에서 그 연결을 통해 내부 서비스에 접근하는 방식입니다.\n","keywords":["devops","ssh","reverse-proxy","networking","tunneling","security","bastion","firewall"],"articleBody":"작성일: 2026-02-08\nSSH 리버스 프록시는 외부에서 내부로 직접 접근할 수 없는 환경에서 유용한 연결 방식입니다. 내부 서버가 외부 서버로 역방향 터널을 먼저 열어두고, 외부 사용자가 그 터널을 통해 내부 서비스에 접근하는 구조입니다. DevOps 환경에서 운영할 때 필요한 구성, 주의 사항, 네트워크 프록시 관점을 정리합니다.\n1. 개념 정리: SSH 리버스 프록시 일반 SSH 포워딩(로컬 포워딩): 로컬 -\u003e 원격 리버스 포워딩(Reverse): 원격 -\u003e 로컬(내부) 리버스 포워딩은 내부 서버가 먼저 외부(중계) 서버에 접속하고, 외부에서 그 연결을 통해 내부 서비스에 접근하는 방식입니다.\n2. 기본 네트워크 구성 구성 예시 내부 서버: internal01 (NAT 뒤, 외부 직접 접근 불가) 외부 중계 서버: bastion (공인 IP 보유) 접속자: operator operator -\u003e bastion:2222 -\u003e internal01:22 구성 예시 (다양한 패턴) 내부 SSH 접근만 필요할 때 operator -\u003e bastion:2222 -\u003e internal01:22 # internal01에서 bastion으로 터널 생성 ssh -N -R 2222:localhost:22 user@bastion 내부 웹 서비스(HTTP/HTTPS) 노출 operator -\u003e bastion:8080 -\u003e internal01:80 operator -\u003e bastion:8443 -\u003e internal01:443 # 내부 웹 포트 2개를 각각 리버스 포워딩 ssh -N -R 8080:localhost:80 -R 8443:localhost:443 user@bastion 여러 내부 서버를 한 bastion으로 수집 operator -\u003e bastion:2222 -\u003e internal01:22 operator -\u003e bastion:2223 -\u003e internal02:22 operator -\u003e bastion:2224 -\u003e internal03:22 # 각 내부 서버에서 서로 다른 포트로 터널 생성 ssh -N -R 2222:localhost:22 user@bastion # internal01 ssh -N -R 2223:localhost:22 user@bastion # internal02 ssh -N -R 2224:localhost:22 user@bastion # internal03 내부 특정 서비스만 제한적으로 공개 operator -\u003e bastion:9300 -\u003e internal01:9300 # 내부 서비스 포트만 외부에 노출 ssh -N -R 9300:localhost:9300 user@bastion bastion 내부에서만 접근 가능한 로컬 바인딩 bastion:127.0.0.1:2222 -\u003e internal01:22 # bastion 로컬에만 바인딩(기본 동작) ssh -N -R 2222:localhost:22 user@bastion 점프 호스트 체인 (내부에서 다시 내부로) operator -\u003e bastion -\u003e internal01:22 -\u003e internal-db:5432 # internal01에서 DB로 로컬 포워딩을 만들고 ssh -N -L 15432:internal-db:5432 internal01 # internal01의 로컬 포트를 bastion으로 리버스 포워딩 ssh -N -R 15432:localhost:15432 user@bastion 내부 서버에서 터널 생성 ssh -N -R 2222:localhost:22 user@bastion -R 2222:localhost:22 bastion의 2222 포트를 내부 서버의 22번으로 연결 -N 쉘 없이 터널만 유지 외부 접속자 입장 ssh -p 2222 internal_user@bastion 이렇게 하면 bastion의 2222 포트가 내부 서버의 22로 연결됩니다.\n3. 실무 설정 포인트 3.1 sshd_config에서 리버스 포워딩 허용 bastion 서버의 /etc/ssh/sshd_config에 다음 설정이 필요할 수 있습니다.\nAllowTcpForwarding yes GatewayPorts no AllowTcpForwarding yes: 포워딩 허용 GatewayPorts no: 기본적으로 127.0.0.1에만 바인딩 위 항목은 기본값이지만 보통 주석 처리되어 있습니다. 즉, 명시적으로 설정하지 않아도 기본 동작은 유지되지만, 운영 환경에서는 의도를 분명히 하기 위해 주석을 해제해 명시적으로 선언하는 경우가 많습니다. 외부 클라이언트가 bastion의 퍼블릭 IP로 접속할 수 있어야 한다면:\nGatewayPorts yes 단, 보안 리스크가 커지므로 접근 제어가 반드시 필요합니다.\n3.2 시스템 서비스로 터널 유지 운영에서는 autossh 또는 systemd를 이용해 터널을 지속적으로 유지합니다.\nautossh -M 0 -N -R 2222:localhost:22 user@bastion -M 0: 모니터링 포트 비활성화 (단순 keepalive) ServerAliveInterval, ServerAliveCountMax 옵션 권장 4. 주의 사항 (운영 리스크) 포트 충돌\nbastion에 동일한 리버스 포워딩 포트가 여러 개 잡히면 충돌 보안 범위 확장\nGatewayPorts yes는 외부 전체에 포트를 노출 반드시 방화벽/ACL/IP 제한 필요 인증 강화 필요\n비밀번호 인증 비활성화 키 기반 인증 + 제한된 계정 사용 로그 추적성\nbastion 로그와 내부 서버 로그를 함께 보관해야 실제 접속 추적 가능 5. 네트워크 프록시 관점 정리 SSH 리버스 포워딩은 L4 TCP 터널입니다.\nHTTP 프록시처럼 헤더를 이해하거나 수정하지 않음 SSL/TLS 종료 지점이 SSH 터널 밖에 있음 따라서 L7 로깅/보안 검사는 별도 구성 필요 터널 내부의 TCP 핸드셰이크(SYN, SYN-ACK, ACK)는 SSH 세션 내부에서 캡슐화되어 흐르므로, bastion은 패킷 내용을 해석하지 않고 바이트 스트림만 중계합니다. 필요 시:\nbastion에서 Nginx/HAProxy를 추가 배치해 L7 프록시 적용 SSH는 터널만 유지하고 실제 트래픽은 L7 레이어에서 관측 6. 운영 팁 터널 포트는 고정된 포트 정책으로 관리 (예: 팀/서버별 포트 범위 할당) ~/.ssh/config에 전용 Host 블록을 만들어 관리 무조건 localhost로 바인딩하고, 필요할 때만 GatewayPorts yes 헬스체크 스크립트를 통해 터널 유실 감지 후 자동 재연결 정리 SSH 리버스 프록시는 외부에서 직접 접근할 수 없는 내부 환경을 열어주는 강력한 도구입니다. 하지만 잘못 구성하면 외부에 불필요한 포트가 노출되고, 보안 사고로 이어질 수 있습니다. DevOps 환경에서는 반드시 포워딩 범위, 인증 정책, 로그 관리까지 포함해 설계해야 합니다.\n","wordCount":"628","inLanguage":"en","datePublished":"2026-02-08T00:00:00+09:00","dateModified":"2026-02-08T00:00:00+09:00","author":{"@type":"Person","name":"Byung Kyu KIM"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://cdecl.github.io/devops/ssh-reverse-proxy-guide/"},"publisher":{"@type":"Organization","name":"cdeclog","logo":{"@type":"ImageObject","url":"https://cdecl.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://cdecl.github.io/ accesskey=h title="cdeclog (Alt + H)">cdeclog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://cdecl.github.io/dev/ title=Dev><span>Dev</span></a></li><li><a href=https://cdecl.github.io/devops/ title=DevOps><span>DevOps</span></a></li><li><a href=https://cdecl.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://cdecl.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://cdecl.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://cdecl.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://cdecl.github.io/devops/>Devops</a></div><h1 class="post-title entry-hint-parent">SSH 리버스 프록시(Reverse Proxy) 네트워크 구성: 설정, 주의 사항, 운영 팁</h1><div class=post-meta><span title='2026-02-08 00:00:00 +0900 KST'>February 8, 2026</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#1-%ea%b0%9c%eb%85%90-%ec%a0%95%eb%a6%ac-ssh-%eb%a6%ac%eb%b2%84%ec%8a%a4-%ed%94%84%eb%a1%9d%ec%8b%9c aria-label="1. 개념 정리: SSH 리버스 프록시">1. 개념 정리: SSH 리버스 프록시</a></li><li><a href=#2-%ea%b8%b0%eb%b3%b8-%eb%84%a4%ed%8a%b8%ec%9b%8c%ed%81%ac-%ea%b5%ac%ec%84%b1 aria-label="2. 기본 네트워크 구성">2. 기본 네트워크 구성</a><ul><li><a href=#%ea%b5%ac%ec%84%b1-%ec%98%88%ec%8b%9c aria-label="구성 예시">구성 예시</a></li><li><a href=#%ea%b5%ac%ec%84%b1-%ec%98%88%ec%8b%9c-%eb%8b%a4%ec%96%91%ed%95%9c-%ed%8c%a8%ed%84%b4 aria-label="구성 예시 (다양한 패턴)">구성 예시 (다양한 패턴)</a></li><li><a href=#%eb%82%b4%eb%b6%80-%ec%84%9c%eb%b2%84%ec%97%90%ec%84%9c-%ed%84%b0%eb%84%90-%ec%83%9d%ec%84%b1 aria-label="내부 서버에서 터널 생성">내부 서버에서 터널 생성</a></li><li><a href=#%ec%99%b8%eb%b6%80-%ec%a0%91%ec%86%8d%ec%9e%90-%ec%9e%85%ec%9e%a5 aria-label="외부 접속자 입장">외부 접속자 입장</a></li></ul></li><li><a href=#3-%ec%8b%a4%eb%ac%b4-%ec%84%a4%ec%a0%95-%ed%8f%ac%ec%9d%b8%ed%8a%b8 aria-label="3. 실무 설정 포인트">3. 실무 설정 포인트</a><ul><li><a href=#31-sshd_config%ec%97%90%ec%84%9c-%eb%a6%ac%eb%b2%84%ec%8a%a4-%ed%8f%ac%ec%9b%8c%eb%94%a9-%ed%97%88%ec%9a%a9 aria-label="3.1 sshd_config에서 리버스 포워딩 허용">3.1 sshd_config에서 리버스 포워딩 허용</a></li><li><a href=#32-%ec%8b%9c%ec%8a%a4%ed%85%9c-%ec%84%9c%eb%b9%84%ec%8a%a4%eb%a1%9c-%ed%84%b0%eb%84%90-%ec%9c%a0%ec%a7%80 aria-label="3.2 시스템 서비스로 터널 유지">3.2 시스템 서비스로 터널 유지</a></li></ul></li><li><a href=#4-%ec%a3%bc%ec%9d%98-%ec%82%ac%ed%95%ad-%ec%9a%b4%ec%98%81-%eb%a6%ac%ec%8a%a4%ed%81%ac aria-label="4. 주의 사항 (운영 리스크)">4. 주의 사항 (운영 리스크)</a></li><li><a href=#5-%eb%84%a4%ed%8a%b8%ec%9b%8c%ed%81%ac-%ed%94%84%eb%a1%9d%ec%8b%9c-%ea%b4%80%ec%a0%90-%ec%a0%95%eb%a6%ac aria-label="5. 네트워크 프록시 관점 정리">5. 네트워크 프록시 관점 정리</a></li><li><a href=#6-%ec%9a%b4%ec%98%81-%ed%8c%81 aria-label="6. 운영 팁">6. 운영 팁</a></li><li><a href=#%ec%a0%95%eb%a6%ac aria-label=정리>정리</a></li></ul></div></details></div><div class=post-content><p>작성일: 2026-02-08</p><p>SSH 리버스 프록시는 <strong>외부에서 내부로 직접 접근할 수 없는 환경</strong>에서 유용한 연결 방식입니다. 내부 서버가 외부 서버로 <strong>역방향 터널을 먼저 열어두고</strong>, 외부 사용자가 그 터널을 통해 내부 서비스에 접근하는 구조입니다. DevOps 환경에서 운영할 때 필요한 구성, 주의 사항, 네트워크 프록시 관점을 정리합니다.</p><hr><h2 id=1-개념-정리-ssh-리버스-프록시>1. 개념 정리: SSH 리버스 프록시<a hidden class=anchor aria-hidden=true href=#1-개념-정리-ssh-리버스-프록시>#</a></h2><ul><li>일반 SSH 포워딩(로컬 포워딩): <strong>로컬 -> 원격</strong></li><li>리버스 포워딩(Reverse): <strong>원격 -> 로컬(내부)</strong></li></ul><p>리버스 포워딩은 내부 서버가 먼저 외부(중계) 서버에 접속하고, 외부에서 그 연결을 통해 내부 서비스에 접근하는 방식입니다.</p><hr><h2 id=2-기본-네트워크-구성>2. 기본 네트워크 구성<a hidden class=anchor aria-hidden=true href=#2-기본-네트워크-구성>#</a></h2><h3 id=구성-예시>구성 예시<a hidden class=anchor aria-hidden=true href=#구성-예시>#</a></h3><ul><li>내부 서버: <code>internal01</code> (NAT 뒤, 외부 직접 접근 불가)</li><li>외부 중계 서버: <code>bastion</code> (공인 IP 보유)</li><li>접속자: <code>operator</code></li></ul><pre tabindex=0><code>operator -&gt; bastion:2222 -&gt; internal01:22
</code></pre><h3 id=구성-예시-다양한-패턴>구성 예시 (다양한 패턴)<a hidden class=anchor aria-hidden=true href=#구성-예시-다양한-패턴>#</a></h3><ol><li>내부 SSH 접근만 필요할 때</li></ol><pre tabindex=0><code>operator -&gt; bastion:2222 -&gt; internal01:22
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#6272a4># internal01에서 bastion으로 터널 생성</span>
</span></span><span style=display:flex><span>ssh -N -R 2222:localhost:22 user@bastion
</span></span></code></pre></div><ol start=2><li>내부 웹 서비스(HTTP/HTTPS) 노출</li></ol><pre tabindex=0><code>operator -&gt; bastion:8080 -&gt; internal01:80
operator -&gt; bastion:8443 -&gt; internal01:443
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#6272a4># 내부 웹 포트 2개를 각각 리버스 포워딩</span>
</span></span><span style=display:flex><span>ssh -N -R 8080:localhost:80 -R 8443:localhost:443 user@bastion
</span></span></code></pre></div><ol start=3><li>여러 내부 서버를 한 bastion으로 수집</li></ol><pre tabindex=0><code>operator -&gt; bastion:2222 -&gt; internal01:22
operator -&gt; bastion:2223 -&gt; internal02:22
operator -&gt; bastion:2224 -&gt; internal03:22
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#6272a4># 각 내부 서버에서 서로 다른 포트로 터널 생성</span>
</span></span><span style=display:flex><span>ssh -N -R 2222:localhost:22 user@bastion   <span style=color:#6272a4># internal01</span>
</span></span><span style=display:flex><span>ssh -N -R 2223:localhost:22 user@bastion   <span style=color:#6272a4># internal02</span>
</span></span><span style=display:flex><span>ssh -N -R 2224:localhost:22 user@bastion   <span style=color:#6272a4># internal03</span>
</span></span></code></pre></div><ol start=4><li>내부 특정 서비스만 제한적으로 공개</li></ol><pre tabindex=0><code>operator -&gt; bastion:9300 -&gt; internal01:9300
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#6272a4># 내부 서비스 포트만 외부에 노출</span>
</span></span><span style=display:flex><span>ssh -N -R 9300:localhost:9300 user@bastion
</span></span></code></pre></div><ol start=5><li>bastion 내부에서만 접근 가능한 로컬 바인딩</li></ol><pre tabindex=0><code>bastion:127.0.0.1:2222 -&gt; internal01:22
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#6272a4># bastion 로컬에만 바인딩(기본 동작)</span>
</span></span><span style=display:flex><span>ssh -N -R 2222:localhost:22 user@bastion
</span></span></code></pre></div><ol start=6><li>점프 호스트 체인 (내부에서 다시 내부로)</li></ol><pre tabindex=0><code>operator -&gt; bastion -&gt; internal01:22 -&gt; internal-db:5432
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#6272a4># internal01에서 DB로 로컬 포워딩을 만들고</span>
</span></span><span style=display:flex><span>ssh -N -L 15432:internal-db:5432 internal01
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4># internal01의 로컬 포트를 bastion으로 리버스 포워딩</span>
</span></span><span style=display:flex><span>ssh -N -R 15432:localhost:15432 user@bastion
</span></span></code></pre></div><h3 id=내부-서버에서-터널-생성>내부 서버에서 터널 생성<a hidden class=anchor aria-hidden=true href=#내부-서버에서-터널-생성>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>ssh -N -R 2222:localhost:22 user@bastion
</span></span></code></pre></div><ul><li><code>-R 2222:localhost:22</code><ul><li>bastion의 2222 포트를 내부 서버의 22번으로 연결</li></ul></li><li><code>-N</code><ul><li>쉘 없이 터널만 유지</li></ul></li></ul><h3 id=외부-접속자-입장>외부 접속자 입장<a hidden class=anchor aria-hidden=true href=#외부-접속자-입장>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>ssh -p <span style=color:#bd93f9>2222</span> internal_user@bastion
</span></span></code></pre></div><p>이렇게 하면 bastion의 2222 포트가 내부 서버의 22로 연결됩니다.</p><hr><h2 id=3-실무-설정-포인트>3. 실무 설정 포인트<a hidden class=anchor aria-hidden=true href=#3-실무-설정-포인트>#</a></h2><h3 id=31-sshd_config에서-리버스-포워딩-허용>3.1 <code>sshd_config</code>에서 리버스 포워딩 허용<a hidden class=anchor aria-hidden=true href=#31-sshd_config에서-리버스-포워딩-허용>#</a></h3><p>bastion 서버의 <code>/etc/ssh/sshd_config</code>에 다음 설정이 필요할 수 있습니다.</p><pre tabindex=0><code>AllowTcpForwarding yes
GatewayPorts no
</code></pre><ul><li><code>AllowTcpForwarding yes</code>: 포워딩 허용</li><li><code>GatewayPorts no</code>: 기본적으로 127.0.0.1에만 바인딩</li><li>위 항목은 <strong>기본값이지만 보통 주석 처리</strong>되어 있습니다. 즉, 명시적으로 설정하지 않아도 기본 동작은 유지되지만, 운영 환경에서는 의도를 분명히 하기 위해 주석을 해제해 <strong>명시적으로 선언</strong>하는 경우가 많습니다.</li></ul><p>외부 클라이언트가 bastion의 퍼블릭 IP로 접속할 수 있어야 한다면:</p><pre tabindex=0><code>GatewayPorts yes
</code></pre><p>단, 보안 리스크가 커지므로 접근 제어가 반드시 필요합니다.</p><hr><h3 id=32-시스템-서비스로-터널-유지>3.2 시스템 서비스로 터널 유지<a hidden class=anchor aria-hidden=true href=#32-시스템-서비스로-터널-유지>#</a></h3><p>운영에서는 <code>autossh</code> 또는 systemd를 이용해 터널을 지속적으로 유지합니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>autossh -M <span style=color:#bd93f9>0</span> -N -R 2222:localhost:22 user@bastion
</span></span></code></pre></div><ul><li><code>-M 0</code>: 모니터링 포트 비활성화 (단순 keepalive)</li><li><code>ServerAliveInterval</code>, <code>ServerAliveCountMax</code> 옵션 권장</li></ul><hr><h2 id=4-주의-사항-운영-리스크>4. 주의 사항 (운영 리스크)<a hidden class=anchor aria-hidden=true href=#4-주의-사항-운영-리스크>#</a></h2><ol><li><p><strong>포트 충돌</strong></p><ul><li>bastion에 동일한 리버스 포워딩 포트가 여러 개 잡히면 충돌</li></ul></li><li><p><strong>보안 범위 확장</strong></p><ul><li><code>GatewayPorts yes</code>는 외부 전체에 포트를 노출</li><li>반드시 방화벽/ACL/IP 제한 필요</li></ul></li><li><p><strong>인증 강화 필요</strong></p><ul><li>비밀번호 인증 비활성화</li><li>키 기반 인증 + 제한된 계정 사용</li></ul></li><li><p><strong>로그 추적성</strong></p><ul><li>bastion 로그와 내부 서버 로그를 함께 보관해야 실제 접속 추적 가능</li></ul></li></ol><hr><h2 id=5-네트워크-프록시-관점-정리>5. 네트워크 프록시 관점 정리<a hidden class=anchor aria-hidden=true href=#5-네트워크-프록시-관점-정리>#</a></h2><p>SSH 리버스 포워딩은 <strong>L4 TCP 터널</strong>입니다.</p><ul><li>HTTP 프록시처럼 헤더를 이해하거나 수정하지 않음</li><li>SSL/TLS 종료 지점이 SSH 터널 밖에 있음</li><li>따라서 <strong>L7 로깅/보안 검사</strong>는 별도 구성 필요</li><li>터널 내부의 TCP 핸드셰이크(SYN, SYN-ACK, ACK)는 <strong>SSH 세션 내부에서 캡슐화</strong>되어 흐르므로, bastion은 패킷 내용을 해석하지 않고 <strong>바이트 스트림만 중계</strong>합니다.</li></ul><p>필요 시:</p><ul><li>bastion에서 Nginx/HAProxy를 추가 배치해 L7 프록시 적용</li><li>SSH는 터널만 유지하고 실제 트래픽은 L7 레이어에서 관측</li></ul><hr><h2 id=6-운영-팁>6. 운영 팁<a hidden class=anchor aria-hidden=true href=#6-운영-팁>#</a></h2><ul><li>터널 포트는 <strong>고정된 포트 정책</strong>으로 관리 (예: 팀/서버별 포트 범위 할당)</li><li><code>~/.ssh/config</code>에 전용 Host 블록을 만들어 관리</li><li>무조건 <code>localhost</code>로 바인딩하고, 필요할 때만 <code>GatewayPorts yes</code></li><li>헬스체크 스크립트를 통해 터널 유실 감지 후 자동 재연결</li></ul><hr><h2 id=정리>정리<a hidden class=anchor aria-hidden=true href=#정리>#</a></h2><p>SSH 리버스 프록시는 <strong>외부에서 직접 접근할 수 없는 내부 환경을 열어주는 강력한 도구</strong>입니다. 하지만 잘못 구성하면 <strong>외부에 불필요한 포트가 노출</strong>되고, 보안 사고로 이어질 수 있습니다. DevOps 환경에서는 반드시 포워딩 범위, 인증 정책, 로그 관리까지 포함해 설계해야 합니다.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://cdecl.github.io/tags/devops/>Devops</a></li><li><a href=https://cdecl.github.io/tags/ssh/>Ssh</a></li><li><a href=https://cdecl.github.io/tags/reverse-proxy/>Reverse Proxy</a></li><li><a href=https://cdecl.github.io/tags/networking/>Networking</a></li><li><a href=https://cdecl.github.io/tags/tunneling/>Tunneling</a></li><li><a href=https://cdecl.github.io/tags/security/>Security</a></li><li><a href=https://cdecl.github.io/tags/bastion/>Bastion</a></li><li><a href=https://cdecl.github.io/tags/firewall/>Firewall</a></li></ul></footer><script src=https://giscus.app/client.js data-repo=cdecl/cdecl.github.io data-repo-id="MDEwOlJlcG9zaXRvcnkzNDk1ODUyNjg=" data-category=General data-category-id=DIC_kwDOFNY_dM4C1XMk data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=transparent_dark data-lang=ko crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2026 <a href=https://cdecl.github.io/>cdeclog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>