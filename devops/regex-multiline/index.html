<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>정규식의 멀티라인 expressions 활용 | cdeclog</title><meta name=keywords content="regex,regular-expression,multiline,programming,text-processing"><meta name=description content="멀티라인 표현식의 활용법, Dotall (Single Line) 모드, Multi Line 모드, Non-Dotall 모드의 차이점, 여러 줄을 처리하는 방법
정규식의 멀티라인 표현식이란?
정규식(Regular Expression, Regex)은 텍스트 패턴을 검색하거나 조작할 때 강력한 도구로 사용됩니다. 특히 멀티라인 표현식은 여러 줄에 걸친 텍스트를 처리할 때 유용하며, 줄바꿈(\n)을 포함한 패턴 매칭을 가능하게 합니다. 이번 포스트에서는 멀티라인 표현식의 활용법, Dotall (Single Line) 모드, Multi Line 모드, Non-Dotall 모드의 차이점, 여러 줄을 처리하는 방법, 그리고 특정 패턴(예: start로 시작하고 end로 끝나는 패턴) 매칭 방법 등을 다룹니다. 또한, /s, /S, /w, /W, .|\n의 모드별 동작 차이를 설명합니다."><meta name=author content="Byung Kyu KIM"><link rel=canonical href=https://cdecl.github.io/devops/regex-multiline/><link crossorigin=anonymous href=/assets/css/stylesheet.94cdd6e6bf254a927ddb1a5b8ae2c24a30232449c016f55d87efd0d9bed87c55.css integrity="sha256-lM3W5r8lSpJ92xpbiuLCSjAjJEnAFvVdh+/Q2b7YfFU=" rel="preload stylesheet" as=style><link rel=icon href=https://cdecl.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://cdecl.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://cdecl.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://cdecl.github.io/apple-touch-icon.png><link rel=mask-icon href=https://cdecl.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://cdecl.github.io/devops/regex-multiline/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-VQQHHYPN7K"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VQQHHYPN7K")}</script><meta property="og:url" content="https://cdecl.github.io/devops/regex-multiline/"><meta property="og:site_name" content="cdeclog"><meta property="og:title" content="정규식의 멀티라인 expressions 활용"><meta property="og:description" content="멀티라인 표현식의 활용법, Dotall (Single Line) 모드, Multi Line 모드, Non-Dotall 모드의 차이점, 여러 줄을 처리하는 방법
정규식의 멀티라인 표현식이란? 정규식(Regular Expression, Regex)은 텍스트 패턴을 검색하거나 조작할 때 강력한 도구로 사용됩니다. 특히 멀티라인 표현식은 여러 줄에 걸친 텍스트를 처리할 때 유용하며, 줄바꿈(\n)을 포함한 패턴 매칭을 가능하게 합니다. 이번 포스트에서는 멀티라인 표현식의 활용법, Dotall (Single Line) 모드, Multi Line 모드, Non-Dotall 모드의 차이점, 여러 줄을 처리하는 방법, 그리고 특정 패턴(예: start로 시작하고 end로 끝나는 패턴) 매칭 방법 등을 다룹니다. 또한, /s, /S, /w, /W, .|\n의 모드별 동작 차이를 설명합니다."><meta property="og:locale" content="ko-kr"><meta property="og:type" content="article"><meta property="article:section" content="devops"><meta property="article:published_time" content="2025-07-01T00:00:00+09:00"><meta property="article:modified_time" content="2025-07-01T00:00:00+09:00"><meta property="article:tag" content="Regex"><meta property="article:tag" content="Regular Expression"><meta property="article:tag" content="Multiline"><meta property="article:tag" content="Programming"><meta property="article:tag" content="Text-Processing"><meta name=twitter:card content="summary"><meta name=twitter:title content="정규식의 멀티라인 expressions 활용"><meta name=twitter:description content="멀티라인 표현식의 활용법, Dotall (Single Line) 모드, Multi Line 모드, Non-Dotall 모드의 차이점, 여러 줄을 처리하는 방법
정규식의 멀티라인 표현식이란?
정규식(Regular Expression, Regex)은 텍스트 패턴을 검색하거나 조작할 때 강력한 도구로 사용됩니다. 특히 멀티라인 표현식은 여러 줄에 걸친 텍스트를 처리할 때 유용하며, 줄바꿈(\n)을 포함한 패턴 매칭을 가능하게 합니다. 이번 포스트에서는 멀티라인 표현식의 활용법, Dotall (Single Line) 모드, Multi Line 모드, Non-Dotall 모드의 차이점, 여러 줄을 처리하는 방법, 그리고 특정 패턴(예: start로 시작하고 end로 끝나는 패턴) 매칭 방법 등을 다룹니다. 또한, /s, /S, /w, /W, .|\n의 모드별 동작 차이를 설명합니다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Devops","item":"https://cdecl.github.io/devops/"},{"@type":"ListItem","position":2,"name":"정규식의 멀티라인 expressions 활용","item":"https://cdecl.github.io/devops/regex-multiline/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"정규식의 멀티라인 expressions 활용","name":"정규식의 멀티라인 expressions 활용","description":"멀티라인 표현식의 활용법, Dotall (Single Line) 모드, Multi Line 모드, Non-Dotall 모드의 차이점, 여러 줄을 처리하는 방법\n정규식의 멀티라인 표현식이란? 정규식(Regular Expression, Regex)은 텍스트 패턴을 검색하거나 조작할 때 강력한 도구로 사용됩니다. 특히 멀티라인 표현식은 여러 줄에 걸친 텍스트를 처리할 때 유용하며, 줄바꿈(\\n)을 포함한 패턴 매칭을 가능하게 합니다. 이번 포스트에서는 멀티라인 표현식의 활용법, Dotall (Single Line) 모드, Multi Line 모드, Non-Dotall 모드의 차이점, 여러 줄을 처리하는 방법, 그리고 특정 패턴(예: start로 시작하고 end로 끝나는 패턴) 매칭 방법 등을 다룹니다. 또한, /s, /S, /w, /W, .|\\n의 모드별 동작 차이를 설명합니다.\n","keywords":["regex","regular-expression","multiline","programming","text-processing"],"articleBody":"멀티라인 표현식의 활용법, Dotall (Single Line) 모드, Multi Line 모드, Non-Dotall 모드의 차이점, 여러 줄을 처리하는 방법\n정규식의 멀티라인 표현식이란? 정규식(Regular Expression, Regex)은 텍스트 패턴을 검색하거나 조작할 때 강력한 도구로 사용됩니다. 특히 멀티라인 표현식은 여러 줄에 걸친 텍스트를 처리할 때 유용하며, 줄바꿈(\\n)을 포함한 패턴 매칭을 가능하게 합니다. 이번 포스트에서는 멀티라인 표현식의 활용법, Dotall (Single Line) 모드, Multi Line 모드, Non-Dotall 모드의 차이점, 여러 줄을 처리하는 방법, 그리고 특정 패턴(예: start로 시작하고 end로 끝나는 패턴) 매칭 방법 등을 다룹니다. 또한, /s, /S, /w, /W, .|\\n의 모드별 동작 차이를 설명합니다.\nDotall, Multi Line, Non-Dotall 모드의 차이점 정규식에서 멀티라인 텍스트를 다룰 때, 세 가지 주요 모드가 사용됩니다: Dotall 모드, Multi Line 모드, 그리고 Non-Dotall 모드. 이들은 점(.)과 경계 문자(^, $)의 동작 방식에서 차이가 있습니다.\n1. Dotall (Single Line) 모드 설명: Dotall 모드는 점(.)이 줄바꿈 문자(\\n)를 포함한 모든 문자를 매칭하도록 합니다. 기본적으로 점(.)은 줄바꿈을 제외한 모든 단일 문자를 의미하지만, Dotall 모드에서는 줄바꿈까지 포함됩니다. 활성화 방법: Python에서는 re.DOTALL 플래그(또는 re.S)를, JavaScript에서는 /s 플래그를 사용합니다. 예시 (Python): import re text = \"Hello\\nWorld\" pattern = r\"Hello.*World\" # Dotall 모드 없이: 매칭 실패 print(re.search(pattern, text)) # None # Dotall 모드 활성화: 매칭 성공 print(re.search(pattern, text, re.DOTALL)) # 사용 사례: 여러 줄에 걸친 텍스트 블록(예: HTML, 로그 파일)을 한 번에 매칭할 때 유용합니다. 2. Multi Line 모드 설명: Multi Line 모드는 ^와 $가 각각 각 줄의 시작과 끝을 나타내도록 합니다. 기본적으로 ^는 문자열 전체의 시작, $는 문자열 전체의 끝을 의미하지만, Multi Line 모드에서는 각 줄에 대해 독립적으로 작동합니다. 활성화 방법: Python에서는 re.MULTILINE 플래그(또는 re.M)를, JavaScript에서는 /m 플래그를 사용합니다. 예시 (Python): import re text = \"start line1\\nstart line2\\nend line3\" pattern = r\"^start.*$\" # Multi Line 모드 없이: 첫 번째 줄만 매칭 시도 print(re.findall(pattern, text)) # [] # Multi Line 모드 활성화: 각 줄에서 패턴 매칭 print(re.findall(pattern, text, re.MULTILINE)) # ['start line1', 'start line2'] 사용 사례: 로그 파일에서 특정 패턴으로 시작하는 각 줄을 추출하거나, 여러 줄에 걸친 코드에서 특정 주석 패턴을 찾을 때 유용합니다. 3. Non-Dotall 모드 설명: Non-Dotall 모드는 기본 정규식 동작으로, 점(.)이 줄바꿈 문자(\\n)를 제외한 모든 단일 문자를 매칭합니다. 이 모드에서는 줄바꿈을 포함하려면 명시적으로 \\n을 패턴에 포함하거나 다른 방법을 사용해야 합니다. 특징: Dotall 모드가 활성화되지 않은 상태로, 점(.)은 한 줄 내에서만 작동하며, 멀티라인 텍스트를 처리하려면 줄바꿈을 별도로 처리해야 합니다. 예시 (Python): import re text = \"Hello\\nWorld\" pattern = r\"Hello.*World\" # Non-Dotall 모드: 매칭 실패 (줄바꿈 때문에) print(re.search(pattern, text)) # None # Non-Dotall에서 줄바꿈 명시적 처리 pattern = r\"Hello[\\s\\S]*World\" print(re.search(pattern, text)) # 사용 사례: 줄바꿈을 포함하지 않는 패턴을 엄격히 매칭하거나, 줄바꿈을 명시적으로 제어하고 싶을 때 사용됩니다. /s, /S, /w, /W, .|\\n의 모드별 차이점 정규식에서 특정 문자 클래스와 패턴은 모드에 따라 다르게 동작합니다. 아래는 주요 패턴의 동작을 비교합니다:\n패턴 설명 Dotall 모드 동작 Multi Line 모드 동작 Non-Dotall 모드 동작 /s 공백 문자(스페이스, 탭, 줄바꿈 등)를 매칭 줄바꿈(\\n) 포함 줄바꿈(\\n) 포함 줄바꿈(\\n) 포함 /S 공백 문자가 아닌 모든 문자를 매칭 줄바꿈(\\n) 포함 줄바꿈(\\n) 포함 줄바꿈(\\n) 포함 /w 단어 문자(알파벳, 숫자, 언더스코어: [a-zA-Z0-9_])를 매칭 모드에 무관 모드에 무관 모드에 무관 /W 단어 문자가 아닌 모든 문자를 매칭 모드에 무관 모드에 무관 모드에 무관 `. \\n` 점(.) 또는 줄바꿈(\\n)을 명시적으로 매칭 불필요 (.)가 이미 \\n 포함 줄바꿈(\\n) 명시적 매칭 필요 설명: /s와 /S는 공백 문자와 비공백 문자를 매칭하며, 모든 모드에서 줄바꿈(\\n)을 포함합니다. /w와 /W는 단어 문자와 비단어 문자를 매칭하며, 모드에 영향을 받지 않습니다. .|\\n은 Non-Dotall 모드에서 줄바꿈을 포함하려는 대안으로 사용되며, Dotall 모드에서는 불필요합니다. 예시 (Python, Non-Dotall에서 .|\\n 사용): import re text = \"Hello\\nWorld\" pattern = r\"Hello(.|\\n)*World\" match = re.search(pattern, text) print(match.group()) # Hello\\nWorld 차이점 요약 모드 점(.) 동작 ^와 $ 동작 플래그 (Python) 플래그 (JavaScript) Dotall (Single Line) 줄바꿈(\\n) 포함 모든 문자 매칭 문자열 전체의 시작/끝 re.DOTALL (re.S) /s Multi Line 줄바꿈(\\n) 제외 각 줄의 시작/끝 re.MULTILINE (re.M) /m Non-Dotall 줄바꿈(\\n) 제외 문자열 전체의 시작/끝 없음 없음 여러 줄을 표현하는 방법 멀티라인 텍스트를 처리할 때, 정규식에서 여러 줄을 표현하는 주요 방법은 다음과 같습니다:\nDotall 모드 활용:\n점(.)을 사용해 줄바꿈을 포함한 모든 텍스트 블록을 매칭. 예: .*로 여러 줄을 한 번에 캡처. Python 예시: import re text = \"Line 1\\nLine 2\\nLine 3\" pattern = r\".*\" matches = re.findall(pattern, text, re.DOTALL) print(matches) # ['Line 1\\nLine 2\\nLine 3'] 줄바꿈 문자(\\n) 명시적 사용:\n줄바꿈을 명시적으로 패턴에 포함(예: .*\\n.*). 예: 두 줄에 걸친 패턴 매칭. import re text = \"Line 1\\nLine 2\\nLine 3\" pattern = r\".*\\n.*\" matches = re.findall(pattern, text) print(matches) # ['Line 1\\nLine 2'] Multi Line 모드와 ^, $ 활용:\n각 줄을 개별적으로 처리. 예: 각 줄의 시작이 특정 단어로 시작하는 경우. import re text = \"apple\\nbanana\\ncherry\" pattern = r\"^\\w+\" matches = re.findall(pattern, text, re.MULTILINE) print(matches) # ['apple', 'banana', 'cherry'] Non-Dotall 모드에서 .|\\n 활용:\n점(.)이 줄바꿈을 포함하지 않으므로, .|\\n를 사용해 줄바꿈을 명시적으로 포함. 예: 여러 줄에 걸친 텍스트를 Non-Dotall 모드로 매칭. import re text = \"Line 1\\nLine 2\\nLine 3\" pattern = r\"Line(.|\\n)*3\" matches = re.findall(pattern, text) print(matches) # ['\\n'] start로 시작하고 end로 끝나는 멀티라인 패턴 특정 문자열(예: start로 시작하고 end로 끝나는 패턴)을 멀티라인에서 매칭하려면 Dotall 모드 또는 Non-Dotall 모드에서 [\\s\\S]를 활용합니다. 또한 특정 문자를 포함하거나 포함하지 않는 조건을 추가할 수 있습니다.\n1. 기본 패턴: start로 시작하고 end로 끝나는 텍스트 Dotall 모드 패턴: start.*?end (비탐욕적 매칭). Non-Dotall 모드 패턴: start[\\s\\S]*?end. 예시 (Python, Non-Dotall): import re text = \"start middle content\\nmore content\\nend other text\" pattern = r\"start[\\s\\S]*?end\" match = re.search(pattern, text) print(match.group()) # start middle content\\nmore content\\nend 2. 특정 문자 포함 요구사항: start와 end 사이에 특정 문자(예: keyword)를 포함하며, 여러 블록을 매칭. 패턴: Non-Dotall 모드에서는 start(?:(?!end)[\\s\\S])*?keyword[\\s\\S]*?end. 예시 (Python, Non-Dotall): import re text = \"\"\"start first block\\nkeyword here\\nend some text start second block\\nno keyword\\nend start third block\\nkeyword again\\nend\"\"\" pattern = r\"start(?:(?!end)[\\s\\S])*?keyword[\\s\\S]*?end\" matches = re.findall(pattern, text) for match in matches: print(match) 출력: start first block keyword here end start third block keyword again end 3. 특정 문자 포함하지 않음 요구사항: start와 end 사이에 특정 문자(예: forbidden)를 포함하지 않으며, 여러 블록을 매칭. 패턴: Non-Dotall 모드에서는 start(?:(?!end)[\\s\\S])*?(?![\\s\\S]*forbidden)[\\s\\S]*?end. 예시 (Python, Non-Dotall): import re text = \"\"\"start first block\\nkeyword here\\nend some text start second block\\nno keyword\\nend start third block\\nkeyword again\\nend start fourth block\\nforbidden content\\nend\"\"\" pattern = r\"start(?:(?!end)[\\s\\S])*?(?![\\s\\S]*forbidden)[\\s\\S]*?end\" matches = re.findall(pattern, text) for match in matches: print(match) 출력: start first block keyword here end start second block no keyword end start third block keyword again end 기타 활용 사례 정규식의 멀티라인 표현식은 다양한 시나리오에서 활용됩니다. 아래는 몇 가지 실용적인 예시입니다:\n로그 파일 분석:\n로그 파일에서 특정 에러 메시지가 포함된 블록을 추출. 예: ERROR(.|\\n)*?\\n로 에러 메시지와 관련된 블록을 Non-Dotall 모드로 추출. import re text = \"INFO: System started\\nERROR: Connection failed\\nDetails: Timeout\\nINFO: System running\" pattern = r\"ERROR(.|\\n)*?\\n\" matches = re.findall(pattern, text) print(matches) # ['\\n', '\\n'] 코드 주석 추출:\n여러 줄 주석(예: /* ... */)을 Non-Dotall 모드로 추출. 예 (JavaScript): const text = \"code\\n/* comment\\nmultiline */\\nmore code\"; const pattern = /\\/\\*(.|\\n)*?\\*\\//; const matches = text.match(pattern); console.log(matches[0]); // /* comment\\nmultiline */ HTML 태그 내용 추출:\n특정 태그(예: ...)의 내용을 멀티라인에서 추출. 예 (Python, Non-Dotall): import re text = \"\\n Content Line 1\\n Content Line 2\\n\" pattern = r\"(.|\\n)*?\" match = re.search(pattern, text) print(match.group()) # \\n Content Line 1\\n Content Line 2\\n 결론 정규식의 멀티라인 표현식은 텍스트 데이터를 다룰 때 강력한 도구입니다. Dotall 모드는 줄바꿈을 포함한 전체 텍스트 블록을 처리하는 데 유용하며, Multi Line 모드는 각 줄의 시작과 끝을 독립적으로 다룰 때 적합합니다. Non-Dotall 모드는 줄바꿈을 명시적으로 처리해야 하며, [\\s\\S]과 같은 패턴을 사용해 유연성을 제공합니다. /s, /S, /w, /W는 모드에 따라 일관된 동작을 보이며, .|\\n은 Non-Dotall 모드에서 줄바꿈을 포함하는 대안입니다. start와 end로 둘러싸인 패턴을 매칭하거나 특정 문자를 포함/제외하는 패턴을 활용하면 복잡한 텍스트 처리 작업을 효율적으로 수행할 수 있습니다.\n추가 리소스 Regular Expressions 101 - 정규식 테스트 및 디버깅 도구 Python re 모듈 문서 JavaScript RegExp MDN 문서 ","wordCount":"1226","inLanguage":"en","datePublished":"2025-07-01T00:00:00+09:00","dateModified":"2025-07-01T00:00:00+09:00","author":{"@type":"Person","name":"Byung Kyu KIM"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://cdecl.github.io/devops/regex-multiline/"},"publisher":{"@type":"Organization","name":"cdeclog","logo":{"@type":"ImageObject","url":"https://cdecl.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://cdecl.github.io/ accesskey=h title="cdeclog (Alt + H)">cdeclog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://cdecl.github.io/dev/ title=Dev><span>Dev</span></a></li><li><a href=https://cdecl.github.io/devops/ title=DevOps><span>DevOps</span></a></li><li><a href=https://cdecl.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://cdecl.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://cdecl.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">정규식의 멀티라인 expressions 활용</h1><div class=post-meta><span title='2025-07-01 00:00:00 +0900 KST'>July 1, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%ec%a0%95%ea%b7%9c%ec%8b%9d%ec%9d%98-%eb%a9%80%ed%8b%b0%eb%9d%bc%ec%9d%b8-%ed%91%9c%ed%98%84%ec%8b%9d%ec%9d%b4%eb%9e%80 aria-label="정규식의 멀티라인 표현식이란?">정규식의 멀티라인 표현식이란?</a></li><li><a href=#dotall-multi-line-non-dotall-%eb%aa%a8%eb%93%9c%ec%9d%98-%ec%b0%a8%ec%9d%b4%ec%a0%90 aria-label="Dotall, Multi Line, Non-Dotall 모드의 차이점">Dotall, Multi Line, Non-Dotall 모드의 차이점</a><ul><li><a href=#1-dotall-single-line-%eb%aa%a8%eb%93%9c aria-label="1. Dotall (Single Line) 모드">1. Dotall (Single Line) 모드</a></li><li><a href=#2-multi-line-%eb%aa%a8%eb%93%9c aria-label="2. Multi Line 모드">2. Multi Line 모드</a></li><li><a href=#3-non-dotall-%eb%aa%a8%eb%93%9c aria-label="3. Non-Dotall 모드">3. Non-Dotall 모드</a></li><li><a href=#s-s-w-w-n%ec%9d%98-%eb%aa%a8%eb%93%9c%eb%b3%84-%ec%b0%a8%ec%9d%b4%ec%a0%90 aria-label="/s, /S, /w, /W, .|\n의 모드별 차이점">/s, /S, /w, /W, .|\n의 모드별 차이점</a></li><li><a href=#%ec%b0%a8%ec%9d%b4%ec%a0%90-%ec%9a%94%ec%95%bd aria-label="차이점 요약">차이점 요약</a></li></ul></li><li><a href=#%ec%97%ac%eb%9f%ac-%ec%a4%84%ec%9d%84-%ed%91%9c%ed%98%84%ed%95%98%eb%8a%94-%eb%b0%a9%eb%b2%95 aria-label="여러 줄을 표현하는 방법">여러 줄을 표현하는 방법</a></li><li><a href=#start%eb%a1%9c-%ec%8b%9c%ec%9e%91%ed%95%98%ea%b3%a0-end%eb%a1%9c-%eb%81%9d%eb%82%98%eb%8a%94-%eb%a9%80%ed%8b%b0%eb%9d%bc%ec%9d%b8-%ed%8c%a8%ed%84%b4 aria-label="start로 시작하고 end로 끝나는 멀티라인 패턴">start로 시작하고 end로 끝나는 멀티라인 패턴</a><ul><li><a href=#1-%ea%b8%b0%eb%b3%b8-%ed%8c%a8%ed%84%b4-start%eb%a1%9c-%ec%8b%9c%ec%9e%91%ed%95%98%ea%b3%a0-end%eb%a1%9c-%eb%81%9d%eb%82%98%eb%8a%94-%ed%85%8d%ec%8a%a4%ed%8a%b8 aria-label="1. 기본 패턴: start로 시작하고 end로 끝나는 텍스트">1. 기본 패턴: start로 시작하고 end로 끝나는 텍스트</a></li><li><a href=#2-%ed%8a%b9%ec%a0%95-%eb%ac%b8%ec%9e%90-%ed%8f%ac%ed%95%a8 aria-label="2. 특정 문자 포함">2. 특정 문자 포함</a></li><li><a href=#3-%ed%8a%b9%ec%a0%95-%eb%ac%b8%ec%9e%90-%ed%8f%ac%ed%95%a8%ed%95%98%ec%a7%80-%ec%95%8a%ec%9d%8c aria-label="3. 특정 문자 포함하지 않음">3. 특정 문자 포함하지 않음</a></li></ul></li><li><a href=#%ea%b8%b0%ed%83%80-%ed%99%9c%ec%9a%a9-%ec%82%ac%eb%a1%80 aria-label="기타 활용 사례">기타 활용 사례</a></li><li><a href=#%ea%b2%b0%eb%a1%a0 aria-label=결론>결론</a></li><li><a href=#%ec%b6%94%ea%b0%80-%eb%a6%ac%ec%86%8c%ec%8a%a4 aria-label="추가 리소스">추가 리소스</a></li></ul></div></details></div><div class=post-content><p>멀티라인 표현식의 활용법, <strong>Dotall (Single Line) 모드</strong>, <strong>Multi Line 모드</strong>, <strong>Non-Dotall 모드</strong>의 차이점, 여러 줄을 처리하는 방법</p><h2 id=정규식의-멀티라인-표현식이란>정규식의 멀티라인 표현식이란?<a hidden class=anchor aria-hidden=true href=#정규식의-멀티라인-표현식이란>#</a></h2><p>정규식(Regular Expression, Regex)은 텍스트 패턴을 검색하거나 조작할 때 강력한 도구로 사용됩니다. 특히 <strong>멀티라인 표현식</strong>은 여러 줄에 걸친 텍스트를 처리할 때 유용하며, 줄바꿈(<code>\n</code>)을 포함한 패턴 매칭을 가능하게 합니다. 이번 포스트에서는 멀티라인 표현식의 활용법, <strong>Dotall (Single Line) 모드</strong>, <strong>Multi Line 모드</strong>, <strong>Non-Dotall 모드</strong>의 차이점, 여러 줄을 처리하는 방법, 그리고 특정 패턴(예: <code>start</code>로 시작하고 <code>end</code>로 끝나는 패턴) 매칭 방법 등을 다룹니다. 또한, <code>/s</code>, <code>/S</code>, <code>/w</code>, <code>/W</code>, <code>.|\n</code>의 모드별 동작 차이를 설명합니다.</p><h2 id=dotall-multi-line-non-dotall-모드의-차이점>Dotall, Multi Line, Non-Dotall 모드의 차이점<a hidden class=anchor aria-hidden=true href=#dotall-multi-line-non-dotall-모드의-차이점>#</a></h2><p>정규식에서 멀티라인 텍스트를 다룰 때, 세 가지 주요 모드가 사용됩니다: <strong>Dotall 모드</strong>, <strong>Multi Line 모드</strong>, 그리고 <strong>Non-Dotall 모드</strong>. 이들은 점(<code>.</code>)과 경계 문자(<code>^</code>, <code>$</code>)의 동작 방식에서 차이가 있습니다.</p><h3 id=1-dotall-single-line-모드>1. Dotall (Single Line) 모드<a hidden class=anchor aria-hidden=true href=#1-dotall-single-line-모드>#</a></h3><ul><li><strong>설명</strong>: Dotall 모드는 점(<code>.</code>)이 줄바꿈 문자(<code>\n</code>)를 포함한 모든 문자를 매칭하도록 합니다. 기본적으로 점(<code>.</code>)은 줄바꿈을 제외한 모든 단일 문자를 의미하지만, Dotall 모드에서는 줄바꿈까지 포함됩니다.</li><li><strong>활성화 방법</strong>: Python에서는 <code>re.DOTALL</code> 플래그(또는 <code>re.S</code>)를, JavaScript에서는 <code>/s</code> 플래그를 사용합니다.</li><li><strong>예시</strong> (Python):<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#ff79c6>import</span> re
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>text <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;Hello</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>World&#34;</span>
</span></span><span style=display:flex><span>pattern <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>r</span><span style=color:#f1fa8c>&#34;Hello.*World&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4># Dotall 모드 없이: 매칭 실패</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>print</span>(re<span style=color:#ff79c6>.</span>search(pattern, text))  <span style=color:#6272a4># None</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4># Dotall 모드 활성화: 매칭 성공</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>print</span>(re<span style=color:#ff79c6>.</span>search(pattern, text, re<span style=color:#ff79c6>.</span>DOTALL))  <span style=color:#6272a4># &lt;re.Match object; span=(0, 11), match=&#39;Hello\nWorld&#39;&gt;</span>
</span></span></code></pre></div></li><li><strong>사용 사례</strong>: 여러 줄에 걸친 텍스트 블록(예: HTML, 로그 파일)을 한 번에 매칭할 때 유용합니다.</li></ul><h3 id=2-multi-line-모드>2. Multi Line 모드<a hidden class=anchor aria-hidden=true href=#2-multi-line-모드>#</a></h3><ul><li><strong>설명</strong>: Multi Line 모드는 <code>^</code>와 <code>$</code>가 각각 각 줄의 시작과 끝을 나타내도록 합니다. 기본적으로 <code>^</code>는 문자열 전체의 시작, <code>$</code>는 문자열 전체의 끝을 의미하지만, Multi Line 모드에서는 각 줄에 대해 독립적으로 작동합니다.</li><li><strong>활성화 방법</strong>: Python에서는 <code>re.MULTILINE</code> 플래그(또는 <code>re.M</code>)를, JavaScript에서는 <code>/m</code> 플래그를 사용합니다.</li><li><strong>예시</strong> (Python):<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#ff79c6>import</span> re
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>text <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;start line1</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>start line2</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>end line3&#34;</span>
</span></span><span style=display:flex><span>pattern <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>r</span><span style=color:#f1fa8c>&#34;^start.*$&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4># Multi Line 모드 없이: 첫 번째 줄만 매칭 시도</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>print</span>(re<span style=color:#ff79c6>.</span>findall(pattern, text))  <span style=color:#6272a4># []</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4># Multi Line 모드 활성화: 각 줄에서 패턴 매칭</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>print</span>(re<span style=color:#ff79c6>.</span>findall(pattern, text, re<span style=color:#ff79c6>.</span>MULTILINE))  <span style=color:#6272a4># [&#39;start line1&#39;, &#39;start line2&#39;]</span>
</span></span></code></pre></div></li><li><strong>사용 사례</strong>: 로그 파일에서 특정 패턴으로 시작하는 각 줄을 추출하거나, 여러 줄에 걸친 코드에서 특정 주석 패턴을 찾을 때 유용합니다.</li></ul><h3 id=3-non-dotall-모드>3. Non-Dotall 모드<a hidden class=anchor aria-hidden=true href=#3-non-dotall-모드>#</a></h3><ul><li><strong>설명</strong>: Non-Dotall 모드는 기본 정규식 동작으로, 점(<code>.</code>)이 줄바꿈 문자(<code>\n</code>)를 제외한 모든 단일 문자를 매칭합니다. 이 모드에서는 줄바꿈을 포함하려면 명시적으로 <code>\n</code>을 패턴에 포함하거나 다른 방법을 사용해야 합니다.</li><li><strong>특징</strong>: Dotall 모드가 활성화되지 않은 상태로, 점(<code>.</code>)은 한 줄 내에서만 작동하며, 멀티라인 텍스트를 처리하려면 줄바꿈을 별도로 처리해야 합니다.</li><li><strong>예시</strong> (Python):<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#ff79c6>import</span> re
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>text <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;Hello</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>World&#34;</span>
</span></span><span style=display:flex><span>pattern <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>r</span><span style=color:#f1fa8c>&#34;Hello.*World&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4># Non-Dotall 모드: 매칭 실패 (줄바꿈 때문에)</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>print</span>(re<span style=color:#ff79c6>.</span>search(pattern, text))  <span style=color:#6272a4># None</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4># Non-Dotall에서 줄바꿈 명시적 처리</span>
</span></span><span style=display:flex><span>pattern <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>r</span><span style=color:#f1fa8c>&#34;Hello[\s\S]*World&#34;</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>print</span>(re<span style=color:#ff79c6>.</span>search(pattern, text))  <span style=color:#6272a4># &lt;re.Match object; span=(0, 11), match=&#39;Hello\nWorld&#39;&gt;</span>
</span></span></code></pre></div></li><li><strong>사용 사례</strong>: 줄바꿈을 포함하지 않는 패턴을 엄격히 매칭하거나, 줄바꿈을 명시적으로 제어하고 싶을 때 사용됩니다.</li></ul><h3 id=s-s-w-w-n의-모드별-차이점><code>/s</code>, <code>/S</code>, <code>/w</code>, <code>/W</code>, <code>.|\n</code>의 모드별 차이점<a hidden class=anchor aria-hidden=true href=#s-s-w-w-n의-모드별-차이점>#</a></h3><p>정규식에서 특정 문자 클래스와 패턴은 모드에 따라 다르게 동작합니다. 아래는 주요 패턴의 동작을 비교합니다:</p><table><thead><tr><th>패턴</th><th>설명</th><th>Dotall 모드 동작</th><th>Multi Line 모드 동작</th><th>Non-Dotall 모드 동작</th></tr></thead><tbody><tr><td><code>/s</code></td><td>공백 문자(스페이스, 탭, 줄바꿈 등)를 매칭</td><td>줄바꿈(<code>\n</code>) 포함</td><td>줄바꿈(<code>\n</code>) 포함</td><td>줄바꿈(<code>\n</code>) 포함</td></tr><tr><td><code>/S</code></td><td>공백 문자가 아닌 모든 문자를 매칭</td><td>줄바꿈(<code>\n</code>) 포함</td><td>줄바꿈(<code>\n</code>) 포함</td><td>줄바꿈(<code>\n</code>) 포함</td></tr><tr><td><code>/w</code></td><td>단어 문자(알파벳, 숫자, 언더스코어: <code>[a-zA-Z0-9_]</code>)를 매칭</td><td>모드에 무관</td><td>모드에 무관</td><td>모드에 무관</td></tr><tr><td><code>/W</code></td><td>단어 문자가 아닌 모든 문자를 매칭</td><td>모드에 무관</td><td>모드에 무관</td><td>모드에 무관</td></tr><tr><td>`.</td><td>\n`</td><td>점(<code>.</code>) 또는 줄바꿈(<code>\n</code>)을 명시적으로 매칭</td><td>불필요 (<code>.</code>)가 이미 <code>\n</code> 포함</td><td>줄바꿈(<code>\n</code>) 명시적 매칭 필요</td></tr></tbody></table><ul><li><strong>설명</strong>:<ul><li><code>/s</code>와 <code>/S</code>는 공백 문자와 비공백 문자를 매칭하며, 모든 모드에서 줄바꿈(<code>\n</code>)을 포함합니다.</li><li><code>/w</code>와 <code>/W</code>는 단어 문자와 비단어 문자를 매칭하며, 모드에 영향을 받지 않습니다.</li><li><code>.|\n</code>은 Non-Dotall 모드에서 줄바꿈을 포함하려는 대안으로 사용되며, Dotall 모드에서는 불필요합니다.</li></ul></li><li><strong>예시</strong> (Python, Non-Dotall에서 <code>.|\n</code> 사용):<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#ff79c6>import</span> re
</span></span><span style=display:flex><span>text <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;Hello</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>World&#34;</span>
</span></span><span style=display:flex><span>pattern <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>r</span><span style=color:#f1fa8c>&#34;Hello(.|\n)*World&#34;</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>match</span> <span style=color:#ff79c6>=</span> re<span style=color:#ff79c6>.</span>search(pattern, text)
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>print</span>(<span style=color:#ff79c6>match</span><span style=color:#ff79c6>.</span>group())  <span style=color:#6272a4># Hello\nWorld</span>
</span></span></code></pre></div></li></ul><h3 id=차이점-요약>차이점 요약<a hidden class=anchor aria-hidden=true href=#차이점-요약>#</a></h3><table><thead><tr><th>모드</th><th>점(<code>.</code>) 동작</th><th><code>^</code>와 <code>$</code> 동작</th><th>플래그 (Python)</th><th>플래그 (JavaScript)</th></tr></thead><tbody><tr><td>Dotall (Single Line)</td><td>줄바꿈(<code>\n</code>) 포함 모든 문자 매칭</td><td>문자열 전체의 시작/끝</td><td><code>re.DOTALL</code> (<code>re.S</code>)</td><td><code>/s</code></td></tr><tr><td>Multi Line</td><td>줄바꿈(<code>\n</code>) 제외</td><td>각 줄의 시작/끝</td><td><code>re.MULTILINE</code> (<code>re.M</code>)</td><td><code>/m</code></td></tr><tr><td>Non-Dotall</td><td>줄바꿈(<code>\n</code>) 제외</td><td>문자열 전체의 시작/끝</td><td>없음</td><td>없음</td></tr></tbody></table><h2 id=여러-줄을-표현하는-방법>여러 줄을 표현하는 방법<a hidden class=anchor aria-hidden=true href=#여러-줄을-표현하는-방법>#</a></h2><p>멀티라인 텍스트를 처리할 때, 정규식에서 여러 줄을 표현하는 주요 방법은 다음과 같습니다:</p><ol><li><p><strong>Dotall 모드 활용</strong>:</p><ul><li>점(<code>.</code>)을 사용해 줄바꿈을 포함한 모든 텍스트 블록을 매칭.</li><li>예: <code>.*</code>로 여러 줄을 한 번에 캡처.</li><li>Python 예시:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#ff79c6>import</span> re
</span></span><span style=display:flex><span>text <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;Line 1</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>Line 2</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>Line 3&#34;</span>
</span></span><span style=display:flex><span>pattern <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>r</span><span style=color:#f1fa8c>&#34;.*&#34;</span>
</span></span><span style=display:flex><span>matches <span style=color:#ff79c6>=</span> re<span style=color:#ff79c6>.</span>findall(pattern, text, re<span style=color:#ff79c6>.</span>DOTALL)
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>print</span>(matches)  <span style=color:#6272a4># [&#39;Line 1\nLine 2\nLine 3&#39;]</span>
</span></span></code></pre></div></li></ul></li><li><p><strong>줄바꿈 문자(<code>\n</code>) 명시적 사용</strong>:</p><ul><li>줄바꿈을 명시적으로 패턴에 포함(예: <code>.*\n.*</code>).</li><li>예: 두 줄에 걸친 패턴 매칭.<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#ff79c6>import</span> re
</span></span><span style=display:flex><span>text <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;Line 1</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>Line 2</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>Line 3&#34;</span>
</span></span><span style=display:flex><span>pattern <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>r</span><span style=color:#f1fa8c>&#34;.*\n.*&#34;</span>
</span></span><span style=display:flex><span>matches <span style=color:#ff79c6>=</span> re<span style=color:#ff79c6>.</span>findall(pattern, text)
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>print</span>(matches)  <span style=color:#6272a4># [&#39;Line 1\nLine 2&#39;]</span>
</span></span></code></pre></div></li></ul></li><li><p><strong>Multi Line 모드와 <code>^</code>, <code>$</code> 활용</strong>:</p><ul><li>각 줄을 개별적으로 처리.</li><li>예: 각 줄의 시작이 특정 단어로 시작하는 경우.<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#ff79c6>import</span> re
</span></span><span style=display:flex><span>text <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;apple</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>banana</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>cherry&#34;</span>
</span></span><span style=display:flex><span>pattern <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>r</span><span style=color:#f1fa8c>&#34;^\w+&#34;</span>
</span></span><span style=display:flex><span>matches <span style=color:#ff79c6>=</span> re<span style=color:#ff79c6>.</span>findall(pattern, text, re<span style=color:#ff79c6>.</span>MULTILINE)
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>print</span>(matches)  <span style=color:#6272a4># [&#39;apple&#39;, &#39;banana&#39;, &#39;cherry&#39;]</span>
</span></span></code></pre></div></li></ul></li><li><p><strong>Non-Dotall 모드에서 <code>.|\n</code> 활용</strong>:</p><ul><li>점(<code>.</code>)이 줄바꿈을 포함하지 않으므로, <code>.|\n</code>를 사용해 줄바꿈을 명시적으로 포함.</li><li>예: 여러 줄에 걸친 텍스트를 Non-Dotall 모드로 매칭.<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#ff79c6>import</span> re
</span></span><span style=display:flex><span>text <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;Line 1</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>Line 2</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>Line 3&#34;</span>
</span></span><span style=display:flex><span>pattern <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>r</span><span style=color:#f1fa8c>&#34;Line(.|\n)*3&#34;</span>
</span></span><span style=display:flex><span>matches <span style=color:#ff79c6>=</span> re<span style=color:#ff79c6>.</span>findall(pattern, text)
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>print</span>(matches)  <span style=color:#6272a4># [&#39;\n&#39;]</span>
</span></span></code></pre></div></li></ul></li></ol><h2 id=start로-시작하고-end로-끝나는-멀티라인-패턴><code>start</code>로 시작하고 <code>end</code>로 끝나는 멀티라인 패턴<a hidden class=anchor aria-hidden=true href=#start로-시작하고-end로-끝나는-멀티라인-패턴>#</a></h2><p>특정 문자열(예: <code>start</code>로 시작하고 <code>end</code>로 끝나는 패턴)을 멀티라인에서 매칭하려면 Dotall 모드 또는 Non-Dotall 모드에서 <code>[\s\S]</code>를 활용합니다. 또한 특정 문자를 포함하거나 포함하지 않는 조건을 추가할 수 있습니다.</p><h3 id=1-기본-패턴-start로-시작하고-end로-끝나는-텍스트>1. 기본 패턴: <code>start</code>로 시작하고 <code>end</code>로 끝나는 텍스트<a hidden class=anchor aria-hidden=true href=#1-기본-패턴-start로-시작하고-end로-끝나는-텍스트>#</a></h3><ul><li><strong>Dotall 모드 패턴</strong>: <code>start.*?end</code> (비탐욕적 매칭).</li><li><strong>Non-Dotall 모드 패턴</strong>: <code>start[\s\S]*?end</code>.</li><li><strong>예시</strong> (Python, Non-Dotall):<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#ff79c6>import</span> re
</span></span><span style=display:flex><span>text <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;start middle content</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>more content</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>end other text&#34;</span>
</span></span><span style=display:flex><span>pattern <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>r</span><span style=color:#f1fa8c>&#34;start[\s\S]*?end&#34;</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>match</span> <span style=color:#ff79c6>=</span> re<span style=color:#ff79c6>.</span>search(pattern, text)
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>print</span>(<span style=color:#ff79c6>match</span><span style=color:#ff79c6>.</span>group())  <span style=color:#6272a4># start middle content\nmore content\nend</span>
</span></span></code></pre></div></li></ul><h3 id=2-특정-문자-포함>2. 특정 문자 포함<a hidden class=anchor aria-hidden=true href=#2-특정-문자-포함>#</a></h3><ul><li><strong>요구사항</strong>: <code>start</code>와 <code>end</code> 사이에 특정 문자(예: <code>keyword</code>)를 포함하며, 여러 블록을 매칭.</li><li><strong>패턴</strong>: Non-Dotall 모드에서는 <code>start(?:(?!end)[\s\S])*?keyword[\s\S]*?end</code>.</li><li><strong>예시</strong> (Python, Non-Dotall):<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#ff79c6>import</span> re
</span></span><span style=display:flex><span>text <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;&#34;&#34;start first block</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>keyword here</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>end
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>some text
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>start second block</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>no keyword</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>end
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>start third block</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>keyword again</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>end&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>pattern <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>r</span><span style=color:#f1fa8c>&#34;start(?:(?!end)[\s\S])*?keyword[\s\S]*?end&#34;</span>
</span></span><span style=display:flex><span>matches <span style=color:#ff79c6>=</span> re<span style=color:#ff79c6>.</span>findall(pattern, text)
</span></span><span style=display:flex><span><span style=color:#ff79c6>for</span> <span style=color:#ff79c6>match</span> <span style=color:#ff79c6>in</span> matches:
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>print</span>(<span style=color:#ff79c6>match</span>)
</span></span></code></pre></div><strong>출력</strong>:<pre tabindex=0><code>start first block
keyword here
end
start third block
keyword again
end
</code></pre></li></ul><h3 id=3-특정-문자-포함하지-않음>3. 특정 문자 포함하지 않음<a hidden class=anchor aria-hidden=true href=#3-특정-문자-포함하지-않음>#</a></h3><ul><li><strong>요구사항</strong>: <code>start</code>와 <code>end</code> 사이에 특정 문자(예: <code>forbidden</code>)를 포함하지 않으며, 여러 블록을 매칭.</li><li><strong>패턴</strong>: Non-Dotall 모드에서는 <code>start(?:(?!end)[\s\S])*?(?![\s\S]*forbidden)[\s\S]*?end</code>.</li><li><strong>예시</strong> (Python, Non-Dotall):<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#ff79c6>import</span> re
</span></span><span style=display:flex><span>text <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;&#34;&#34;start first block</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>keyword here</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>end
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>some text
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>start second block</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>no keyword</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>end
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>start third block</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>keyword again</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>end
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>start fourth block</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>forbidden content</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>end&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>pattern <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>r</span><span style=color:#f1fa8c>&#34;start(?:(?!end)[\s\S])*?(?![\s\S]*forbidden)[\s\S]*?end&#34;</span>
</span></span><span style=display:flex><span>matches <span style=color:#ff79c6>=</span> re<span style=color:#ff79c6>.</span>findall(pattern, text)
</span></span><span style=display:flex><span><span style=color:#ff79c6>for</span> <span style=color:#ff79c6>match</span> <span style=color:#ff79c6>in</span> matches:
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>print</span>(<span style=color:#ff79c6>match</span>)
</span></span></code></pre></div><strong>출력</strong>:<pre tabindex=0><code>start first block
keyword here
end
start second block
no keyword
end
start third block
keyword again
end
</code></pre></li></ul><h2 id=기타-활용-사례>기타 활용 사례<a hidden class=anchor aria-hidden=true href=#기타-활용-사례>#</a></h2><p>정규식의 멀티라인 표현식은 다양한 시나리오에서 활용됩니다. 아래는 몇 가지 실용적인 예시입니다:</p><ol><li><p><strong>로그 파일 분석</strong>:</p><ul><li>로그 파일에서 특정 에러 메시지가 포함된 블록을 추출.</li><li>예: <code>ERROR(.|\n)*?\n</code>로 에러 메시지와 관련된 블록을 Non-Dotall 모드로 추출.<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#ff79c6>import</span> re
</span></span><span style=display:flex><span>text <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;INFO: System started</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>ERROR: Connection failed</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>Details: Timeout</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>INFO: System running&#34;</span>
</span></span><span style=display:flex><span>pattern <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>r</span><span style=color:#f1fa8c>&#34;ERROR(.|\n)*?\n&#34;</span>
</span></span><span style=display:flex><span>matches <span style=color:#ff79c6>=</span> re<span style=color:#ff79c6>.</span>findall(pattern, text)
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>print</span>(matches)  <span style=color:#6272a4># [&#39;\n&#39;, &#39;\n&#39;]</span>
</span></span></code></pre></div></li></ul></li><li><p><strong>코드 주석 추출</strong>:</p><ul><li>여러 줄 주석(예: <code>/* ... */</code>)을 Non-Dotall 모드로 추출.</li><li>예 (JavaScript):<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#ff79c6>const</span> text <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;code\n/* comment\nmultiline */\nmore code&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#ff79c6>const</span> pattern <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>/\/\*(.|\n)*?\*\//</span>;
</span></span><span style=display:flex><span><span style=color:#ff79c6>const</span> matches <span style=color:#ff79c6>=</span> text.match(pattern);
</span></span><span style=display:flex><span>console.log(matches[<span style=color:#bd93f9>0</span>]); <span style=color:#6272a4>// /* comment\nmultiline */
</span></span></span></code></pre></div></li></ul></li><li><p><strong>HTML 태그 내용 추출</strong>:</p><ul><li>특정 태그(예: <code>&lt;div>...&lt;/div></code>)의 내용을 멀티라인에서 추출.</li><li>예 (Python, Non-Dotall):<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#ff79c6>import</span> re
</span></span><span style=display:flex><span>text <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;&lt;div&gt;</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>  Content Line 1</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>  Content Line 2</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&lt;/div&gt;&#34;</span>
</span></span><span style=display:flex><span>pattern <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>r</span><span style=color:#f1fa8c>&#34;&lt;div&gt;(.|\n)*?&lt;/div&gt;&#34;</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>match</span> <span style=color:#ff79c6>=</span> re<span style=color:#ff79c6>.</span>search(pattern, text)
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>print</span>(<span style=color:#ff79c6>match</span><span style=color:#ff79c6>.</span>group())  <span style=color:#6272a4># &lt;div&gt;\n  Content Line 1\n  Content Line 2\n&lt;/div&gt;</span>
</span></span></code></pre></div></li></ul></li></ol><h2 id=결론>결론<a hidden class=anchor aria-hidden=true href=#결론>#</a></h2><p>정규식의 멀티라인 표현식은 텍스트 데이터를 다룰 때 강력한 도구입니다. <strong>Dotall 모드</strong>는 줄바꿈을 포함한 전체 텍스트 블록을 처리하는 데 유용하며, <strong>Multi Line 모드</strong>는 각 줄의 시작과 끝을 독립적으로 다룰 때 적합합니다. <strong>Non-Dotall 모드</strong>는 줄바꿈을 명시적으로 처리해야 하며, <code>[\s\S]</code>과 같은 패턴을 사용해 유연성을 제공합니다. <code>/s</code>, <code>/S</code>, <code>/w</code>, <code>/W</code>는 모드에 따라 일관된 동작을 보이며, <code>.|\n</code>은 Non-Dotall 모드에서 줄바꿈을 포함하는 대안입니다. <code>start</code>와 <code>end</code>로 둘러싸인 패턴을 매칭하거나 특정 문자를 포함/제외하는 패턴을 활용하면 복잡한 텍스트 처리 작업을 효율적으로 수행할 수 있습니다.</p><h2 id=추가-리소스>추가 리소스<a hidden class=anchor aria-hidden=true href=#추가-리소스>#</a></h2><ul><li><a href=https://regex101.com/>Regular Expressions 101</a> - 정규식 테스트 및 디버깅 도구</li><li><a href=https://docs.python.org/3/library/re.html>Python re 모듈 문서</a></li><li><a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp>JavaScript RegExp MDN 문서</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://cdecl.github.io/tags/regex/>Regex</a></li><li><a href=https://cdecl.github.io/tags/regular-expression/>Regular Expression</a></li><li><a href=https://cdecl.github.io/tags/multiline/>Multiline</a></li><li><a href=https://cdecl.github.io/tags/programming/>Programming</a></li><li><a href=https://cdecl.github.io/tags/text-processing/>Text-Processing</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://cdecl.github.io/>cdeclog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>