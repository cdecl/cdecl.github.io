<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>OpenClaw (구 Clawdbot): 로컬 중심의 개인용 AI 런타임 심층 분석 | cdeclog</title><meta name=keywords content="openclaw,clawdbot,ai-agent,nodejs,automation,browser-automation,security"><meta name=description content="
공지: Clawdbot은 OpenClaw로 리브랜딩되었습니다. 이 문서는 기존 Clawdbot의 개념과 함께 새로운 OpenClaw의 관점에서 내용을 보강하고 있습니다.

**OpenClaw (구 Clawdbot)**은 본격적으로 로컬에서 실행되는 AI 런타임이다. 클라우드 기반 서비스와 달리, 사용자의 컴퓨터(Mac/Linux)에서 백그라운드 데몬으로 동작하며 로컬 데이터만을 활용한다. 사용자에게는 터미널, 파일시스템, 브라우저 컨트롤 같은 OS 리소스가 직관적으로 노출된다.
1. OpenClaw (구 Clawdbot)란?
OpenClaw은 Node.js 기반으로 구현된 로컬 AI 런타임이다. 클라우드에 의존하지 않고, 사용자의 개인 환경에서 실행되므로 데이터 유출 위험이 최소화된다. 주요 특징은 다음과 같다."><meta name=author content="Byung Kyu KIM"><link rel=canonical href=https://cdecl.github.io/devops/clawdbot-deep-dive/><link crossorigin=anonymous href=/assets/css/stylesheet.f939c4ffefb264e6fe85e04352266f79db6bb1303c8e16ae9b6064c1247b5e32.css integrity="sha256-+TnE/++yZOb+heBDUiZvedtrsTA8jhaum2BkwSR7XjI=" rel="preload stylesheet" as=style><link rel=icon href=https://cdecl.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://cdecl.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://cdecl.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://cdecl.github.io/apple-touch-icon.png><link rel=mask-icon href=https://cdecl.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://cdecl.github.io/devops/clawdbot-deep-dive/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-VQQHHYPN7K"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VQQHHYPN7K")}</script><meta property="og:url" content="https://cdecl.github.io/devops/clawdbot-deep-dive/"><meta property="og:site_name" content="cdeclog"><meta property="og:title" content="OpenClaw (구 Clawdbot): 로컬 중심의 개인용 AI 런타임 심층 분석"><meta property="og:description" content=" 공지: Clawdbot은 OpenClaw로 리브랜딩되었습니다. 이 문서는 기존 Clawdbot의 개념과 함께 새로운 OpenClaw의 관점에서 내용을 보강하고 있습니다.
**OpenClaw (구 Clawdbot)**은 본격적으로 로컬에서 실행되는 AI 런타임이다. 클라우드 기반 서비스와 달리, 사용자의 컴퓨터(Mac/Linux)에서 백그라운드 데몬으로 동작하며 로컬 데이터만을 활용한다. 사용자에게는 터미널, 파일시스템, 브라우저 컨트롤 같은 OS 리소스가 직관적으로 노출된다.
1. OpenClaw (구 Clawdbot)란? OpenClaw은 Node.js 기반으로 구현된 로컬 AI 런타임이다. 클라우드에 의존하지 않고, 사용자의 개인 환경에서 실행되므로 데이터 유출 위험이 최소화된다. 주요 특징은 다음과 같다."><meta property="og:locale" content="ko-kr"><meta property="og:type" content="article"><meta property="article:section" content="devops"><meta property="article:published_time" content="2026-01-29T00:00:00+09:00"><meta property="article:modified_time" content="2026-01-29T00:00:00+09:00"><meta property="article:tag" content="Openclaw"><meta property="article:tag" content="Clawdbot"><meta property="article:tag" content="Ai-Agent"><meta property="article:tag" content="Nodejs"><meta property="article:tag" content="Automation"><meta property="article:tag" content="Browser-Automation"><meta name=twitter:card content="summary"><meta name=twitter:title content="OpenClaw (구 Clawdbot): 로컬 중심의 개인용 AI 런타임 심층 분석"><meta name=twitter:description content="
공지: Clawdbot은 OpenClaw로 리브랜딩되었습니다. 이 문서는 기존 Clawdbot의 개념과 함께 새로운 OpenClaw의 관점에서 내용을 보강하고 있습니다.

**OpenClaw (구 Clawdbot)**은 본격적으로 로컬에서 실행되는 AI 런타임이다. 클라우드 기반 서비스와 달리, 사용자의 컴퓨터(Mac/Linux)에서 백그라운드 데몬으로 동작하며 로컬 데이터만을 활용한다. 사용자에게는 터미널, 파일시스템, 브라우저 컨트롤 같은 OS 리소스가 직관적으로 노출된다.
1. OpenClaw (구 Clawdbot)란?
OpenClaw은 Node.js 기반으로 구현된 로컬 AI 런타임이다. 클라우드에 의존하지 않고, 사용자의 개인 환경에서 실행되므로 데이터 유출 위험이 최소화된다. 주요 특징은 다음과 같다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Devops","item":"https://cdecl.github.io/devops/"},{"@type":"ListItem","position":2,"name":"OpenClaw (구 Clawdbot): 로컬 중심의 개인용 AI 런타임 심층 분석","item":"https://cdecl.github.io/devops/clawdbot-deep-dive/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"OpenClaw (구 Clawdbot): 로컬 중심의 개인용 AI 런타임 심층 분석","name":"OpenClaw (구 Clawdbot): 로컬 중심의 개인용 AI 런타임 심층 분석","description":" 공지: Clawdbot은 OpenClaw로 리브랜딩되었습니다. 이 문서는 기존 Clawdbot의 개념과 함께 새로운 OpenClaw의 관점에서 내용을 보강하고 있습니다.\n**OpenClaw (구 Clawdbot)**은 본격적으로 로컬에서 실행되는 AI 런타임이다. 클라우드 기반 서비스와 달리, 사용자의 컴퓨터(Mac/Linux)에서 백그라운드 데몬으로 동작하며 로컬 데이터만을 활용한다. 사용자에게는 터미널, 파일시스템, 브라우저 컨트롤 같은 OS 리소스가 직관적으로 노출된다.\n1. OpenClaw (구 Clawdbot)란? OpenClaw은 Node.js 기반으로 구현된 로컬 AI 런타임이다. 클라우드에 의존하지 않고, 사용자의 개인 환경에서 실행되므로 데이터 유출 위험이 최소화된다. 주요 특징은 다음과 같다.\n","keywords":["openclaw","clawdbot","ai-agent","nodejs","automation","browser-automation","security"],"articleBody":" 공지: Clawdbot은 OpenClaw로 리브랜딩되었습니다. 이 문서는 기존 Clawdbot의 개념과 함께 새로운 OpenClaw의 관점에서 내용을 보강하고 있습니다.\n**OpenClaw (구 Clawdbot)**은 본격적으로 로컬에서 실행되는 AI 런타임이다. 클라우드 기반 서비스와 달리, 사용자의 컴퓨터(Mac/Linux)에서 백그라운드 데몬으로 동작하며 로컬 데이터만을 활용한다. 사용자에게는 터미널, 파일시스템, 브라우저 컨트롤 같은 OS 리소스가 직관적으로 노출된다.\n1. OpenClaw (구 Clawdbot)란? OpenClaw은 Node.js 기반으로 구현된 로컬 AI 런타임이다. 클라우드에 의존하지 않고, 사용자의 개인 환경에서 실행되므로 데이터 유출 위험이 최소화된다. 주요 특징은 다음과 같다.\nOS 위의 쉘: 터미널 명령을 실행하고, 브라우저를 제어하며, 파일시스템을 조작한다. 장기 실행: 데몬 프로세스를 통해 상태를 유지하고, 필요에 따라 백그라운드에서 동작한다. 멀티 모델 지원: 클라우드 LLM(예: Google Gemini, Anthropic Claude)과 로컬 LLM(예: Ollama)이 동시에 사용 가능하다. 2. 핵심 아키텍처 OpenClaw은 세 가지 핵심 컴포넌트로 구성된다.\n2.1 Gateway (데몬) 역할: CLI·웹 UI와 Agent 간 연결 관리 및 보안 정책 강제 통신: HTTP/WebSocket (JSON‑RPC 2.0) 보안: Tailscale 연동으로 외부에서도 안전 접근 가능 2.2 Session (상태 머신) 목적: 사용자와의 대화 맥락을 유지 다중 모델: 세션마다 Cloud 또는 Local 모드 지정 메모리: MEMORY.md 마크다운 파일에 대화 내용 저장 2.3 Skills (플러그인) 프레임워크: 독립적인 NPM 패키지·로컬 디렉토리 명세서: SKILL.md 로 LLM에게 사용법을 전달 Core Skills: read, write, exec, web_search User Skills: 사용자가 스크립트/타입스크립트 으로 직접 개발 가능 3. 브라우저 자동화 OpenClaw은 두 가지 브라우저 제어 방식을 제공한다.\n3.1 Dedicated Browser (Clawd Profile) 기술: Playwright와 유사한 CDP 사용, Headless Chrome 실행 특징: 완전 격리된 새 컴퓨터 환경, 쿠키·세션 별도 용도: 웹 검색·데이터 수집·로그인 없이 접근 가능한 공개 서비스 3.2 Extension Relay (Chrome Extension) 기술: 사용자의 설치된 확장 프로그램이 CDP 명령 중계 특징: 현재 탭을 직접 제어, 사용자 세션 그대로 사용 용도: “메일 확인해줘”, “이 페이지 요약해줘” 등 개인화 작업 작동 1. Gateway가 로컬 웹서버를 엽니다. 2. 확장 프로그램이 chrome.debugger를 통해 탭에 연결됩니다. 3. 두 엔드포인트가 WebSocket으로 CDP 명령을 주고받습니다. 두 모드는 상황에 따라 자동 스위칭하거나, 사용자가 명시적으로 선택 가능하다.\n4. 보안 모델 AI가 로컬 시스템을 제어할 때 필요한 보안 조치를 정리한다.\n샌드박싱 제한된 권한에서 실행. rm -rf / 같은 위험 명령은 차단하거나 승인 요구. Human‑in‑the‑loop 파일 삭제·송금·민감 정보 전송 같은 위험 작업은 y/n 승인 필요. 로컬 우선 로컬 LLM(예: Ollama) 사용 시 프롬프트가 외부 서버로 전송되지 않는다. 5. 모델 활용 전략 OpenClaw의 가장 큰 장점 중 하나는 하이브리드 모델 접근 방식이다. 사용자는 작업의 성격과 보안 요구사항에 따라 클라우드 모델과 로컬 모델을 자유롭게 전환할 수 있다.\n5.1 클라우드 모델 (Cloud Models) 특징: 최고 수준의 성능과 추론 능력을 제공한다. 복잡한 코드를 생성하거나, 깊이 있는 분석이 필요할 때 적합하다. 주요 모델: Anthropic: Claude 3 (Opus, Sonnet, Haiku) Google: Gemini (Ultra, Pro, Flash) OpenAI: GPT-4, GPT-4o 단점: API 비용이 발생하며, 데이터를 외부로 전송해야 하는 보안상의 트레이드오프가 있다. 5.2 Ollama를 활용한 로컬 모델 (Local Models with Ollama) 특징: 인터넷 연결 없이, 개인 기기에서 모델을 실행할 수 있다. 개인정보 보호에 유리하며, 오프라인 환경에서도 작업이 가능하다. 설치 및 사용: Ollama를 설치하면 ollama run 같은 간단한 명령으로 모델을 실행하고 관리할 수 있다. 장점: 비용이 없고, 응답 속도가 빠르며, 데이터가 로컬 환경을 벗어나지 않는다. 5.3 16GB 메모리 환경을 위한 현실적인 모델 추천 대부분의 최신 노트북과 데스크톱 환경(예: 16GB RAM)에서도 충분히 활용 가능한 고성능 소형 모델(sLLM)들이 많다.\nMeta Llama 3 (8B) (Ollama: llama3:8b): 80억 파라미터 모델로, 동급 최강의 성능을 자랑한다. 일반적인 대화, 코딩, 요약 작업에 매우 뛰어나다. 약 6-8GB의 RAM을 사용한다. Mistral (7B) (Ollama: mistral:7b): Llama 3와 유사한 성능을 내는 70억 파라미터 모델. 특히 지시(Instruction)를 따르는 능력이 우수하다. 약 5-7GB의 RAM을 사용한다. Gemma (7B) (Ollama: gemma:7b): 구글이 개발한 70억 파라미터 모델. 균형 잡힌 성능을 보여주며, 안정적인 선택지 중 하나다. Phi-3 (3.8B) (Ollama: phi3:3.8b): Microsoft가 개발한 38억 파라미터의 초소형 모델. 4-5GB의 적은 RAM으로도 놀라운 성능을 보여주어, 경량 환경에 가장 적합하다. 이러한 모델들은 OpenClaw의 Local 모드와 결합될 때, 보안과 성능의 균형을 맞춘 최적의 개인용 AI 환경을 구축할 수 있게 해준다.\n5.4 모델 설정 및 고급 전략 OpenClaw의 멀티 모델 환경을 효과적으로 사용하려면, 체계적인 설정 파일과 동작 전략을 정의하는 것이 중요하다. 공식 문서에 따르면, 설정 파일은 ~/.openclaw/openclaw.json 경로에 JSON 형식으로 저장된다.\n참고: 기존 config.toml 형식에서 openclaw.json 형식으로 변경되었습니다. 아래는 모델을 설정하는 간단한 예시입니다.\n설정 파일 예시 (openclaw.json) { \"agent\": { \"model\": \"anthropic/claude-opus-4-5\" }, \"channels\": { \"telegram\": { \"botToken\": \"123456:ABCDEF\" } } } 설정 및 인증 (Configuration \u0026 Authentication) API 키 관리: 위 예시처럼 API 키는 설정 파일에 직접 저장하기보다, GOOGLE_API_KEY, ANTHROPIC_API_KEY 같은 환경 변수를 통해 관리하는 것이 가장 안전하다. OpenClaw 런타임은 시작 시 이 환경 변수를 자동으로 로드한다. 모델별 파라미터: temperature (창의성), timeout (타임아웃) 등 모델의 동작을 세밀하게 조정하는 파라미터를 제공자별로 설정할 수 있다. Fallback 및 복합 전략 (Fallback \u0026 Hybrid Strategy) 로컬 우선 Fallback: strategy.fallback 테이블은 비용과 성능을 최적화하는 핵심 전략이다. 평상시에는 비용이 없는 로컬 모델(primary_provider)을 사용하다가, 응답 시간이 길어지거나(timeout), 사용자가 복잡한 작업을 요구(keyword)할 때만 클라우드 모델(secondary_provider)로 자동 전환하여 비용을 절약하고 생산성을 높인다. 의도 기반 라우팅: strategy.routing은 한 단계 더 나아간 전략이다. phi3:mini 같이 매우 가벼운 로컬 모델을 ‘교통경찰’처럼 활용하여, 사용자의 질문 의도를 먼저 파악한다. 이후, “간단한 질문\"은 중간급 로컬 모델로, “복잡한 추론\"이나 “코드 생성\"은 각 작업에 특화된 최강의 클라우드 모델로 요청을 분배하여 효율을 극대화한다. 6. OpenClaw 활용 사례 및 아이디어 OpenClaw의 진정한 힘은 로컬 시스템의 모든 자원을 AI와 결합하여 무한한 자동화 가능성을 여는 데 있다. 다음은 몇 가지 구체적인 활용 사례와 스킬 확장 아이디어다.\n6.1 주요 활용 사례 5가지 일일 브리핑 및 업무 준비\n프롬프트: “오늘 주요 뉴스 3줄 요약하고, 새로 온 이메일 제목만 뽑아서 알려줘. 그리고 오늘 내 캘린더에 등록된 미팅 일정도 함께 정리해줘.” 작동 방식: web_search 스킬로 뉴스를 검색 및 요약하고, 브라우저 확장(Extension Relay)을 통해 Gmail에 접근하여 이메일 제목을 가져온다. 캘린더 접근 역시 확장을 통해 가능하다. 이 모든 정보를 종합하여 하나의 보고서로 제공한다. 프로젝트 초기 환경 자동 설정\n프롬프트: “내 개발 폴더에 ‘my-next-app’ 이름으로 새 프로젝트를 만들고, Next.js와 TypeScript, Tailwind CSS 환경을 설정해줘.” 작동 방식: exec 스킬을 사용하여 터미널 명령(npx create-next-app@latest ..., npm install ...)을 순차적으로 실행한다. write 스킬로 tailwind.config.js 같은 설정 파일을 생성하거나 수정하여 초기 세팅을 완료한다. Git 레포지토리 분석 및 보고\n프롬프트: “현재 git 프로젝트의 최근 2주간 커밋 내역을 분석해서, 어떤 파일이 가장 많이 바뀌었는지, 그리고 주요 기능 변경사항이 무엇이었는지 요약 보고서를 작성해줘.” 작동 방식: exec 스킬로 git log --since=\"2 weeks ago\" --name-status 같은 명령을 실행하여 데이터를 수집한다. 수집된 텍스트를 LLM이 분석하여 가장 많이 변경된 파일과 커밋 메시지를 기반으로 주요 변경 사항을 요약한다. 로컬 서버 모니터링 및 알림\n프롬프트: “로컬 개발 서버를 시작하고, logs/app.log 파일을 실시간으로 감시해줘. 만약 ‘FATAL’ 또는 ‘ERROR’ 키워드가 포함된 로그가 발생하면 즉시 나에게 알려줘.” 작동 방식: exec 스킬을 백그라운드로 실행하여 서버를 구동(npm run dev \u0026)하고, 다른 exec 프로세스로 tail -f logs/app.log | grep -E 'FATAL|ERROR' 명령을 실행하여 로그를 모니터링한다. 특정 키워드가 감지되면 사용자에게 알림을 보낸다. 자동화된 기술 리서치 및 요약\n프롬프트: “최근에 발표된 ‘Mixtral 8x22B’ 모델에 대한 기술 블로그나 논문을 찾아서, 가장 중요한 내용(아키텍처, 성능)을 요약하고 관련 링크를 research.md 파일로 저장해줘.” 작동 방식: web_search 스킬로 관련 정보를 검색하고, 결과 페이지에 접근하여 내용을 추출한다. LLM이 추출된 텍스트를 요약하고, write 스킬을 사용해 지정된 파일에 결과를 저장한다. 6.2 사용자 Skill 확장 아이디어 OpenClaw은 사용자가 직접 스킬을 만들어 기능을 무한히 확장할 수 있다.\n데이터베이스 스킬: 로컬 SQLite나 PostgreSQL 데이터베이스에 연결하여, 자연어 질문을 SQL 쿼리로 변환하고 실행 결과를 반환하는 스킬. “지난달 가장 많이 팔린 상품 5개 보여줘” 같은 요청을 처리할 수 있다. 클라우드 관리 스킬: aws, gcloud, az 같은 클라우드 CLI 도구를 래핑하여 스킬을 만들 수 있다. “현재 GCP 프로젝트에 실행 중인 VM 인스턴스 목록 보여줘” 같은 명령을 자연어로 내릴 수 있게 된다. 프로젝트 맞춤형 스킬: 특정 프로젝트의 구조를 이해하고, 테스트 실행(npm test), 빌드, 배포 같은 반복 작업을 자동화하는 스킬. “내 블로그 글 새로 썼는데, 빌드해서 배포까지 해줘.” 개인 지식 베이스(PKM) 스킬: Obsidian, Notion 같은 개인 지식 관리 도구의 로컬 파일이나 API와 연동하여, “내 옵시디언 노트에서 ‘인공지능’에 대한 모든 글 찾아줘” 같은 요청을 처리하는 스킬. 7. 마치며 OpenClaw은 “나를 위한, 나만의, 내 컴퓨터에 사는” 비서다. 클라우드 서비스와 비교했을 때, 데이터 통제력·runtime 제어가 훨씬 강력하다. 앞으로도 더 진화하여 로컬 중심의 AI 에이전트로 확장될 전망이다.\n","wordCount":"1242","inLanguage":"en","datePublished":"2026-01-29T00:00:00+09:00","dateModified":"2026-01-29T00:00:00+09:00","author":{"@type":"Person","name":"Byung Kyu KIM"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://cdecl.github.io/devops/clawdbot-deep-dive/"},"publisher":{"@type":"Organization","name":"cdeclog","logo":{"@type":"ImageObject","url":"https://cdecl.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://cdecl.github.io/ accesskey=h title="cdeclog (Alt + H)">cdeclog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://cdecl.github.io/dev/ title=Dev><span>Dev</span></a></li><li><a href=https://cdecl.github.io/devops/ title=DevOps><span>DevOps</span></a></li><li><a href=https://cdecl.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://cdecl.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://cdecl.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://cdecl.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://cdecl.github.io/devops/>Devops</a></div><h1 class="post-title entry-hint-parent">OpenClaw (구 Clawdbot): 로컬 중심의 개인용 AI 런타임 심층 분석</h1><div class=post-meta><span title='2026-01-29 00:00:00 +0900 KST'>January 29, 2026</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#1-openclaw-%ea%b5%ac-clawdbot%eb%9e%80 aria-label="1. OpenClaw (구 Clawdbot)란?">1. OpenClaw (구 Clawdbot)란?</a></li><li><a href=#2-%ed%95%b5%ec%8b%ac-%ec%95%84%ed%82%a4%ed%85%8d%ec%b2%98 aria-label="2. 핵심 아키텍처">2. 핵심 아키텍처</a><ul><li><a href=#21-gateway-%eb%8d%b0%eb%aa%ac aria-label="2.1 Gateway (데몬)">2.1 Gateway (데몬)</a></li><li><a href=#22-session-%ec%83%81%ed%83%9c-%eb%a8%b8%ec%8b%a0 aria-label="2.2 Session (상태 머신)">2.2 Session (상태 머신)</a></li><li><a href=#23-skills-%ed%94%8c%eb%9f%ac%ea%b7%b8%ec%9d%b8 aria-label="2.3 Skills (플러그인)">2.3 Skills (플러그인)</a></li></ul></li><li><a href=#3-%eb%b8%8c%eb%9d%bc%ec%9a%b0%ec%a0%80-%ec%9e%90%eb%8f%99%ed%99%94 aria-label="3. 브라우저 자동화">3. 브라우저 자동화</a><ul><li><a href=#31-dedicated-browser-clawd-profile aria-label="3.1 Dedicated Browser (Clawd Profile)">3.1 Dedicated Browser (Clawd Profile)</a></li><li><a href=#32-extension-relay-chrome-extension aria-label="3.2 Extension Relay (Chrome Extension)">3.2 Extension Relay (Chrome Extension)</a></li></ul></li><li><a href=#4-%eb%b3%b4%ec%95%88-%eb%aa%a8%eb%8d%b8 aria-label="4. 보안 모델">4. 보안 모델</a></li><li><a href=#5-%eb%aa%a8%eb%8d%b8-%ed%99%9c%ec%9a%a9-%ec%a0%84%eb%9e%b5 aria-label="5. 모델 활용 전략">5. 모델 활용 전략</a><ul><li><a href=#51-%ed%81%b4%eb%9d%bc%ec%9a%b0%eb%93%9c-%eb%aa%a8%eb%8d%b8-cloud-models aria-label="5.1 클라우드 모델 (Cloud Models)">5.1 클라우드 모델 (Cloud Models)</a></li><li><a href=#52-ollama%eb%a5%bc-%ed%99%9c%ec%9a%a9%ed%95%9c-%eb%a1%9c%ec%bb%ac-%eb%aa%a8%eb%8d%b8-local-models-with-ollama aria-label="5.2 Ollama를 활용한 로컬 모델 (Local Models with Ollama)">5.2 Ollama를 활용한 로컬 모델 (Local Models with Ollama)</a></li><li><a href=#53-16gb-%eb%a9%94%eb%aa%a8%eb%a6%ac-%ed%99%98%ea%b2%bd%ec%9d%84-%ec%9c%84%ed%95%9c-%ed%98%84%ec%8b%a4%ec%a0%81%ec%9d%b8-%eb%aa%a8%eb%8d%b8-%ec%b6%94%ec%b2%9c aria-label="5.3 16GB 메모리 환경을 위한 현실적인 모델 추천">5.3 16GB 메모리 환경을 위한 현실적인 모델 추천</a></li><li><a href=#54-%eb%aa%a8%eb%8d%b8-%ec%84%a4%ec%a0%95-%eb%b0%8f-%ea%b3%a0%ea%b8%89-%ec%a0%84%eb%9e%b5 aria-label="5.4 모델 설정 및 고급 전략">5.4 모델 설정 및 고급 전략</a><ul><li><a href=#%ec%84%a4%ec%a0%95-%ed%8c%8c%ec%9d%bc-%ec%98%88%ec%8b%9c-openclawjson aria-label="설정 파일 예시 (openclaw.json)">설정 파일 예시 (openclaw.json)</a></li><li><a href=#%ec%84%a4%ec%a0%95-%eb%b0%8f-%ec%9d%b8%ec%a6%9d-configuration--authentication aria-label="설정 및 인증 (Configuration & Authentication)">설정 및 인증 (Configuration & Authentication)</a></li><li><a href=#fallback-%eb%b0%8f-%eb%b3%b5%ed%95%a9-%ec%a0%84%eb%9e%b5-fallback--hybrid-strategy aria-label="Fallback 및 복합 전략 (Fallback & Hybrid Strategy)">Fallback 및 복합 전략 (Fallback & Hybrid Strategy)</a></li></ul></li></ul></li><li><a href=#6-openclaw-%ed%99%9c%ec%9a%a9-%ec%82%ac%eb%a1%80-%eb%b0%8f-%ec%95%84%ec%9d%b4%eb%94%94%ec%96%b4 aria-label="6. OpenClaw 활용 사례 및 아이디어">6. OpenClaw 활용 사례 및 아이디어</a><ul><li><a href=#61-%ec%a3%bc%ec%9a%94-%ed%99%9c%ec%9a%a9-%ec%82%ac%eb%a1%80-5%ea%b0%80%ec%a7%80 aria-label="6.1 주요 활용 사례 5가지">6.1 주요 활용 사례 5가지</a></li><li><a href=#62-%ec%82%ac%ec%9a%a9%ec%9e%90-skill-%ed%99%95%ec%9e%a5-%ec%95%84%ec%9d%b4%eb%94%94%ec%96%b4 aria-label="6.2 사용자 Skill 확장 아이디어">6.2 사용자 Skill 확장 아이디어</a></li></ul></li><li><a href=#7-%eb%a7%88%ec%b9%98%eb%a9%b0 aria-label="7. 마치며">7. 마치며</a></li></ul></div></details></div><div class=post-content><blockquote><p><strong>공지</strong>: <strong>Clawdbot</strong>은 <strong>OpenClaw</strong>로 리브랜딩되었습니다. 이 문서는 기존 Clawdbot의 개념과 함께 새로운 OpenClaw의 관점에서 내용을 보강하고 있습니다.</p></blockquote><p>**OpenClaw (구 Clawdbot)**은 본격적으로 로컬에서 실행되는 AI 런타임이다. 클라우드 기반 서비스와 달리, 사용자의 컴퓨터(Mac/Linux)에서 백그라운드 데몬으로 동작하며 로컬 데이터만을 활용한다. 사용자에게는 터미널, 파일시스템, 브라우저 컨트롤 같은 OS 리소스가 직관적으로 노출된다.</p><h2 id=1-openclaw-구-clawdbot란>1. OpenClaw (구 Clawdbot)란?<a hidden class=anchor aria-hidden=true href=#1-openclaw-구-clawdbot란>#</a></h2><p>OpenClaw은 <strong>Node.js</strong> 기반으로 구현된 <strong>로컬 AI 런타임</strong>이다. 클라우드에 의존하지 않고, 사용자의 개인 환경에서 실행되므로 데이터 유출 위험이 최소화된다. 주요 특징은 다음과 같다.</p><ul><li><strong>OS 위의 쉘</strong>: 터미널 명령을 실행하고, 브라우저를 제어하며, 파일시스템을 조작한다.</li><li><strong>장기 실행</strong>: 데몬 프로세스를 통해 상태를 유지하고, 필요에 따라 백그라운드에서 동작한다.</li><li><strong>멀티 모델 지원</strong>: 클라우드 LLM(예: Google Gemini, Anthropic Claude)과 로컬 LLM(예: Ollama)이 동시에 사용 가능하다.</li></ul><h2 id=2-핵심-아키텍처>2. 핵심 아키텍처<a hidden class=anchor aria-hidden=true href=#2-핵심-아키텍처>#</a></h2><p>OpenClaw은 세 가지 핵심 컴포넌트로 구성된다.</p><h3 id=21-gateway-데몬>2.1 Gateway (데몬)<a hidden class=anchor aria-hidden=true href=#21-gateway-데몬>#</a></h3><ul><li><strong>역할</strong>: CLI·웹 UI와 Agent 간 연결 관리 및 보안 정책 강제</li><li><strong>통신</strong>: HTTP/WebSocket (JSON‑RPC 2.0)</li><li><strong>보안</strong>: Tailscale 연동으로 외부에서도 안전 접근 가능</li></ul><h3 id=22-session-상태-머신>2.2 Session (상태 머신)<a hidden class=anchor aria-hidden=true href=#22-session-상태-머신>#</a></h3><ul><li><strong>목적</strong>: 사용자와의 대화 맥락을 유지</li><li><strong>다중 모델</strong>: 세션마다 <strong>Cloud</strong> 또는 <strong>Local</strong> 모드 지정</li><li><strong>메모리</strong>: <code>MEMORY.md</code> 마크다운 파일에 대화 내용 저장</li></ul><h3 id=23-skills-플러그인>2.3 Skills (플러그인)<a hidden class=anchor aria-hidden=true href=#23-skills-플러그인>#</a></h3><ul><li><strong>프레임워크</strong>: 독립적인 NPM 패키지·로컬 디렉토리</li><li><strong>명세서</strong>: <code>SKILL.md</code> 로 LLM에게 사용법을 전달</li><li><strong>Core Skills</strong>: <code>read</code>, <code>write</code>, <code>exec</code>, <code>web_search</code></li><li><strong>User Skills</strong>: 사용자가 스크립트/타입스크립트 으로 직접 개발 가능</li></ul><h2 id=3-브라우저-자동화>3. 브라우저 자동화<a hidden class=anchor aria-hidden=true href=#3-브라우저-자동화>#</a></h2><p>OpenClaw은 두 가지 브라우저 제어 방식을 제공한다.</p><h3 id=31-dedicated-browser-clawd-profile>3.1 Dedicated Browser (Clawd Profile)<a hidden class=anchor aria-hidden=true href=#31-dedicated-browser-clawd-profile>#</a></h3><ul><li><strong>기술</strong>: Playwright와 유사한 CDP 사용, Headless Chrome 실행</li><li><strong>특징</strong>: 완전 격리된 새 컴퓨터 환경, 쿠키·세션 별도</li><li><strong>용도</strong>: 웹 검색·데이터 수집·로그인 없이 접근 가능한 공개 서비스</li></ul><h3 id=32-extension-relay-chrome-extension>3.2 Extension Relay (Chrome Extension)<a hidden class=anchor aria-hidden=true href=#32-extension-relay-chrome-extension>#</a></h3><ul><li><strong>기술</strong>: 사용자의 설치된 확장 프로그램이 CDP 명령 중계</li><li><strong>특징</strong>: 현재 탭을 직접 제어, 사용자 세션 그대로 사용</li><li><strong>용도</strong>: “메일 확인해줘”, “이 페이지 요약해줘” 등 개인화 작업</li><li><strong>작동</strong> 1. Gateway가 로컬 웹서버를 엽니다. 2. 확장 프로그램이 <code>chrome.debugger</code>를 통해 탭에 연결됩니다. 3. 두 엔드포인트가 WebSocket으로 CDP 명령을 주고받습니다.</li></ul><p>두 모드는 상황에 따라 자동 스위칭하거나, 사용자가 명시적으로 선택 가능하다.</p><h2 id=4-보안-모델>4. 보안 모델<a hidden class=anchor aria-hidden=true href=#4-보안-모델>#</a></h2><p>AI가 로컬 시스템을 제어할 때 필요한 보안 조치를 정리한다.</p><ol><li><strong>샌드박싱</strong><ul><li>제한된 권한에서 실행. <code>rm -rf /</code> 같은 위험 명령은 차단하거나 승인 요구.</li></ul></li><li><strong>Human‑in‑the‑loop</strong><ul><li>파일 삭제·송금·민감 정보 전송 같은 위험 작업은 <code>y/n</code> 승인 필요.</li></ul></li><li><strong>로컬 우선</strong><ul><li>로컬 LLM(예: Ollama) 사용 시 프롬프트가 외부 서버로 전송되지 않는다.</li></ul></li></ol><h2 id=5-모델-활용-전략>5. 모델 활용 전략<a hidden class=anchor aria-hidden=true href=#5-모델-활용-전략>#</a></h2><p>OpenClaw의 가장 큰 장점 중 하나는 <strong>하이브리드 모델 접근 방식</strong>이다. 사용자는 작업의 성격과 보안 요구사항에 따라 클라우드 모델과 로컬 모델을 자유롭게 전환할 수 있다.</p><h3 id=51-클라우드-모델-cloud-models>5.1 클라우드 모델 (Cloud Models)<a hidden class=anchor aria-hidden=true href=#51-클라우드-모델-cloud-models>#</a></h3><ul><li><strong>특징</strong>: 최고 수준의 성능과 추론 능력을 제공한다. 복잡한 코드를 생성하거나, 깊이 있는 분석이 필요할 때 적합하다.</li><li><strong>주요 모델</strong>:<ul><li><strong>Anthropic</strong>: <code>Claude 3</code> (Opus, Sonnet, Haiku)</li><li><strong>Google</strong>: <code>Gemini</code> (Ultra, Pro, Flash)</li><li><strong>OpenAI</strong>: <code>GPT-4</code>, <code>GPT-4o</code></li></ul></li><li><strong>단점</strong>: API 비용이 발생하며, 데이터를 외부로 전송해야 하는 보안상의 트레이드오프가 있다.</li></ul><h3 id=52-ollama를-활용한-로컬-모델-local-models-with-ollama>5.2 Ollama를 활용한 로컬 모델 (Local Models with Ollama)<a hidden class=anchor aria-hidden=true href=#52-ollama를-활용한-로컬-모델-local-models-with-ollama>#</a></h3><ul><li><strong>특징</strong>: 인터넷 연결 없이, 개인 기기에서 모델을 실행할 수 있다. 개인정보 보호에 유리하며, 오프라인 환경에서도 작업이 가능하다.</li><li><strong>설치 및 사용</strong>: <a href=https://ollama.com/>Ollama</a>를 설치하면 <code>ollama run &lt;model_name></code> 같은 간단한 명령으로 모델을 실행하고 관리할 수 있다.</li><li><strong>장점</strong>: 비용이 없고, 응답 속도가 빠르며, 데이터가 로컬 환경을 벗어나지 않는다.</li></ul><h3 id=53-16gb-메모리-환경을-위한-현실적인-모델-추천>5.3 16GB 메모리 환경을 위한 현실적인 모델 추천<a hidden class=anchor aria-hidden=true href=#53-16gb-메모리-환경을-위한-현실적인-모델-추천>#</a></h3><p>대부분의 최신 노트북과 데스크톱 환경(예: 16GB RAM)에서도 충분히 활용 가능한 고성능 소형 모델(sLLM)들이 많다.</p><ul><li><strong>Meta Llama 3 (8B)</strong> (Ollama: <code>llama3:8b</code>): 80억 파라미터 모델로, 동급 최강의 성능을 자랑한다. 일반적인 대화, 코딩, 요약 작업에 매우 뛰어나다. 약 6-8GB의 RAM을 사용한다.</li><li><strong>Mistral (7B)</strong> (Ollama: <code>mistral:7b</code>): Llama 3와 유사한 성능을 내는 70억 파라미터 모델. 특히 지시(Instruction)를 따르는 능력이 우수하다. 약 5-7GB의 RAM을 사용한다.</li><li><strong>Gemma (7B)</strong> (Ollama: <code>gemma:7b</code>): 구글이 개발한 70억 파라미터 모델. 균형 잡힌 성능을 보여주며, 안정적인 선택지 중 하나다.</li><li><strong>Phi-3 (3.8B)</strong> (Ollama: <code>phi3:3.8b</code>): Microsoft가 개발한 38억 파라미터의 초소형 모델. 4-5GB의 적은 RAM으로도 놀라운 성능을 보여주어, 경량 환경에 가장 적합하다.</li></ul><p>이러한 모델들은 OpenClaw의 <strong>Local</strong> 모드와 결합될 때, 보안과 성능의 균형을 맞춘 최적의 개인용 AI 환경을 구축할 수 있게 해준다.</p><h3 id=54-모델-설정-및-고급-전략>5.4 모델 설정 및 고급 전략<a hidden class=anchor aria-hidden=true href=#54-모델-설정-및-고급-전략>#</a></h3><p>OpenClaw의 멀티 모델 환경을 효과적으로 사용하려면, 체계적인 설정 파일과 동작 전략을 정의하는 것이 중요하다. 공식 문서에 따르면, 설정 파일은 <code>~/.openclaw/openclaw.json</code> 경로에 <strong>JSON</strong> 형식으로 저장된다.</p><blockquote><p><strong>참고</strong>: 기존 <code>config.toml</code> 형식에서 <code>openclaw.json</code> 형식으로 변경되었습니다. 아래는 모델을 설정하는 간단한 예시입니다.</p></blockquote><h4 id=설정-파일-예시-openclawjson>설정 파일 예시 (<code>openclaw.json</code>)<a hidden class=anchor aria-hidden=true href=#설정-파일-예시-openclawjson>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>&#34;agent&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>&#34;model&#34;</span>: <span style=color:#f1fa8c>&#34;anthropic/claude-opus-4-5&#34;</span>
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>&#34;channels&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>&#34;telegram&#34;</span>: {
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>&#34;botToken&#34;</span>: <span style=color:#f1fa8c>&#34;123456:ABCDEF&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=설정-및-인증-configuration--authentication>설정 및 인증 (Configuration & Authentication)<a hidden class=anchor aria-hidden=true href=#설정-및-인증-configuration--authentication>#</a></h4><ul><li><strong>API 키 관리</strong>: 위 예시처럼 API 키는 설정 파일에 직접 저장하기보다, <code>GOOGLE_API_KEY</code>, <code>ANTHROPIC_API_KEY</code> 같은 <strong>환경 변수</strong>를 통해 관리하는 것이 가장 안전하다. OpenClaw 런타임은 시작 시 이 환경 변수를 자동으로 로드한다.</li><li><strong>모델별 파라미터</strong>: <code>temperature</code> (창의성), <code>timeout</code> (타임아웃) 등 모델의 동작을 세밀하게 조정하는 파라미터를 제공자별로 설정할 수 있다.</li></ul><h4 id=fallback-및-복합-전략-fallback--hybrid-strategy>Fallback 및 복합 전략 (Fallback & Hybrid Strategy)<a hidden class=anchor aria-hidden=true href=#fallback-및-복합-전략-fallback--hybrid-strategy>#</a></h4><ul><li><strong>로컬 우선 Fallback</strong>: <code>strategy.fallback</code> 테이블은 비용과 성능을 최적화하는 핵심 전략이다. 평상시에는 비용이 없는 로컬 모델(<code>primary_provider</code>)을 사용하다가, 응답 시간이 길어지거나(<code>timeout</code>), 사용자가 복잡한 작업을 요구(<code>keyword</code>)할 때만 클라우드 모델(<code>secondary_provider</code>)로 자동 전환하여 비용을 절약하고 생산성을 높인다.</li><li><strong>의도 기반 라우팅</strong>: <code>strategy.routing</code>은 한 단계 더 나아간 전략이다. <code>phi3:mini</code> 같이 매우 가벼운 로컬 모델을 &lsquo;교통경찰&rsquo;처럼 활용하여, 사용자의 질문 의도를 먼저 파악한다. 이후, &ldquo;간단한 질문"은 중간급 로컬 모델로, &ldquo;복잡한 추론"이나 &ldquo;코드 생성"은 각 작업에 특화된 최강의 클라우드 모델로 요청을 분배하여 효율을 극대화한다.</li></ul><h2 id=6-openclaw-활용-사례-및-아이디어>6. OpenClaw 활용 사례 및 아이디어<a hidden class=anchor aria-hidden=true href=#6-openclaw-활용-사례-및-아이디어>#</a></h2><p>OpenClaw의 진정한 힘은 로컬 시스템의 모든 자원을 AI와 결합하여 무한한 자동화 가능성을 여는 데 있다. 다음은 몇 가지 구체적인 활용 사례와 스킬 확장 아이디어다.</p><h3 id=61-주요-활용-사례-5가지>6.1 주요 활용 사례 5가지<a hidden class=anchor aria-hidden=true href=#61-주요-활용-사례-5가지>#</a></h3><ol><li><p><strong>일일 브리핑 및 업무 준비</strong></p><ul><li><strong>프롬프트</strong>: &ldquo;오늘 주요 뉴스 3줄 요약하고, 새로 온 이메일 제목만 뽑아서 알려줘. 그리고 오늘 내 캘린더에 등록된 미팅 일정도 함께 정리해줘.&rdquo;</li><li><strong>작동 방식</strong>: <code>web_search</code> 스킬로 뉴스를 검색 및 요약하고, 브라우저 확장(<code>Extension Relay</code>)을 통해 Gmail에 접근하여 이메일 제목을 가져온다. 캘린더 접근 역시 확장을 통해 가능하다. 이 모든 정보를 종합하여 하나의 보고서로 제공한다.</li></ul></li><li><p><strong>프로젝트 초기 환경 자동 설정</strong></p><ul><li><strong>프롬프트</strong>: &ldquo;내 개발 폴더에 &lsquo;my-next-app&rsquo; 이름으로 새 프로젝트를 만들고, Next.js와 TypeScript, Tailwind CSS 환경을 설정해줘.&rdquo;</li><li><strong>작동 방식</strong>: <code>exec</code> 스킬을 사용하여 터미널 명령(<code>npx create-next-app@latest ...</code>, <code>npm install ...</code>)을 순차적으로 실행한다. <code>write</code> 스킬로 <code>tailwind.config.js</code> 같은 설정 파일을 생성하거나 수정하여 초기 세팅을 완료한다.</li></ul></li><li><p><strong>Git 레포지토리 분석 및 보고</strong></p><ul><li><strong>프롬프트</strong>: &ldquo;현재 git 프로젝트의 최근 2주간 커밋 내역을 분석해서, 어떤 파일이 가장 많이 바뀌었는지, 그리고 주요 기능 변경사항이 무엇이었는지 요약 보고서를 작성해줘.&rdquo;</li><li><strong>작동 방식</strong>: <code>exec</code> 스킬로 <code>git log --since="2 weeks ago" --name-status</code> 같은 명령을 실행하여 데이터를 수집한다. 수집된 텍스트를 LLM이 분석하여 가장 많이 변경된 파일과 커밋 메시지를 기반으로 주요 변경 사항을 요약한다.</li></ul></li><li><p><strong>로컬 서버 모니터링 및 알림</strong></p><ul><li><strong>프롬프트</strong>: &ldquo;로컬 개발 서버를 시작하고, <code>logs/app.log</code> 파일을 실시간으로 감시해줘. 만약 &lsquo;FATAL&rsquo; 또는 &lsquo;ERROR&rsquo; 키워드가 포함된 로그가 발생하면 즉시 나에게 알려줘.&rdquo;</li><li><strong>작동 방식</strong>: <code>exec</code> 스킬을 백그라운드로 실행하여 서버를 구동(<code>npm run dev &</code>)하고, 다른 <code>exec</code> 프로세스로 <code>tail -f logs/app.log | grep -E 'FATAL|ERROR'</code> 명령을 실행하여 로그를 모니터링한다. 특정 키워드가 감지되면 사용자에게 알림을 보낸다.</li></ul></li><li><p><strong>자동화된 기술 리서치 및 요약</strong></p><ul><li><strong>프롬프트</strong>: &ldquo;최근에 발표된 &lsquo;Mixtral 8x22B&rsquo; 모델에 대한 기술 블로그나 논문을 찾아서, 가장 중요한 내용(아키텍처, 성능)을 요약하고 관련 링크를 <code>research.md</code> 파일로 저장해줘.&rdquo;</li><li><strong>작동 방식</strong>: <code>web_search</code> 스킬로 관련 정보를 검색하고, 결과 페이지에 접근하여 내용을 추출한다. LLM이 추출된 텍스트를 요약하고, <code>write</code> 스킬을 사용해 지정된 파일에 결과를 저장한다.</li></ul></li></ol><h3 id=62-사용자-skill-확장-아이디어>6.2 사용자 Skill 확장 아이디어<a hidden class=anchor aria-hidden=true href=#62-사용자-skill-확장-아이디어>#</a></h3><p>OpenClaw은 사용자가 직접 스킬을 만들어 기능을 무한히 확장할 수 있다.</p><ul><li><strong>데이터베이스 스킬</strong>: 로컬 SQLite나 PostgreSQL 데이터베이스에 연결하여, 자연어 질문을 SQL 쿼리로 변환하고 실행 결과를 반환하는 스킬. &ldquo;지난달 가장 많이 팔린 상품 5개 보여줘&rdquo; 같은 요청을 처리할 수 있다.</li><li><strong>클라우드 관리 스킬</strong>: <code>aws</code>, <code>gcloud</code>, <code>az</code> 같은 클라우드 CLI 도구를 래핑하여 스킬을 만들 수 있다. &ldquo;현재 GCP 프로젝트에 실행 중인 VM 인스턴스 목록 보여줘&rdquo; 같은 명령을 자연어로 내릴 수 있게 된다.</li><li><strong>프로젝트 맞춤형 스킬</strong>: 특정 프로젝트의 구조를 이해하고, 테스트 실행(<code>npm test</code>), 빌드, 배포 같은 반복 작업을 자동화하는 스킬. &ldquo;내 블로그 글 새로 썼는데, 빌드해서 배포까지 해줘.&rdquo;</li><li><strong>개인 지식 베이스(PKM) 스킬</strong>: Obsidian, Notion 같은 개인 지식 관리 도구의 로컬 파일이나 API와 연동하여, &ldquo;내 옵시디언 노트에서 &lsquo;인공지능&rsquo;에 대한 모든 글 찾아줘&rdquo; 같은 요청을 처리하는 스킬.</li></ul><h2 id=7-마치며>7. 마치며<a hidden class=anchor aria-hidden=true href=#7-마치며>#</a></h2><p>OpenClaw은 “나를 위한, 나만의, 내 컴퓨터에 사는” 비서다. 클라우드 서비스와 비교했을 때, 데이터 통제력·runtime 제어가 훨씬 강력하다. 앞으로도 더 진화하여 로컬 중심의 AI 에이전트로 확장될 전망이다.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://cdecl.github.io/tags/openclaw/>Openclaw</a></li><li><a href=https://cdecl.github.io/tags/clawdbot/>Clawdbot</a></li><li><a href=https://cdecl.github.io/tags/ai-agent/>Ai-Agent</a></li><li><a href=https://cdecl.github.io/tags/nodejs/>Nodejs</a></li><li><a href=https://cdecl.github.io/tags/automation/>Automation</a></li><li><a href=https://cdecl.github.io/tags/browser-automation/>Browser-Automation</a></li><li><a href=https://cdecl.github.io/tags/security/>Security</a></li></ul></footer><script src=https://giscus.app/client.js data-repo=cdecl/cdecl.github.io data-repo-id="MDEwOlJlcG9zaXRvcnkzNDk1ODUyNjg=" data-category=General data-category-id=DIC_kwDOFNY_dM4C1XMk data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=transparent_dark data-lang=ko crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2026 <a href=https://cdecl.github.io/>cdeclog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>