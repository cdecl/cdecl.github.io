<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>DuckDB CLI 및 SQL CheatSheet | cdeclog</title><meta name=keywords content="duckdb,sql,cli,csv,parquet,json,excel,데이터베이스,http,s3"><meta name=description content="DuckDB CLI 및 SQL CheatSheet - 주요 파일 포맷, DB Attach, HTTP/S3, Excel
DuckDB CLI 및 SQL CheatSheet 가이드
1. DuckDB와 CLI/SQL 기능 소개
DuckDB는 고성능 분석 쿼리를 위해 설계된 인-프로세스, 컬럼 지향 OLAP 데이터베이스입니다. CLI와 SQL 인터페이스를 통해 CSV, Parquet, JSON, Excel 등의 파일 포맷을 처리하고, 데이터베이스를 관리하며, HTTP/S3와 같은 웹 기반 스토리지와 통합할 수 있습니다. 이 치트시트는 DuckDB의 CLI와 SQL 명령어를 중심으로 실용적인 예제와 모범 사례를 제공합니다.
주요 기능:"><meta name=author content="Byung Kyu KIM"><link rel=canonical href=https://cdecl.github.io/devops/duckdb-cheatsheet/><link crossorigin=anonymous href=/assets/css/stylesheet.d980bb9fb2cba61af0aead0606b5eb221d7e358748ac394b60233d95d626c563.css integrity="sha256-2YC7n7LLphrwrq0GBrXrIh1+NYdIrDlLYCM9ldYmxWM=" rel="preload stylesheet" as=style><link rel=icon href=https://cdecl.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://cdecl.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://cdecl.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://cdecl.github.io/apple-touch-icon.png><link rel=mask-icon href=https://cdecl.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://cdecl.github.io/devops/duckdb-cheatsheet/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-VQQHHYPN7K"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VQQHHYPN7K")}</script><meta property="og:url" content="https://cdecl.github.io/devops/duckdb-cheatsheet/"><meta property="og:site_name" content="cdeclog"><meta property="og:title" content="DuckDB CLI 및 SQL CheatSheet"><meta property="og:description" content="DuckDB CLI 및 SQL CheatSheet - 주요 파일 포맷, DB Attach, HTTP/S3, Excel
DuckDB CLI 및 SQL CheatSheet 가이드 1. DuckDB와 CLI/SQL 기능 소개 DuckDB는 고성능 분석 쿼리를 위해 설계된 인-프로세스, 컬럼 지향 OLAP 데이터베이스입니다. CLI와 SQL 인터페이스를 통해 CSV, Parquet, JSON, Excel 등의 파일 포맷을 처리하고, 데이터베이스를 관리하며, HTTP/S3와 같은 웹 기반 스토리지와 통합할 수 있습니다. 이 치트시트는 DuckDB의 CLI와 SQL 명령어를 중심으로 실용적인 예제와 모범 사례를 제공합니다.
주요 기능:"><meta property="og:locale" content="ko-kr"><meta property="og:type" content="article"><meta property="article:section" content="devops"><meta property="article:published_time" content="2025-04-15T00:00:00+09:00"><meta property="article:modified_time" content="2025-04-15T00:00:00+09:00"><meta property="article:tag" content="Duckdb"><meta property="article:tag" content="Sql"><meta property="article:tag" content="Cli"><meta property="article:tag" content="Csv"><meta property="article:tag" content="Parquet"><meta property="article:tag" content="Json"><meta name=twitter:card content="summary"><meta name=twitter:title content="DuckDB CLI 및 SQL CheatSheet"><meta name=twitter:description content="DuckDB CLI 및 SQL CheatSheet - 주요 파일 포맷, DB Attach, HTTP/S3, Excel
DuckDB CLI 및 SQL CheatSheet 가이드
1. DuckDB와 CLI/SQL 기능 소개
DuckDB는 고성능 분석 쿼리를 위해 설계된 인-프로세스, 컬럼 지향 OLAP 데이터베이스입니다. CLI와 SQL 인터페이스를 통해 CSV, Parquet, JSON, Excel 등의 파일 포맷을 처리하고, 데이터베이스를 관리하며, HTTP/S3와 같은 웹 기반 스토리지와 통합할 수 있습니다. 이 치트시트는 DuckDB의 CLI와 SQL 명령어를 중심으로 실용적인 예제와 모범 사례를 제공합니다.
주요 기능:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Devops","item":"https://cdecl.github.io/devops/"},{"@type":"ListItem","position":2,"name":"DuckDB CLI 및 SQL CheatSheet","item":"https://cdecl.github.io/devops/duckdb-cheatsheet/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"DuckDB CLI 및 SQL CheatSheet","name":"DuckDB CLI 및 SQL CheatSheet","description":"DuckDB CLI 및 SQL CheatSheet - 주요 파일 포맷, DB Attach, HTTP/S3, Excel\nDuckDB CLI 및 SQL CheatSheet 가이드 1. DuckDB와 CLI/SQL 기능 소개 DuckDB는 고성능 분석 쿼리를 위해 설계된 인-프로세스, 컬럼 지향 OLAP 데이터베이스입니다. CLI와 SQL 인터페이스를 통해 CSV, Parquet, JSON, Excel 등의 파일 포맷을 처리하고, 데이터베이스를 관리하며, HTTP/S3와 같은 웹 기반 스토리지와 통합할 수 있습니다. 이 치트시트는 DuckDB의 CLI와 SQL 명령어를 중심으로 실용적인 예제와 모범 사례를 제공합니다.\n주요 기능:\n","keywords":["duckdb","sql","cli","csv","parquet","json","excel","데이터베이스","http","s3"],"articleBody":"DuckDB CLI 및 SQL CheatSheet - 주요 파일 포맷, DB Attach, HTTP/S3, Excel\nDuckDB CLI 및 SQL CheatSheet 가이드 1. DuckDB와 CLI/SQL 기능 소개 DuckDB는 고성능 분석 쿼리를 위해 설계된 인-프로세스, 컬럼 지향 OLAP 데이터베이스입니다. CLI와 SQL 인터페이스를 통해 CSV, Parquet, JSON, Excel 등의 파일 포맷을 처리하고, 데이터베이스를 관리하며, HTTP/S3와 같은 웹 기반 스토리지와 통합할 수 있습니다. 이 치트시트는 DuckDB의 CLI와 SQL 명령어를 중심으로 실용적인 예제와 모범 사례를 제공합니다.\n주요 기능:\n파일 포맷 지원: CSV, Parquet, JSON, Excel 등을 손쉽게 읽고 쓰기. 데이터베이스 관리: 여러 데이터베이스를 연결하고 테이블을 효율적으로 관리. 웹 통합: httpfs 확장을 통해 HTTP 또는 S3에서 원격 데이터 접근. 사용 편의성: 직관적인 CLI와 SQL 문법으로 빠른 데이터 처리. 이 가이드는 데이터 엔지니어, 분석가, 개발자가 로컬 및 원격 데이터 워크플로우에 DuckDB를 활용하고자 할 때 유용합니다.\n2. 파일 포맷 vs. 데이터베이스 작업 DuckDB는 파일 직접 작업과 전통적인 데이터베이스 관리를 모두 지원합니다. 아래 표는 두 접근 방식의 차이를 비교합니다:\n기능 파일 작업 데이터베이스 작업 범위 CSV, Parquet, JSON, Excel 파일 영구 DB 파일 (.db) 접근 방식 SQL로 직접 읽기/쓰기 데이터베이스 연결, 테이블 생성 및 쿼리 사용 사례 임시 분석, ETL 구조화된 데이터 저장, 인덱싱 예제 SELECT * FROM 'file.csv'; ATTACH 'mydb.db'; SELECT * FROM mytable; 파일 작업은 빠른 분석에 적합하며, 데이터베이스 작업은 구조화된 영구 저장에 적합합니다. DuckDB는 두 방식 간 전환을 유연하게 지원합니다.\n3. 파일 포맷 작업 DuckDB는 read_csv_auto, read_parquet, read_json_auto, 그리고 excel 확장을 통해 CSV, Parquet, JSON, Excel 파일을 지원합니다. 각 포맷에 대한 주요 명령어는 아래와 같습니다.\n3.1 CSV 파일 가져오기:\nCLI: duckdb -c \"CREATE TABLE mytable AS SELECT * FROM 'file.csv';\" SQL: SELECT * FROM read_csv_auto('file.csv'); CREATE TABLE mytable AS SELECT * FROM read_csv('file.csv', delim=',', header=TRUE); 사용자 정의 스키마: SELECT * FROM read_csv('file.csv', columns={'id': 'INTEGER', 'name': 'VARCHAR'}); 헤더 옵션 (header):\nheader=TRUE: 첫 번째 행을 컬럼 이름으로 사용. SELECT * FROM read_csv('file.csv', header=TRUE); header=FALSE: 첫 번째 행을 데이터로 처리, 기본 컬럼 이름 생성 (예: column0, column1). SELECT * FROM read_csv('file.csv', header=FALSE); read_csv_auto는 기본적으로 header=TRUE로 동작하며, 헤더 유무를 자동 감지. SELECT * FROM read_csv_auto('file.csv', header=TRUE); 내보내기:\nCLI: duckdb -c \"COPY mytable TO 'output.csv';\" SQL: COPY mytable TO 'output.csv' (DELIMITER ',', HEADER); 내보내기 시 HEADER 옵션 추가로 컬럼 이름 포함: COPY mytable TO 'output.csv' (DELIMITER ',', HEADER TRUE); 참고:\nread_csv_auto는 구분자와 스키마를 자동으로 감지. header 옵션은 데이터의 구조를 명확히 지정할 때 유용. 압축 파일 지원 (예: file.csv.gz). 3.2 Parquet 파일 가져오기:\nCLI: duckdb -c \"CREATE TABLE mytable AS SELECT * FROM 'file.parquet';\" SQL: SELECT * FROM read_parquet('file.parquet'); CREATE TABLE mytable AS SELECT * FROM read_parquet('file.parquet'); 다중 파일: SELECT * FROM read_parquet(['file1.parquet', 'file2.parquet']); 내보내기:\nCLI: duckdb -c \"COPY mytable TO 'output.parquet';\" SQL: COPY mytable TO 'output.parquet' (FORMAT PARQUET); 참고:\n컬럼 지향 저장으로 대규모 데이터에 최적화. 원격 접근 지원 (HTTP/S3 섹션 참조). 3.2.1 DuckDB 내장 테이블과 Parquet 비교 DuckDB 내장 테이블은 DuckDB의 독자적인 열 지향 스토리지 형식(예: .duckdb 파일)으로, 데이터 수정 및 트랜잭션을 지원하며 쿼리 실행에 최적화되어 있습니다. 반면, Parquet는 오픈소스 열 지향 파일 형식으로, 높은 압축률과 분산 환경(S3, HDFS) 호환성을 제공하지만 데이터 수정은 불가능합니다.\n주요 차이점: DuckDB 내장 테이블: 메모리 또는 디스크 기반 저장소. 데이터 수정(INSERT, UPDATE, DELETE) 가능. DuckDB 쿼리 엔진에 최적화, 소규모 데이터에서 빠른 읽기/쓰기. 용도: 데이터 변환, 증분 업데이트, 메모리 내 분석. Parquet 파일: 높은 압축률로 대규모 데이터에 적합. 읽기 전용, 수정하려면 새 파일 생성 필요. Spark, Pandas 등 외부 도구와의 호환성. 용도: 데이터 아카이빙, 공유, 분산 저장소. 성능 비교 표: 항목 DuckDB 내장 테이블 Parquet 파일 읽기 성능 소규모 데이터 빠름, 쿼리 최적화 우수 대규모 데이터 유리, 높은 압축률, 메타데이터 활용 쓰기 성능 소규모 데이터 빠름, 증분 업데이트 가능 대규모 데이터 압축으로 디스크 사용량 적음, 쓰기 느림 데이터 수정 가능 (INSERT, UPDATE, DELETE) 불가 (새 파일 덮어쓰기 필요) 압축률 중간 높음 (Snappy, ZSTD 등) 호환성 DuckDB 전용 Spark, Pandas 등 다양한 도구와 호환 추천 사용 사례: DuckDB 내장 테이블: 데이터 수정이 빈번하거나, 메모리 내 분석이 필요한 경우. Parquet: 대규모 데이터 저장, 외부 시스템과의 데이터 공유, S3 같은 분산 환경. 하이브리드: Parquet 파일을 DuckDB 테이블로 로드해 분석 (예: CREATE TABLE mytable AS SELECT * FROM read_parquet('file.parquet');). 3.3 JSON 파일 가져오기:\nCLI: duckdb -c \"CREATE TABLE mytable AS SELECT * FROM read_json_auto('file.json');\" SQL: SELECT * FROM read_json_auto('file.json'); CREATE TABLE mytable AS SELECT * FROM read_json('file.json', format='auto'); JSON Lines: SELECT * FROM read_json('file.jsonl', lines=TRUE); 내보내기:\nCLI: duckdb -c \"COPY mytable TO 'output.json';\" SQL: COPY mytable TO 'output.json' (FORMAT JSON); 참고:\n중첩 JSON은 unnest로 평탄화 가능. read_json_auto는 스키마를 자동 추론. 3.4 Excel 파일 설정:\nExcel 파일 처리는 excel 확장이 필요. 설치 및 로드: INSTALL excel; LOAD excel; 가져오기:\nCLI: duckdb -c \"CREATE TABLE mytable AS SELECT * FROM read_xlsx('file.xlsx');\" SQL: SELECT * FROM read_xlsx('file.xlsx'); CREATE TABLE mytable AS SELECT * FROM read_xlsx('file.xlsx'); 특정 시트 지정: SELECT * FROM read_xlsx('file.xlsx', sheet='Sheet1'); 특정 셀 범위 지정: SELECT * FROM read_xlsx('file.xlsx', sheet='Sheet1', range='A1:C10'); 내보내기:\nCLI: duckdb -c \"COPY mytable TO 'output.xlsx' WITH (FORMAT xlsx);\" SQL: COPY mytable TO 'output.xlsx' WITH (FORMAT xlsx, SHEET 'Sheet1'); 여러 시트로 내보내기: COPY mytable TO 'output.xlsx' WITH (FORMAT xlsx, SHEET 'DataSheet'); 참고:\nread_xlsx은 .xlsx, .xls 파일을 지원하며, sheet 또는 range 옵션으로 데이터 범위를 지정할 수 있음. COPY ... WITH (FORMAT xlsx)을 사용해 Excel 파일로 내보내기 가능. 복잡한 서식(예: 차트, 매크로)은 지원하지 않음. 원격 Excel 파일은 HTTP/S3를 통해 접근 가능 (아래 섹션 참조). 대규모 데이터는 Parquet으로 변환 권장. 4. 데이터베이스 작업 및 Attach DuckDB는 인-메모리 및 파일 기반 데이터베이스를 지원하며, ATTACH 명령어로 다중 데이터베이스 워크플로우를 구현할 수 있습니다.\n4.1 데이터베이스 관리 데이터베이스 열기:\nCLI: duckdb mydb.db # 파일 기반 DB duckdb # 인-메모리 DB SQL: ATTACH DATABASE 'mydb.db' AS mydb; DETACH DATABASE mydb; 테이블 작업:\nSQL: CREATE TABLE mytable (id INTEGER, name VARCHAR); INSERT INTO mytable VALUES (1, 'Alice'), (2, 'Bob'); SELECT * FROM mytable WHERE id \u003e 1; DROP TABLE mytable; 인덱싱:\nSQL: CREATE INDEX idx ON mytable(id); 4.2 다중 데이터베이스 쿼리를 위한 ATTACH 단일 데이터베이스:\nSQL: ATTACH DATABASE 'mydb.db' AS mydb; USE mydb; SELECT * FROM mytable; CLI: duckdb -c \"ATTACH DATABASE 'mydb.db' AS mydb;\" 다중 데이터베이스:\nSQL: ATTACH DATABASE 'db1.db' AS db1; ATTACH DATABASE 'db2.db' AS db2; SELECT * FROM db1.mytable JOIN db2.another_table ON db1.mytable.id = db2.another_table.id; 참고:\nATTACH로 여러 데이터베이스 간 쿼리 가능. 기본 데이터베이스는 main, 추가 데이터베이스는 별칭(예: mydb)으로 구분. 5. HTTP 및 S3 통합 DuckDB의 httpfs 확장은 HTTP 또는 S3를 통해 원격 파일에 접근할 수 있게 해주며, 클라우드 기반 워크플로우에 이상적입니다.\n5.1 설정 확장 설치 및 로드: SQL: INSTALL httpfs; LOAD httpfs; CLI: duckdb -c \"INSTALL httpfs; LOAD httpfs;\" 5.2 HTTP 접근 가져오기:\nSQL: SELECT * FROM read_csv_auto('https://example.com/data.csv'); SELECT * FROM read_parquet('https://example.com/file.parquet'); SELECT * FROM read_xlsx('https://example.com/file.xlsx', sheet='Sheet1'); CLI: duckdb -c \"SELECT * FROM read_xlsx('https://example.com/file.xlsx');\" 내보내기:\nSQL: COPY mytable TO 'https://example.com/output.xlsx' WITH (FORMAT xlsx, SHEET 'Sheet1'); 5.3 S3 접근 자격 증명으로 가져오기:\nSQL: SET s3_access_key_id = 'your_access_key'; SET s3_secret_access_key = 'your_secret_key'; SELECT * FROM read_parquet('s3://bucket/file.parquet'); SELECT * FROM read_xlsx('s3://bucket/file.xlsx', sheet='Sheet1'); 익명 접근: SELECT * FROM read_parquet('s3://bucket/public/file.parquet'); SELECT * FROM read_xlsx('s3://bucket/public/file.xlsx'); 내보내기:\nSQL: COPY mytable TO 's3://bucket/output.xlsx' WITH (FORMAT xlsx, SHEET 'Sheet1'); 참고:\nS3 리전 설정: SET s3_region = 'us-east-1';. httpfs는 HTTP와 S3 프로토콜 모두 지원. Excel 파일의 원격 내보내기는 httpfs 확장과 함께 작동. 6. CLI 유틸리티 DuckDB의 CLI는 출력 형식과 실행 옵션을 통해 생산성을 높입니다.\n출력 형식:\n.mode box # 보기 좋은 테이블 출력 .mode csv # CSV 출력 쿼리 실행:\nduckdb -c \"SELECT * FROM 'file.csv';\" # 단일 쿼리 duckdb \u003c query.sql # SQL 파일 실행 기타 명령어:\n.open mydb.db # DB 열기 .help # 도움말 보기 .exit # 종료 7. 예제 SQL 및 CLI 워크플로우 아래는 실제 데이터 처리 시나리오를 보여주는 예제입니다.\n예제 데이터 로컬 CSV 파일: users.csv (id, name 컬럼, 헤더 포함). 로컬 Excel 파일: sales.xlsx (Sheet1에 데이터 포함). 원격 Parquet 파일: s3://bucket/data.parquet. 데이터베이스: mydb.db. 예제 워크플로우 # CLI로 DuckDB 실행 및 확장 로드 duckdb \u003e INSTALL httpfs; LOAD httpfs; \u003e INSTALL excel; LOAD excel; # 로컬 CSV에서 테이블 생성 (헤더 포함) \u003e CREATE TABLE users AS SELECT * FROM read_csv_auto('users.csv', header=TRUE); # 로컬 Excel 파일에서 데이터 가져오기 \u003e CREATE TABLE sales AS SELECT * FROM read_xlsx('sales.xlsx', sheet='Sheet1'); # 원격 Parquet 데이터 쿼리 \u003e SELECT * FROM read_parquet('s3://bucket/data.parquet') LIMIT 5; # 데이터베이스 연결 및 데이터 삽입 \u003e ATTACH DATABASE 'mydb.db' AS mydb; \u003e INSERT INTO mydb.users SELECT * FROM users; # 다중 DB 쿼리 \u003e ATTACH DATABASE 'db2.db' AS db2; \u003e SELECT u.name FROM mydb.users u JOIN db2.orders o ON u.id = o.user_id; # 결과 내보내기 (Excel 파일) \u003e COPY users TO 'output.xlsx' WITH (FORMAT xlsx, SHEET 'Users'); 이 워크플로우는 로컬 및 원격 데이터를 통합하고, 다중 데이터베이스 쿼리를 실행하며, 결과를 다양한 포맷(특히 Excel)으로 내보내는 과정을 보여줍니다.\n8. 추가 팁 쿼리 최적화:\nEXPLAIN ANALYZE SELECT * FROM mytable; # 실행 계획 분석 SUMMARIZE mytable; # 데이터 요약 다중 포맷 통합:\nSELECT * FROM read_csv_auto('file.csv') UNION ALL SELECT * FROM read_parquet('file.parquet') UNION ALL SELECT * FROM read_xlsx('file.xlsx', sheet='Sheet1'); 로컬 및 원격 혼합:\nSELECT * FROM read_csv_auto('https://example.com/data.csv') UNION ALL SELECT * FROM read_xlsx('https://example.com/file.xlsx', sheet='Sheet1'); ","wordCount":"1427","inLanguage":"en","datePublished":"2025-04-15T00:00:00+09:00","dateModified":"2025-04-15T00:00:00+09:00","author":{"@type":"Person","name":"Byung Kyu KIM"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://cdecl.github.io/devops/duckdb-cheatsheet/"},"publisher":{"@type":"Organization","name":"cdeclog","logo":{"@type":"ImageObject","url":"https://cdecl.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://cdecl.github.io/ accesskey=h title="cdeclog (Alt + H)">cdeclog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://cdecl.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://cdecl.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://cdecl.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">DuckDB CLI 및 SQL CheatSheet</h1><div class=post-meta><span title='2025-04-15 00:00:00 +0900 KST'>April 15, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#duckdb-cli-%eb%b0%8f-sql-cheatsheet-%ea%b0%80%ec%9d%b4%eb%93%9c aria-label="DuckDB CLI 및 SQL CheatSheet 가이드">DuckDB CLI 및 SQL CheatSheet 가이드</a><ul><li><a href=#1-duckdb%ec%99%80-clisql-%ea%b8%b0%eb%8a%a5-%ec%86%8c%ea%b0%9c aria-label="1. DuckDB와 CLI/SQL 기능 소개">1. DuckDB와 CLI/SQL 기능 소개</a></li><li><a href=#2-%ed%8c%8c%ec%9d%bc-%ed%8f%ac%eb%a7%b7-vs-%eb%8d%b0%ec%9d%b4%ed%84%b0%eb%b2%a0%ec%9d%b4%ec%8a%a4-%ec%9e%91%ec%97%85 aria-label="2. 파일 포맷 vs. 데이터베이스 작업">2. 파일 포맷 vs. 데이터베이스 작업</a></li><li><a href=#3-%ed%8c%8c%ec%9d%bc-%ed%8f%ac%eb%a7%b7-%ec%9e%91%ec%97%85 aria-label="3. 파일 포맷 작업">3. 파일 포맷 작업</a><ul><li><a href=#31-csv-%ed%8c%8c%ec%9d%bc aria-label="3.1 CSV 파일">3.1 CSV 파일</a></li><li><a href=#32-parquet-%ed%8c%8c%ec%9d%bc aria-label="3.2 Parquet 파일">3.2 Parquet 파일</a><ul><li><a href=#321-duckdb-%eb%82%b4%ec%9e%a5-%ed%85%8c%ec%9d%b4%eb%b8%94%ea%b3%bc-parquet-%eb%b9%84%ea%b5%90 aria-label="3.2.1 DuckDB 내장 테이블과 Parquet 비교">3.2.1 DuckDB 내장 테이블과 Parquet 비교</a><ul><li><a href=#%ec%a3%bc%ec%9a%94-%ec%b0%a8%ec%9d%b4%ec%a0%90 aria-label="주요 차이점:">주요 차이점:</a></li><li><a href=#%ec%84%b1%eb%8a%a5-%eb%b9%84%ea%b5%90-%ed%91%9c aria-label="성능 비교 표:">성능 비교 표:</a></li><li><a href=#%ec%b6%94%ec%b2%9c-%ec%82%ac%ec%9a%a9-%ec%82%ac%eb%a1%80 aria-label="추천 사용 사례:">추천 사용 사례:</a></li></ul></li></ul></li><li><a href=#33-json-%ed%8c%8c%ec%9d%bc aria-label="3.3 JSON 파일">3.3 JSON 파일</a></li><li><a href=#34-excel-%ed%8c%8c%ec%9d%bc aria-label="3.4 Excel 파일">3.4 Excel 파일</a></li></ul></li><li><a href=#4-%eb%8d%b0%ec%9d%b4%ed%84%b0%eb%b2%a0%ec%9d%b4%ec%8a%a4-%ec%9e%91%ec%97%85-%eb%b0%8f-attach aria-label="4. 데이터베이스 작업 및 Attach">4. 데이터베이스 작업 및 Attach</a><ul><li><a href=#41-%eb%8d%b0%ec%9d%b4%ed%84%b0%eb%b2%a0%ec%9d%b4%ec%8a%a4-%ea%b4%80%eb%a6%ac aria-label="4.1 데이터베이스 관리">4.1 데이터베이스 관리</a></li><li><a href=#42-%eb%8b%a4%ec%a4%91-%eb%8d%b0%ec%9d%b4%ed%84%b0%eb%b2%a0%ec%9d%b4%ec%8a%a4-%ec%bf%bc%eb%a6%ac%eb%a5%bc-%ec%9c%84%ed%95%9c-attach aria-label="4.2 다중 데이터베이스 쿼리를 위한 ATTACH">4.2 다중 데이터베이스 쿼리를 위한 ATTACH</a></li></ul></li><li><a href=#5-http-%eb%b0%8f-s3-%ed%86%b5%ed%95%a9 aria-label="5. HTTP 및 S3 통합">5. HTTP 및 S3 통합</a><ul><li><a href=#51-%ec%84%a4%ec%a0%95 aria-label="5.1 설정">5.1 설정</a></li><li><a href=#52-http-%ec%a0%91%ea%b7%bc aria-label="5.2 HTTP 접근">5.2 HTTP 접근</a></li><li><a href=#53-s3-%ec%a0%91%ea%b7%bc aria-label="5.3 S3 접근">5.3 S3 접근</a></li></ul></li><li><a href=#6-cli-%ec%9c%a0%ed%8b%b8%eb%a6%ac%ed%8b%b0 aria-label="6. CLI 유틸리티">6. CLI 유틸리티</a></li><li><a href=#7-%ec%98%88%ec%a0%9c-sql-%eb%b0%8f-cli-%ec%9b%8c%ed%81%ac%ed%94%8c%eb%a1%9c%ec%9a%b0 aria-label="7. 예제 SQL 및 CLI 워크플로우">7. 예제 SQL 및 CLI 워크플로우</a><ul><li><a href=#%ec%98%88%ec%a0%9c-%eb%8d%b0%ec%9d%b4%ed%84%b0 aria-label="예제 데이터">예제 데이터</a></li><li><a href=#%ec%98%88%ec%a0%9c-%ec%9b%8c%ed%81%ac%ed%94%8c%eb%a1%9c%ec%9a%b0 aria-label="예제 워크플로우">예제 워크플로우</a></li></ul></li><li><a href=#8-%ec%b6%94%ea%b0%80-%ed%8c%81 aria-label="8. 추가 팁">8. 추가 팁</a></li></ul></li></ul></div></details></div><div class=post-content><p>DuckDB CLI 및 SQL CheatSheet - 주요 파일 포맷, DB Attach, HTTP/S3, Excel</p><h2 id=duckdb-cli-및-sql-cheatsheet-가이드>DuckDB CLI 및 SQL CheatSheet 가이드<a hidden class=anchor aria-hidden=true href=#duckdb-cli-및-sql-cheatsheet-가이드>#</a></h2><h3 id=1-duckdb와-clisql-기능-소개>1. DuckDB와 CLI/SQL 기능 소개<a hidden class=anchor aria-hidden=true href=#1-duckdb와-clisql-기능-소개>#</a></h3><p>DuckDB는 고성능 분석 쿼리를 위해 설계된 인-프로세스, 컬럼 지향 OLAP 데이터베이스입니다. CLI와 SQL 인터페이스를 통해 CSV, Parquet, JSON, Excel 등의 파일 포맷을 처리하고, 데이터베이스를 관리하며, HTTP/S3와 같은 웹 기반 스토리지와 통합할 수 있습니다. 이 치트시트는 DuckDB의 CLI와 SQL 명령어를 중심으로 실용적인 예제와 모범 사례를 제공합니다.</p><p><strong>주요 기능</strong>:</p><ul><li><strong>파일 포맷 지원</strong>: CSV, Parquet, JSON, Excel 등을 손쉽게 읽고 쓰기.</li><li><strong>데이터베이스 관리</strong>: 여러 데이터베이스를 연결하고 테이블을 효율적으로 관리.</li><li><strong>웹 통합</strong>: <code>httpfs</code> 확장을 통해 HTTP 또는 S3에서 원격 데이터 접근.</li><li><strong>사용 편의성</strong>: 직관적인 CLI와 SQL 문법으로 빠른 데이터 처리.</li></ul><p>이 가이드는 데이터 엔지니어, 분석가, 개발자가 로컬 및 원격 데이터 워크플로우에 DuckDB를 활용하고자 할 때 유용합니다.</p><h3 id=2-파일-포맷-vs-데이터베이스-작업>2. 파일 포맷 vs. 데이터베이스 작업<a hidden class=anchor aria-hidden=true href=#2-파일-포맷-vs-데이터베이스-작업>#</a></h3><p>DuckDB는 파일 직접 작업과 전통적인 데이터베이스 관리를 모두 지원합니다. 아래 표는 두 접근 방식의 차이를 비교합니다:</p><table><thead><tr><th>기능</th><th>파일 작업</th><th>데이터베이스 작업</th></tr></thead><tbody><tr><td><strong>범위</strong></td><td>CSV, Parquet, JSON, Excel 파일</td><td>영구 DB 파일 (<code>.db</code>)</td></tr><tr><td><strong>접근 방식</strong></td><td>SQL로 직접 읽기/쓰기</td><td>데이터베이스 연결, 테이블 생성 및 쿼리</td></tr><tr><td><strong>사용 사례</strong></td><td>임시 분석, ETL</td><td>구조화된 데이터 저장, 인덱싱</td></tr><tr><td><strong>예제</strong></td><td><code>SELECT * FROM 'file.csv';</code></td><td><code>ATTACH 'mydb.db'; SELECT * FROM mytable;</code></td></tr></tbody></table><p>파일 작업은 빠른 분석에 적합하며, 데이터베이스 작업은 구조화된 영구 저장에 적합합니다. DuckDB는 두 방식 간 전환을 유연하게 지원합니다.</p><h3 id=3-파일-포맷-작업>3. 파일 포맷 작업<a hidden class=anchor aria-hidden=true href=#3-파일-포맷-작업>#</a></h3><p>DuckDB는 <code>read_csv_auto</code>, <code>read_parquet</code>, <code>read_json_auto</code>, 그리고 <code>excel</code> 확장을 통해 CSV, Parquet, JSON, Excel 파일을 지원합니다. 각 포맷에 대한 주요 명령어는 아래와 같습니다.</p><h4 id=31-csv-파일>3.1 CSV 파일<a hidden class=anchor aria-hidden=true href=#31-csv-파일>#</a></h4><ul><li><p><strong>가져오기</strong>:</p><ul><li>CLI:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>duckdb -c <span style=color:#e6db74>&#34;CREATE TABLE mytable AS SELECT * FROM &#39;file.csv&#39;;&#34;</span>
</span></span></code></pre></div></li><li>SQL:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> read_csv_auto(<span style=color:#e6db74>&#39;file.csv&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> mytable <span style=color:#66d9ef>AS</span> <span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> read_csv(<span style=color:#e6db74>&#39;file.csv&#39;</span>, delim<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;,&#39;</span>, header<span style=color:#f92672>=</span><span style=color:#66d9ef>TRUE</span>);
</span></span></code></pre></div></li><li>사용자 정의 스키마:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> read_csv(<span style=color:#e6db74>&#39;file.csv&#39;</span>, columns<span style=color:#f92672>=</span><span style=color:#960050;background-color:#1e0010>{</span><span style=color:#e6db74>&#39;id&#39;</span>: <span style=color:#e6db74>&#39;INTEGER&#39;</span>, <span style=color:#e6db74>&#39;name&#39;</span>: <span style=color:#e6db74>&#39;VARCHAR&#39;</span><span style=color:#960050;background-color:#1e0010>}</span>);
</span></span></code></pre></div></li></ul></li><li><p><strong>헤더 옵션 (<code>header</code>)</strong>:</p><ul><li><code>header=TRUE</code>: 첫 번째 행을 컬럼 이름으로 사용.<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> read_csv(<span style=color:#e6db74>&#39;file.csv&#39;</span>, header<span style=color:#f92672>=</span><span style=color:#66d9ef>TRUE</span>);
</span></span></code></pre></div></li><li><code>header=FALSE</code>: 첫 번째 행을 데이터로 처리, 기본 컬럼 이름 생성 (예: <code>column0</code>, <code>column1</code>).<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> read_csv(<span style=color:#e6db74>&#39;file.csv&#39;</span>, header<span style=color:#f92672>=</span><span style=color:#66d9ef>FALSE</span>);
</span></span></code></pre></div></li><li><code>read_csv_auto</code>는 기본적으로 <code>header=TRUE</code>로 동작하며, 헤더 유무를 자동 감지.<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> read_csv_auto(<span style=color:#e6db74>&#39;file.csv&#39;</span>, header<span style=color:#f92672>=</span><span style=color:#66d9ef>TRUE</span>);
</span></span></code></pre></div></li></ul></li><li><p><strong>내보내기</strong>:</p><ul><li>CLI:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>duckdb -c <span style=color:#e6db74>&#34;COPY mytable TO &#39;output.csv&#39;;&#34;</span>
</span></span></code></pre></div></li><li>SQL:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>COPY</span> mytable <span style=color:#66d9ef>TO</span> <span style=color:#e6db74>&#39;output.csv&#39;</span> (<span style=color:#66d9ef>DELIMITER</span> <span style=color:#e6db74>&#39;,&#39;</span>, HEADER);
</span></span></code></pre></div></li><li>내보내기 시 <code>HEADER</code> 옵션 추가로 컬럼 이름 포함:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>COPY</span> mytable <span style=color:#66d9ef>TO</span> <span style=color:#e6db74>&#39;output.csv&#39;</span> (<span style=color:#66d9ef>DELIMITER</span> <span style=color:#e6db74>&#39;,&#39;</span>, HEADER <span style=color:#66d9ef>TRUE</span>);
</span></span></code></pre></div></li></ul></li><li><p><strong>참고</strong>:</p><ul><li><code>read_csv_auto</code>는 구분자와 스키마를 자동으로 감지.</li><li><code>header</code> 옵션은 데이터의 구조를 명확히 지정할 때 유용.</li><li>압축 파일 지원 (예: <code>file.csv.gz</code>).</li></ul></li></ul><h4 id=32-parquet-파일>3.2 Parquet 파일<a hidden class=anchor aria-hidden=true href=#32-parquet-파일>#</a></h4><ul><li><p><strong>가져오기</strong>:</p><ul><li>CLI:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>duckdb -c <span style=color:#e6db74>&#34;CREATE TABLE mytable AS SELECT * FROM &#39;file.parquet&#39;;&#34;</span>
</span></span></code></pre></div></li><li>SQL:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> read_parquet(<span style=color:#e6db74>&#39;file.parquet&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> mytable <span style=color:#66d9ef>AS</span> <span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> read_parquet(<span style=color:#e6db74>&#39;file.parquet&#39;</span>);
</span></span></code></pre></div></li><li>다중 파일:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> read_parquet([<span style=color:#e6db74>&#39;file1.parquet&#39;</span>, <span style=color:#e6db74>&#39;file2.parquet&#39;</span>]);
</span></span></code></pre></div></li></ul></li><li><p><strong>내보내기</strong>:</p><ul><li>CLI:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>duckdb -c <span style=color:#e6db74>&#34;COPY mytable TO &#39;output.parquet&#39;;&#34;</span>
</span></span></code></pre></div></li><li>SQL:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>COPY</span> mytable <span style=color:#66d9ef>TO</span> <span style=color:#e6db74>&#39;output.parquet&#39;</span> (FORMAT PARQUET);
</span></span></code></pre></div></li></ul></li><li><p><strong>참고</strong>:</p><ul><li>컬럼 지향 저장으로 대규모 데이터에 최적화.</li><li>원격 접근 지원 (HTTP/S3 섹션 참조).</li></ul></li></ul><h5 id=321-duckdb-내장-테이블과-parquet-비교>3.2.1 DuckDB 내장 테이블과 Parquet 비교<a hidden class=anchor aria-hidden=true href=#321-duckdb-내장-테이블과-parquet-비교>#</a></h5><p>DuckDB 내장 테이블은 DuckDB의 독자적인 열 지향 스토리지 형식(예: <code>.duckdb</code> 파일)으로, 데이터 수정 및 트랜잭션을 지원하며 쿼리 실행에 최적화되어 있습니다. 반면, Parquet는 오픈소스 열 지향 파일 형식으로, 높은 압축률과 분산 환경(S3, HDFS) 호환성을 제공하지만 데이터 수정은 불가능합니다.</p><h6 id=주요-차이점><strong>주요 차이점</strong>:<a hidden class=anchor aria-hidden=true href=#주요-차이점>#</a></h6><ul><li><strong>DuckDB 내장 테이블</strong>:<ul><li>메모리 또는 디스크 기반 저장소.</li><li>데이터 수정(INSERT, UPDATE, DELETE) 가능.</li><li>DuckDB 쿼리 엔진에 최적화, 소규모 데이터에서 빠른 읽기/쓰기.</li><li>용도: 데이터 변환, 증분 업데이트, 메모리 내 분석.</li></ul></li><li><strong>Parquet 파일</strong>:<ul><li>높은 압축률로 대규모 데이터에 적합.</li><li>읽기 전용, 수정하려면 새 파일 생성 필요.</li><li>Spark, Pandas 등 외부 도구와의 호환성.</li><li>용도: 데이터 아카이빙, 공유, 분산 저장소.</li></ul></li></ul><h6 id=성능-비교-표><strong>성능 비교 표</strong>:<a hidden class=anchor aria-hidden=true href=#성능-비교-표>#</a></h6><table><thead><tr><th><strong>항목</strong></th><th><strong>DuckDB 내장 테이블</strong></th><th><strong>Parquet 파일</strong></th></tr></thead><tbody><tr><td><strong>읽기 성능</strong></td><td>소규모 데이터 빠름, 쿼리 최적화 우수</td><td>대규모 데이터 유리, 높은 압축률, 메타데이터 활용</td></tr><tr><td><strong>쓰기 성능</strong></td><td>소규모 데이터 빠름, 증분 업데이트 가능</td><td>대규모 데이터 압축으로 디스크 사용량 적음, 쓰기 느림</td></tr><tr><td><strong>데이터 수정</strong></td><td>가능 (INSERT, UPDATE, DELETE)</td><td>불가 (새 파일 덮어쓰기 필요)</td></tr><tr><td><strong>압축률</strong></td><td>중간</td><td>높음 (Snappy, ZSTD 등)</td></tr><tr><td><strong>호환성</strong></td><td>DuckDB 전용</td><td>Spark, Pandas 등 다양한 도구와 호환</td></tr></tbody></table><h6 id=추천-사용-사례><strong>추천 사용 사례</strong>:<a hidden class=anchor aria-hidden=true href=#추천-사용-사례>#</a></h6><ul><li><strong>DuckDB 내장 테이블</strong>: 데이터 수정이 빈번하거나, 메모리 내 분석이 필요한 경우.</li><li><strong>Parquet</strong>: 대규모 데이터 저장, 외부 시스템과의 데이터 공유, S3 같은 분산 환경.</li><li><strong>하이브리드</strong>: Parquet 파일을 DuckDB 테이블로 로드해 분석 (예: <code>CREATE TABLE mytable AS SELECT * FROM read_parquet('file.parquet');</code>).</li></ul><h4 id=33-json-파일>3.3 JSON 파일<a hidden class=anchor aria-hidden=true href=#33-json-파일>#</a></h4><ul><li><p><strong>가져오기</strong>:</p><ul><li>CLI:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>duckdb -c <span style=color:#e6db74>&#34;CREATE TABLE mytable AS SELECT * FROM read_json_auto(&#39;file.json&#39;);&#34;</span>
</span></span></code></pre></div></li><li>SQL:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> read_json_auto(<span style=color:#e6db74>&#39;file.json&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> mytable <span style=color:#66d9ef>AS</span> <span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> read_json(<span style=color:#e6db74>&#39;file.json&#39;</span>, format<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;auto&#39;</span>);
</span></span></code></pre></div></li><li>JSON Lines:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> read_json(<span style=color:#e6db74>&#39;file.jsonl&#39;</span>, lines<span style=color:#f92672>=</span><span style=color:#66d9ef>TRUE</span>);
</span></span></code></pre></div></li></ul></li><li><p><strong>내보내기</strong>:</p><ul><li>CLI:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>duckdb -c <span style=color:#e6db74>&#34;COPY mytable TO &#39;output.json&#39;;&#34;</span>
</span></span></code></pre></div></li><li>SQL:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>COPY</span> mytable <span style=color:#66d9ef>TO</span> <span style=color:#e6db74>&#39;output.json&#39;</span> (FORMAT JSON);
</span></span></code></pre></div></li></ul></li><li><p><strong>참고</strong>:</p><ul><li>중첩 JSON은 <code>unnest</code>로 평탄화 가능.</li><li><code>read_json_auto</code>는 스키마를 자동 추론.</li></ul></li></ul><h4 id=34-excel-파일>3.4 Excel 파일<a hidden class=anchor aria-hidden=true href=#34-excel-파일>#</a></h4><ul><li><p><strong>설정</strong>:</p><ul><li>Excel 파일 처리는 <code>excel</code> 확장이 필요.</li><li>설치 및 로드:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>INSTALL excel;
</span></span><span style=display:flex><span><span style=color:#66d9ef>LOAD</span> excel;
</span></span></code></pre></div></li></ul></li><li><p><strong>가져오기</strong>:</p><ul><li>CLI:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>duckdb -c <span style=color:#e6db74>&#34;CREATE TABLE mytable AS SELECT * FROM read_xlsx(&#39;file.xlsx&#39;);&#34;</span>
</span></span></code></pre></div></li><li>SQL:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> read_xlsx(<span style=color:#e6db74>&#39;file.xlsx&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> mytable <span style=color:#66d9ef>AS</span> <span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> read_xlsx(<span style=color:#e6db74>&#39;file.xlsx&#39;</span>);
</span></span></code></pre></div></li><li>특정 시트 지정:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> read_xlsx(<span style=color:#e6db74>&#39;file.xlsx&#39;</span>, sheet<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;Sheet1&#39;</span>);
</span></span></code></pre></div></li><li>특정 셀 범위 지정:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> read_xlsx(<span style=color:#e6db74>&#39;file.xlsx&#39;</span>, sheet<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;Sheet1&#39;</span>, range<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;A1:C10&#39;</span>);
</span></span></code></pre></div></li></ul></li><li><p><strong>내보내기</strong>:</p><ul><li>CLI:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>duckdb -c <span style=color:#e6db74>&#34;COPY mytable TO &#39;output.xlsx&#39; WITH (FORMAT xlsx);&#34;</span>
</span></span></code></pre></div></li><li>SQL:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>COPY</span> mytable <span style=color:#66d9ef>TO</span> <span style=color:#e6db74>&#39;output.xlsx&#39;</span> <span style=color:#66d9ef>WITH</span> (FORMAT xlsx, SHEET <span style=color:#e6db74>&#39;Sheet1&#39;</span>);
</span></span></code></pre></div></li><li>여러 시트로 내보내기:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>COPY</span> mytable <span style=color:#66d9ef>TO</span> <span style=color:#e6db74>&#39;output.xlsx&#39;</span> <span style=color:#66d9ef>WITH</span> (FORMAT xlsx, SHEET <span style=color:#e6db74>&#39;DataSheet&#39;</span>);
</span></span></code></pre></div></li></ul></li><li><p><strong>참고</strong>:</p><ul><li><code>read_xlsx</code>은 <code>.xlsx</code>, <code>.xls</code> 파일을 지원하며, <code>sheet</code> 또는 <code>range</code> 옵션으로 데이터 범위를 지정할 수 있음.</li><li><code>COPY ... WITH (FORMAT xlsx)</code>을 사용해 Excel 파일로 내보내기 가능.</li><li>복잡한 서식(예: 차트, 매크로)은 지원하지 않음.</li><li>원격 Excel 파일은 HTTP/S3를 통해 접근 가능 (아래 섹션 참조).</li><li>대규모 데이터는 Parquet으로 변환 권장.</li></ul></li></ul><h3 id=4-데이터베이스-작업-및-attach>4. 데이터베이스 작업 및 Attach<a hidden class=anchor aria-hidden=true href=#4-데이터베이스-작업-및-attach>#</a></h3><p>DuckDB는 인-메모리 및 파일 기반 데이터베이스를 지원하며, <code>ATTACH</code> 명령어로 다중 데이터베이스 워크플로우를 구현할 수 있습니다.</p><h4 id=41-데이터베이스-관리>4.1 데이터베이스 관리<a hidden class=anchor aria-hidden=true href=#41-데이터베이스-관리>#</a></h4><ul><li><p><strong>데이터베이스 열기</strong>:</p><ul><li>CLI:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>duckdb mydb.db  <span style=color:#75715e># 파일 기반 DB</span>
</span></span><span style=display:flex><span>duckdb          <span style=color:#75715e># 인-메모리 DB</span>
</span></span></code></pre></div></li><li>SQL:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>ATTACH <span style=color:#66d9ef>DATABASE</span> <span style=color:#e6db74>&#39;mydb.db&#39;</span> <span style=color:#66d9ef>AS</span> mydb;
</span></span><span style=display:flex><span>DETACH <span style=color:#66d9ef>DATABASE</span> mydb;
</span></span></code></pre></div></li></ul></li><li><p><strong>테이블 작업</strong>:</p><ul><li>SQL:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> mytable (id INTEGER, name VARCHAR);
</span></span><span style=display:flex><span><span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>INTO</span> mytable <span style=color:#66d9ef>VALUES</span> (<span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#39;Alice&#39;</span>), (<span style=color:#ae81ff>2</span>, <span style=color:#e6db74>&#39;Bob&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> mytable <span style=color:#66d9ef>WHERE</span> id <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>DROP</span> <span style=color:#66d9ef>TABLE</span> mytable;
</span></span></code></pre></div></li></ul></li><li><p><strong>인덱싱</strong>:</p><ul><li>SQL:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>INDEX</span> idx <span style=color:#66d9ef>ON</span> mytable(id);
</span></span></code></pre></div></li></ul></li></ul><h4 id=42-다중-데이터베이스-쿼리를-위한-attach>4.2 다중 데이터베이스 쿼리를 위한 ATTACH<a hidden class=anchor aria-hidden=true href=#42-다중-데이터베이스-쿼리를-위한-attach>#</a></h4><ul><li><p><strong>단일 데이터베이스</strong>:</p><ul><li>SQL:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>ATTACH <span style=color:#66d9ef>DATABASE</span> <span style=color:#e6db74>&#39;mydb.db&#39;</span> <span style=color:#66d9ef>AS</span> mydb;
</span></span><span style=display:flex><span>USE mydb;
</span></span><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> mytable;
</span></span></code></pre></div></li><li>CLI:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>duckdb -c <span style=color:#e6db74>&#34;ATTACH DATABASE &#39;mydb.db&#39; AS mydb;&#34;</span>
</span></span></code></pre></div></li></ul></li><li><p><strong>다중 데이터베이스</strong>:</p><ul><li>SQL:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>ATTACH <span style=color:#66d9ef>DATABASE</span> <span style=color:#e6db74>&#39;db1.db&#39;</span> <span style=color:#66d9ef>AS</span> db1;
</span></span><span style=display:flex><span>ATTACH <span style=color:#66d9ef>DATABASE</span> <span style=color:#e6db74>&#39;db2.db&#39;</span> <span style=color:#66d9ef>AS</span> db2;
</span></span><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> db1.mytable <span style=color:#66d9ef>JOIN</span> db2.another_table <span style=color:#66d9ef>ON</span> db1.mytable.id <span style=color:#f92672>=</span> db2.another_table.id;
</span></span></code></pre></div></li></ul></li><li><p><strong>참고</strong>:</p><ul><li><code>ATTACH</code>로 여러 데이터베이스 간 쿼리 가능.</li><li>기본 데이터베이스는 <code>main</code>, 추가 데이터베이스는 별칭(예: <code>mydb</code>)으로 구분.</li></ul></li></ul><h3 id=5-http-및-s3-통합>5. HTTP 및 S3 통합<a hidden class=anchor aria-hidden=true href=#5-http-및-s3-통합>#</a></h3><p>DuckDB의 <code>httpfs</code> 확장은 HTTP 또는 S3를 통해 원격 파일에 접근할 수 있게 해주며, 클라우드 기반 워크플로우에 이상적입니다.</p><h4 id=51-설정>5.1 설정<a hidden class=anchor aria-hidden=true href=#51-설정>#</a></h4><ul><li><strong>확장 설치 및 로드</strong>:<ul><li>SQL:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>INSTALL httpfs;
</span></span><span style=display:flex><span><span style=color:#66d9ef>LOAD</span> httpfs;
</span></span></code></pre></div></li><li>CLI:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>duckdb -c <span style=color:#e6db74>&#34;INSTALL httpfs; LOAD httpfs;&#34;</span>
</span></span></code></pre></div></li></ul></li></ul><h4 id=52-http-접근>5.2 HTTP 접근<a hidden class=anchor aria-hidden=true href=#52-http-접근>#</a></h4><ul><li><p><strong>가져오기</strong>:</p><ul><li>SQL:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> read_csv_auto(<span style=color:#e6db74>&#39;https://example.com/data.csv&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> read_parquet(<span style=color:#e6db74>&#39;https://example.com/file.parquet&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> read_xlsx(<span style=color:#e6db74>&#39;https://example.com/file.xlsx&#39;</span>, sheet<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;Sheet1&#39;</span>);
</span></span></code></pre></div></li><li>CLI:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>duckdb -c <span style=color:#e6db74>&#34;SELECT * FROM read_xlsx(&#39;https://example.com/file.xlsx&#39;);&#34;</span>
</span></span></code></pre></div></li></ul></li><li><p><strong>내보내기</strong>:</p><ul><li>SQL:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>COPY</span> mytable <span style=color:#66d9ef>TO</span> <span style=color:#e6db74>&#39;https://example.com/output.xlsx&#39;</span> <span style=color:#66d9ef>WITH</span> (FORMAT xlsx, SHEET <span style=color:#e6db74>&#39;Sheet1&#39;</span>);
</span></span></code></pre></div></li></ul></li></ul><h4 id=53-s3-접근>5.3 S3 접근<a hidden class=anchor aria-hidden=true href=#53-s3-접근>#</a></h4><ul><li><p><strong>자격 증명으로 가져오기</strong>:</p><ul><li>SQL:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SET</span> s3_access_key_id <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;your_access_key&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>SET</span> s3_secret_access_key <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;your_secret_key&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> read_parquet(<span style=color:#e6db74>&#39;s3://bucket/file.parquet&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> read_xlsx(<span style=color:#e6db74>&#39;s3://bucket/file.xlsx&#39;</span>, sheet<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;Sheet1&#39;</span>);
</span></span></code></pre></div></li><li>익명 접근:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> read_parquet(<span style=color:#e6db74>&#39;s3://bucket/public/file.parquet&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> read_xlsx(<span style=color:#e6db74>&#39;s3://bucket/public/file.xlsx&#39;</span>);
</span></span></code></pre></div></li></ul></li><li><p><strong>내보내기</strong>:</p><ul><li>SQL:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>COPY</span> mytable <span style=color:#66d9ef>TO</span> <span style=color:#e6db74>&#39;s3://bucket/output.xlsx&#39;</span> <span style=color:#66d9ef>WITH</span> (FORMAT xlsx, SHEET <span style=color:#e6db74>&#39;Sheet1&#39;</span>);
</span></span></code></pre></div></li></ul></li><li><p><strong>참고</strong>:</p><ul><li>S3 리전 설정: <code>SET s3_region = 'us-east-1';</code>.</li><li><code>httpfs</code>는 HTTP와 S3 프로토콜 모두 지원.</li><li>Excel 파일의 원격 내보내기는 <code>httpfs</code> 확장과 함께 작동.</li></ul></li></ul><h3 id=6-cli-유틸리티>6. CLI 유틸리티<a hidden class=anchor aria-hidden=true href=#6-cli-유틸리티>#</a></h3><p>DuckDB의 CLI는 출력 형식과 실행 옵션을 통해 생산성을 높입니다.</p><ul><li><p><strong>출력 형식</strong>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>.mode box  <span style=color:#75715e># 보기 좋은 테이블 출력</span>
</span></span><span style=display:flex><span>.mode csv  <span style=color:#75715e># CSV 출력</span>
</span></span></code></pre></div></li><li><p><strong>쿼리 실행</strong>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>duckdb -c <span style=color:#e6db74>&#34;SELECT * FROM &#39;file.csv&#39;;&#34;</span>  <span style=color:#75715e># 단일 쿼리</span>
</span></span><span style=display:flex><span>duckdb &lt; query.sql                    <span style=color:#75715e># SQL 파일 실행</span>
</span></span></code></pre></div></li><li><p><strong>기타 명령어</strong>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>.open mydb.db  <span style=color:#75715e># DB 열기</span>
</span></span><span style=display:flex><span>.help          <span style=color:#75715e># 도움말 보기</span>
</span></span><span style=display:flex><span>.exit          <span style=color:#75715e># 종료</span>
</span></span></code></pre></div></li></ul><h3 id=7-예제-sql-및-cli-워크플로우>7. 예제 SQL 및 CLI 워크플로우<a hidden class=anchor aria-hidden=true href=#7-예제-sql-및-cli-워크플로우>#</a></h3><p>아래는 실제 데이터 처리 시나리오를 보여주는 예제입니다.</p><h4 id=예제-데이터>예제 데이터<a hidden class=anchor aria-hidden=true href=#예제-데이터>#</a></h4><ul><li><strong>로컬 CSV 파일</strong>: <code>users.csv</code> (id, name 컬럼, 헤더 포함).</li><li><strong>로컬 Excel 파일</strong>: <code>sales.xlsx</code> (Sheet1에 데이터 포함).</li><li><strong>원격 Parquet 파일</strong>: <code>s3://bucket/data.parquet</code>.</li><li><strong>데이터베이스</strong>: <code>mydb.db</code>.</li></ul><h4 id=예제-워크플로우>예제 워크플로우<a hidden class=anchor aria-hidden=true href=#예제-워크플로우>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># CLI로 DuckDB 실행 및 확장 로드</span>
</span></span><span style=display:flex><span>duckdb
</span></span><span style=display:flex><span>&gt; INSTALL httpfs; LOAD httpfs;
</span></span><span style=display:flex><span>&gt; INSTALL excel; LOAD excel;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 로컬 CSV에서 테이블 생성 (헤더 포함)</span>
</span></span><span style=display:flex><span>&gt; CREATE TABLE users AS SELECT * FROM read_csv_auto<span style=color:#f92672>(</span><span style=color:#e6db74>&#39;users.csv&#39;</span>, header<span style=color:#f92672>=</span>TRUE<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 로컬 Excel 파일에서 데이터 가져오기</span>
</span></span><span style=display:flex><span>&gt; CREATE TABLE sales AS SELECT * FROM read_xlsx<span style=color:#f92672>(</span><span style=color:#e6db74>&#39;sales.xlsx&#39;</span>, sheet<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;Sheet1&#39;</span><span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 원격 Parquet 데이터 쿼리</span>
</span></span><span style=display:flex><span>&gt; SELECT * FROM read_parquet<span style=color:#f92672>(</span><span style=color:#e6db74>&#39;s3://bucket/data.parquet&#39;</span><span style=color:#f92672>)</span> LIMIT 5;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 데이터베이스 연결 및 데이터 삽입</span>
</span></span><span style=display:flex><span>&gt; ATTACH DATABASE <span style=color:#e6db74>&#39;mydb.db&#39;</span> AS mydb;
</span></span><span style=display:flex><span>&gt; INSERT INTO mydb.users SELECT * FROM users;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 다중 DB 쿼리</span>
</span></span><span style=display:flex><span>&gt; ATTACH DATABASE <span style=color:#e6db74>&#39;db2.db&#39;</span> AS db2;
</span></span><span style=display:flex><span>&gt; SELECT u.name FROM mydb.users u JOIN db2.orders o ON u.id <span style=color:#f92672>=</span> o.user_id;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 결과 내보내기 (Excel 파일)</span>
</span></span><span style=display:flex><span>&gt; COPY users TO <span style=color:#e6db74>&#39;output.xlsx&#39;</span> WITH <span style=color:#f92672>(</span>FORMAT xlsx, SHEET <span style=color:#e6db74>&#39;Users&#39;</span><span style=color:#f92672>)</span>;
</span></span></code></pre></div><p>이 워크플로우는 로컬 및 원격 데이터를 통합하고, 다중 데이터베이스 쿼리를 실행하며, 결과를 다양한 포맷(특히 Excel)으로 내보내는 과정을 보여줍니다.</p><h3 id=8-추가-팁>8. 추가 팁<a hidden class=anchor aria-hidden=true href=#8-추가-팁>#</a></h3><ul><li><p><strong>쿼리 최적화</strong>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>EXPLAIN</span> <span style=color:#66d9ef>ANALYZE</span> <span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> mytable;  <span style=color:#f92672>#</span> <span style=color:#960050;background-color:#1e0010>실행</span> <span style=color:#960050;background-color:#1e0010>계획</span> <span style=color:#960050;background-color:#1e0010>분석</span>
</span></span><span style=display:flex><span>SUMMARIZE mytable;                     <span style=color:#f92672>#</span> <span style=color:#960050;background-color:#1e0010>데이터</span> <span style=color:#960050;background-color:#1e0010>요약</span>
</span></span></code></pre></div></li><li><p><strong>다중 포맷 통합</strong>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> read_csv_auto(<span style=color:#e6db74>&#39;file.csv&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>UNION</span> <span style=color:#66d9ef>ALL</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> read_parquet(<span style=color:#e6db74>&#39;file.parquet&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>UNION</span> <span style=color:#66d9ef>ALL</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> read_xlsx(<span style=color:#e6db74>&#39;file.xlsx&#39;</span>, sheet<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;Sheet1&#39;</span>);
</span></span></code></pre></div></li><li><p><strong>로컬 및 원격 혼합</strong>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> read_csv_auto(<span style=color:#e6db74>&#39;https://example.com/data.csv&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>UNION</span> <span style=color:#66d9ef>ALL</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> read_xlsx(<span style=color:#e6db74>&#39;https://example.com/file.xlsx&#39;</span>, sheet<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;Sheet1&#39;</span>);
</span></span></code></pre></div></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://cdecl.github.io/tags/duckdb/>Duckdb</a></li><li><a href=https://cdecl.github.io/tags/sql/>Sql</a></li><li><a href=https://cdecl.github.io/tags/cli/>Cli</a></li><li><a href=https://cdecl.github.io/tags/csv/>Csv</a></li><li><a href=https://cdecl.github.io/tags/parquet/>Parquet</a></li><li><a href=https://cdecl.github.io/tags/json/>Json</a></li><li><a href=https://cdecl.github.io/tags/excel/>Excel</a></li><li><a href=https://cdecl.github.io/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/>데이터베이스</a></li><li><a href=https://cdecl.github.io/tags/http/>Http</a></li><li><a href=https://cdecl.github.io/tags/s3/>S3</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://cdecl.github.io/>cdeclog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>