<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Devops | cdeclog</title><meta name=keywords content><meta name=description content="Devops - cdeclog"><meta name=author content="Byung Kyu KIM"><link rel=canonical href=https://cdecl.github.io/devops/><link crossorigin=anonymous href=/assets/css/stylesheet.f939c4ffefb264e6fe85e04352266f79db6bb1303c8e16ae9b6064c1247b5e32.css integrity="sha256-+TnE/++yZOb+heBDUiZvedtrsTA8jhaum2BkwSR7XjI=" rel="preload stylesheet" as=style><link rel=icon href=https://cdecl.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://cdecl.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://cdecl.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://cdecl.github.io/apple-touch-icon.png><link rel=mask-icon href=https://cdecl.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://cdecl.github.io/devops/index.xml title=rss><link rel=alternate hreflang=en href=https://cdecl.github.io/devops/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-VQQHHYPN7K"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VQQHHYPN7K")}</script><meta property="og:url" content="https://cdecl.github.io/devops/"><meta property="og:site_name" content="cdeclog"><meta property="og:title" content="Devops"><meta property="og:description" content="cdecl's Dev.Ops Blog"><meta property="og:locale" content="ko-kr"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Devops"><meta name=twitter:description content="cdecl's Dev.Ops Blog"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Devops","item":"https://cdecl.github.io/devops/"}]}</script></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://cdecl.github.io/ accesskey=h title="cdeclog (Alt + H)">cdeclog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://cdecl.github.io/dev/ title=Dev><span>Dev</span></a></li><li><a href=https://cdecl.github.io/devops/ title=DevOps><span class=active>DevOps</span></a></li><li><a href=https://cdecl.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://cdecl.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://cdecl.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://cdecl.github.io/>Home</a></div><h1>Devops</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>AI 에이전트(OpenClaw 등)의 LLM 인터페이스 구현 및 툴 콜링 기술 개요</h2></header><div class=entry-content><p>OpenClaw, Claude 데스크톱 앱, 혹은 로컬 기반의 여러 AI 에이전트들은 내부적으로 LLM(대형 언어 모델)과 어떻게 소통하고, 로컬 환경의 도구(Tool)들을 사용할까요? 이 글에서는 에이전트가 LLM과 인터페이스를 맺는 기술적 구현 내용과 핵심 요소들을 살펴봅니다.
1. 지침 파일(agent.md 등) 적용 방법 AI 에이전트의 페르소나, 역할, 기본 규칙을 정의하기 위해 주로 .md 형태의 지침 파일을 사용합니다. (예: agent.md, system_prompt.txt, SOUL.md 등)
기술적 구현: 이러한 지침 파일은 LLM에 전달되는 **시스템 프롬프트(System Prompt)**로 로드됩니다. 에이전트 프로그램이 실행될 때 혹은 세션이 시작될 때 파일 시스템에서 문서를 읽어 LLM의 system 역할(role) 메시지에 주입합니다.
...</p></div><footer class=entry-footer><span title='2026-02-21 00:00:00 +0900 KST'>February 21, 2026</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to AI 에이전트(OpenClaw 등)의 LLM 인터페이스 구현 및 툴 콜링 기술 개요" href=https://cdecl.github.io/devops/ai-agent-openclaw-llm-interface/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>OpenClaw 용어집 및 운영 지침 가이드</h2></header><div class=entry-content><p>OpenClaw(ClawdBot 기반)는 개인 AI 에이전트를 메시징 채널과 연결해 운영하는 게이트웨이 중심 프레임워크입니다. 이 문서는 용어를 사람 친화적으로 정리하고, 운영 시 바로 적용할 수 있는 체크리스트와 최신 변경 사항(공식 소스 기준)까지 함께 제공합니다.
개요 문서 목적: 용어 설명 + 운영 지침 통합 가이드 최신 정보 범위: 공식 문서와 공식 릴리스만 사용 최신 반영 기준: GitHub Release v2026.2.15 (게시일: 2026-02-16) docs.openclaw.ai의 공식 업데이트 문서 핵심 개념 (단순 설명) Gateway (게이트웨이) 모든 메신저(WhatsApp, Telegram, Discord 등)와 에이전트를 연결해 주는 중앙 서버/데몬. 기본 포트: 18789 (WebSocket). 한 개의 Gateway로 여러 채널과 여러 에이전트를 동시에 관리 가능. Agent (에이전트) AI 어시스턴트의 “뇌"에 해당. 개별 성격, 메모리, 행동 방식을 가짐. 각 Agent는 격리된 상태(workspace, auth, sessions)를 유지. 기본 에이전트 이름: main. Workspace (작업 폴더) Agent의 “개인 폴더"로, 기본 경로: ~/.openclaw/workspace. 주요 파일: AGENTS.md: 동작 지시, 규칙, 메모리. SOUL.md: 성격, 말투, 경계. USER.md: 사용자 정보와 호칭. TOOLS.md: 사용 가능한 도구/툴 설명. BOOTSTRAP.md: 최초 실행 설정(한 번 실행 후 삭제). memory/YYYY-MM-DD.md: 일일 메모리 로그. Agent Directory (agentDir) 에이전트의 기술 설정/인증 정보를 저장. 기본 경로: ~/.openclaw/agents/&lt;agentId>/agent. 주요 파일: auth-profiles.json: 모델 제공자(Anthropic, OpenAI 등) 인증 정보. 에이전트별 모델 설정/구조 파일. 통신 구조 Channel (채널) 메신저 연결 단위. 예: WhatsApp, Telegram, Discord 각각 하나의 관(pipe). Account ID (accountId) 같은 채널 내 여러 계정을 구분. 예: 개인 WhatsApp, 업무용 WhatsApp. Session Key (sessionKey) 대화 스레드를 구분하는 고유 이름/주소. 예: agent:main:main (기본 1:1 대화) agent:main:telegram:group:123 (그룹 대화) Session ID (sessionId) 실제 대화 기록 파일 ID. 경로 예: ~/.openclaw/agents/&lt;agentId>/sessions/&lt;sessionId>.jsonl. 세션 재설정 시 값이 바뀜. Binding (바인딩) 라우팅 규칙. 어떤 채널/계정/연락처에서 온 메시지를 어떤 Agent로 보낼지 결정. 가장 구체적인 규칙이 우선 적용. 세션 관리 Main Session (기본 대화) 기본 1:1 대화 세션. 예: agent:&lt;agentId>:main. 모든 개인 대화를 한 세션으로 모아 유지할 수 있음. DM Scope (dmScope) DM(1:1) 분리 수준 설정. main: 모든 DM 공유 per-peer: 사용자별 분리 per-channel-peer: 채널+사용자별 분리 per-account-channel-peer: 계정+채널+사용자별 최대 분리 Session Reset (초기화) 새 대화를 시작할 때 sessionId를 새로 생성. 방법: 수동: openclaw new, openclaw reset 자동: 지정 시각(예: 매일 04:00), 비활성 시간 기준 자동 리셋 Compaction (압축/요약) 긴 대화를 요약해 컨텍스트 한도 초과를 방지. 핵심 맥락은 남기고 오래된 상세를 정리. Memory Flush (메모리 저장) Compaction 전에 중요한 정보를 영구 메모리로 기록. memory/YYYY-MM-DD.md에 저장. NO_REPLY 내부 메시지로 사용자 노출 없이 처리 가능. 접근 제어 / 보안 Pairing (페어링) 새 노드(장치) 연결 시 승인 절차. 로컬(127.0.0.1)은 자동 승인 옵션 가능. 승인 후 토큰 발급으로 접근 허용. DM Policy (dmPolicy) DM 허용 범위 제어. open: 누구나 가능(위험) pairing: 승인 사용자만 allowlist: 허용 목록만 Allow From (allowFrom) 허용 번호/ID 목록. 예: +15555550123 Group Policy (groupPolicy) 그룹 참여 범위 제어. open: 모든 그룹(권장하지 않음) allowlist: 허용 그룹만 denylist: 차단 목록 제외 Require Mention 그룹에서 @멘션이 있을 때만 응답. 불필요 응답/스팸 방지에 유효. Gateway Token (OPENCLAW_GATEWAY_TOKEN) Gateway 접속용 공유 비밀. WebSocket 인증에 사용. Sandbox (샌드박스) 도구 실행 격리(도커 기반). 모드: off: 비격리(전체 시스템 접근) non-main: 메인 세션만 비격리 all: 모든 세션 격리 스코프: session, agent, shared 주의
...</p></div><footer class=entry-footer><span title='2026-02-17 00:00:00 +0900 KST'>February 17, 2026</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to OpenClaw 용어집 및 운영 지침 가이드" href=https://cdecl.github.io/devops/openclaw-glossary-operation-guidelines/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>127.0.0.1 vs localhost: 차이와 함정</h2></header><div class=entry-content><p>작성일: 2026-02-08
운영 환경에서 “localhost로 붙었는데 왜 안 되지?” 같은 문제는 자주 발생합니다. 결론부터 말하면 127.0.0.1과 localhost는 보통 같은 의미로 쓰이지만, 항상 동일하게 해석되진 않습니다. 이 미묘한 차이가 헬스체크 실패, 접근 불가, 보안 정책 충돌로 이어질 수 있습니다.
1. 루프백(Loopback) 정의 루프백은 자기 자신에게 되돌아오는 네트워크 경로입니다. 물리 NIC 없이도 TCP/IP 스택을 테스트하거나 로컬 프로세스 간 통신을 가능하게 합니다.
IPv4 루프백 대역: 127.0.0.0/8 (대표 주소가 127.0.0.1) IPv6 루프백 주소: ::1 즉, 127.0.0.1은 항상 이 머신 자신을 의미합니다. DNS나 이름 해석 과정과는 무관합니다.
...</p></div><footer class=entry-footer><span title='2026-02-08 00:00:00 +0900 KST'>February 8, 2026</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to 127.0.0.1 vs localhost: 차이와 함정" href=https://cdecl.github.io/devops/localhost/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>SSH 리버스 프록시(Reverse Proxy) 네트워크 구성: 설정, 주의 사항, 운영 팁</h2></header><div class=entry-content><p>작성일: 2026-02-08
SSH 리버스 프록시는 외부에서 내부로 직접 접근할 수 없는 환경에서 유용한 연결 방식입니다. 내부 서버가 외부 서버로 역방향 터널을 먼저 열어두고, 외부 사용자가 그 터널을 통해 내부 서비스에 접근하는 구조입니다. DevOps 환경에서 운영할 때 필요한 구성, 주의 사항, 네트워크 프록시 관점을 정리합니다.
1. 개념 정리: SSH 리버스 프록시 일반 SSH 포워딩(로컬 포워딩): 로컬 -> 원격 리버스 포워딩(Reverse): 원격 -> 로컬(내부) 리버스 포워딩은 내부 서버가 먼저 외부(중계) 서버에 접속하고, 외부에서 그 연결을 통해 내부 서비스에 접근하는 방식입니다.
...</p></div><footer class=entry-footer><span title='2026-02-08 00:00:00 +0900 KST'>February 8, 2026</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to SSH 리버스 프록시(Reverse Proxy) 네트워크 구성: 설정, 주의 사항, 운영 팁" href=https://cdecl.github.io/devops/ssh-reverse-proxy-guide/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Lazygit 가이드: 설치부터 패널별 치트시트</h2></header><div class=entry-content><p>Git은 강력하지만 명령어 입력 방식은 때로 직관성이 떨어집니다. 특히 수많은 파일을 개별적으로 스테이징하거나 복잡한 인터랙티브 리베이스를 수행할 때 터미널 UI(TUI) 도구의 진가가 드러납니다. 그중에서도 가장 완성도 높은 도구인 Lazygit을 파헤쳐 봅니다.
1. Lazygit 설치 (Installation) 환경에 맞는 패키지 매니저를 사용하여 간단히 설치할 수 있습니다.
macOS brew install lazygit Windows # Scoop 사용 시 scoop bucket add extras scoop install lazygit # Winget 사용 시 winget install jesseduffield.lazygit Linux (Ubuntu/Debian 등) # 바이너리 직접 설치 예시 LAZYGIT_VERSION=$(curl -s "https://api.github.com/repos/jesseduffield/lazygit/releases/latest" | grep -Po '"tag_name": "v\K[^"]*') curl -Lo lazygit.tar.gz "https://github.com/jesseduffield/lazygit/releases/latest/download/lazygit_${LAZYGIT_VERSION}_Linux_x86_64.tar.gz" tar xf lazygit.tar.gz lazygit sudo install lazygit /usr/local/bin 2. TUI 구성 및 레이아웃 (Layout) Lazygit는 한 화면에서 Git의 모든 상태를 조망할 수 있는 대시보드형 레이아웃을 가지고 있습니다.
...</p></div><footer class=entry-footer><span title='2026-02-04 00:00:00 +0900 KST'>February 4, 2026</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to Lazygit 가이드: 설치부터 패널별 치트시트" href=https://cdecl.github.io/devops/lazygit-guide/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>macOS 시스템 최적화의 종결자: Mole 유틸리티와 Agent Skills 활용기</h2></header><div class=entry-content><p>서론 유료 앱들의 핵심 기능을 단 하나의 바이너리로 통합한 강력한 오픈소스 CLI 도구, Mole을 소개. 특히 최근 유행하는 AI Agent와 연계하여 시스템 관리를 자동화하는 방법까지 함께 살펴보겠습니다.
1. Mole 유틸리티란? Mole(tw93/Mole)은 tw93이 개발한 macOS용 올인원 시스템 유틸리티다. Go 언어와 셸 스크립트로 작성되어 매우 가볍고 빠르며, 터미널 환경에서 모든 시스템 최적화 작업을 통합 관리할 수 있다.
주요 특징 All-in-One: 청소, 앱 삭제, 최적화, 분석, 실시간 모니터링 기능을 단일 바이너리로 통합. 오픈소스: MIT 라이선스 기반의 무료 도구로, 상업용 앱의 광고나 구독 모델 없이 모든 기능 제공. 초경량: CLI 기반으로 동작하여 시스템 리소스 점유율이 매우 낮음. 2. 설치 방법 Homebrew를 통해 간단히 설치 가능하다.
...</p></div><footer class=entry-footer><span title='2026-01-29 00:00:00 +0900 KST'>January 29, 2026</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to macOS 시스템 최적화의 종결자: Mole 유틸리티와 Agent Skills 활용기" href=https://cdecl.github.io/devops/mole-utility-guide/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>OpenClaw (구 Clawdbot): 로컬 중심의 개인용 AI 런타임 심층 분석</h2></header><div class=entry-content><p>공지: Clawdbot은 OpenClaw로 리브랜딩되었습니다. 이 문서는 기존 Clawdbot의 개념과 함께 새로운 OpenClaw의 관점에서 내용을 보강하고 있습니다.
**OpenClaw (구 Clawdbot)**은 본격적으로 로컬에서 실행되는 AI 런타임이다. 클라우드 기반 서비스와 달리, 사용자의 컴퓨터(Mac/Linux)에서 백그라운드 데몬으로 동작하며 로컬 데이터만을 활용한다. 사용자에게는 터미널, 파일시스템, 브라우저 컨트롤 같은 OS 리소스가 직관적으로 노출된다.
1. OpenClaw (구 Clawdbot)란? OpenClaw은 Node.js 기반으로 구현된 로컬 AI 런타임이다. 클라우드에 의존하지 않고, 사용자의 개인 환경에서 실행되므로 데이터 유출 위험이 최소화된다. 주요 특징은 다음과 같다.
...</p></div><footer class=entry-footer><span title='2026-01-29 00:00:00 +0900 KST'>January 29, 2026</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to OpenClaw (구 Clawdbot): 로컬 중심의 개인용 AI 런타임 심층 분석" href=https://cdecl.github.io/devops/clawdbot-deep-dive/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Gemini CLI와 Antigravity에서 antigravity-awesome-skills로 Agent Skills 강화하기</h2></header><div class=entry-content><p>서론 AI 에이전트의 능력을 한 단계 더 끌어올릴 수 있는 “Agent Skills"를 활용
이 글에서는 antigravity-awesome-skills라는 훌륭한 오픈소스 스킬셋을 Gemini CLI 및 Antigravity 환경에 설치하고, 적용하며, 테스트하는 방법과 유용한 스킬 예제 13가지를 소개합니다.
1. Antigravity Awesome Skills란 무엇인가? “Agent Skills"는 AI 에이전트에게 특정 작업을 수행하는 방법을 알려주는 작은 마크다운 파일 형식의 지침서입니다. 예를 들어, “API 문서를 작성해줘"라는 막연한 요청 대신, @api-documentation 스킬을 사용하여 정형화되고 일관된 형식의 문서를 생성하도록 지시할 수 있습니다.
...</p></div><footer class=entry-footer><span title='2026-01-25 00:00:00 +0900 KST'>January 25, 2026</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to Gemini CLI와 Antigravity에서 antigravity-awesome-skills로 Agent Skills 강화하기" href=https://cdecl.github.io/devops/agent-skills-antigravity-gemini-guide/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Agent Skill 가이드: AI 에이전트의 전문성을 위한 모듈식 아키텍처</h2></header><div class=entry-content><p>Claude Code나 Gemini CLI를 사용해본 개발자라면 이런 경험을 했을 겁니다: 특정 도메인의 작업을 할 때 에이전트가 너무 일반적으로만 접근한다는 것입니다. 이것이 바로 Agent Skill이 필요한 이유입니다.
1. Agent Skill이란? Agent Skill은 특정 도메인의 전문 지식을 패키징한 재사용 가능한 모듈입니다. 2025년 Anthropic이 정식으로 도입한 이 기술은 에이전트에게 단순한 명령이 아닌 진정한 전문성을 제공합니다.
더 정확히는:
구조: SKILL.md 파일과 지침, 스크립트, 참고 자료를 포함하는 폴더 작동: 에이전트가 관련성을 감지하면 자동으로 해당 Skill을 활성화하여 그 분야의 전문가처럼 행동 핵심 원리: 필요한 정보만 필요한 시점에 로드하는 Progressive Disclosure 일반 LLM은 비결정성 특성으로 같은 작업을 반복해도 결과가 달라질 수 있습니다. Agent Skill은 구조화된 절차와 리소스를 제공하여 이를 개선합니다.
...</p></div><footer class=entry-footer><span title='2026-01-20 00:00:00 +0900 KST'>January 20, 2026</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to Agent Skill 가이드: AI 에이전트의 전문성을 위한 모듈식 아키텍처" href=https://cdecl.github.io/devops/agent-skill-complete-guide/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>OpenCode: AI 코딩 에이전트 가이드</h2></header><div class=entry-content><p>OpenCode는 터미널 기반의 오픈소스 AI 코딩 에이전트로, 개발 생산성 향상을 목표로 합니다. LSP(Language Server Pro
OpenCode 핵심 기능 LSP (Language Server Protocol) LSP 서버란? LSP 자동 로드 OpenCode는 프로젝트를 열 때 .lsproj 파일이나 언어별 설정 파일을 자동으로 스캔하여 해당 프로젝트에 적합한 LSP 서버를 감지하고 설치 및 실행합니다. 예를 들어, TypeScript 프로젝트에서는 자동으로 TypeScript Language Server를 활성화합니다. 이 기능 덕분에 개발자는 별도의 수동 설정 없이 즉시 언어 서비스를 활용할 수 있으며, 에이전트는 LSP 서버와 통신하며 코드 분석, 편집, 리팩토링 등을 지원합니다.
...</p></div><footer class=entry-footer><span title='2026-01-12 00:00:00 +0900 KST'>January 12, 2026</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to OpenCode: AI 코딩 에이전트 가이드" href=https://cdecl.github.io/devops/opencode-ai-agent/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://cdecl.github.io/devops/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2026 <a href=https://cdecl.github.io/>cdeclog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>