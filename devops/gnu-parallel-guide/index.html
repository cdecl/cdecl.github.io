<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>GNU Parallel: xargs를 넘어선 강력한 병렬 처리 | cdeclog</title><meta name=keywords content="linux,shell,parallel,performance"><meta name=description content="리눅스 환경에서 대량의 데이터나 파일을 처리하다 보면, 단일 코어만 사용하는 쉘 스크립트의 성능 한계에 부딪히게 됩니다. xargs를 통해 어느 정도 병렬 처리가 가능하지만, 더 복잡하고 강력한 기능을 제공하는 도구가 바로 GNU Parallel입니다.
🚀 parallel 개요
GNU Parallel은 로컬 또는 원격 컴퓨터에서 작업을 병렬로 실행하기 위한 쉘 도구입니다. 덴마크의 Ole Tange가 Perl로 개발했으며, 표준 입력(stdin)이나 파일로부터 인자를 받아 명령어를 병렬로 실행합니다.
가장 큰 특징은 xargs나 find -exec와 같은 기존 도구들의 사용성을 유지하면서도, 출력 제어, 작업 슬롯 관리, 원격 실행 등 고급 기능을 제공한다는 점입니다."><meta name=author content="Byung Kyu KIM"><link rel=canonical href=https://cdecl.github.io/devops/gnu-parallel-guide/><link crossorigin=anonymous href=/assets/css/stylesheet.f939c4ffefb264e6fe85e04352266f79db6bb1303c8e16ae9b6064c1247b5e32.css integrity="sha256-+TnE/++yZOb+heBDUiZvedtrsTA8jhaum2BkwSR7XjI=" rel="preload stylesheet" as=style><link rel=icon href=https://cdecl.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://cdecl.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://cdecl.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://cdecl.github.io/apple-touch-icon.png><link rel=mask-icon href=https://cdecl.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://cdecl.github.io/devops/gnu-parallel-guide/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-VQQHHYPN7K"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VQQHHYPN7K")}</script><meta property="og:url" content="https://cdecl.github.io/devops/gnu-parallel-guide/"><meta property="og:site_name" content="cdeclog"><meta property="og:title" content="GNU Parallel: xargs를 넘어선 강력한 병렬 처리"><meta property="og:description" content="리눅스 환경에서 대량의 데이터나 파일을 처리하다 보면, 단일 코어만 사용하는 쉘 스크립트의 성능 한계에 부딪히게 됩니다. xargs를 통해 어느 정도 병렬 처리가 가능하지만, 더 복잡하고 강력한 기능을 제공하는 도구가 바로 GNU Parallel입니다.
🚀 parallel 개요 GNU Parallel은 로컬 또는 원격 컴퓨터에서 작업을 병렬로 실행하기 위한 쉘 도구입니다. 덴마크의 Ole Tange가 Perl로 개발했으며, 표준 입력(stdin)이나 파일로부터 인자를 받아 명령어를 병렬로 실행합니다.
가장 큰 특징은 xargs나 find -exec와 같은 기존 도구들의 사용성을 유지하면서도, 출력 제어, 작업 슬롯 관리, 원격 실행 등 고급 기능을 제공한다는 점입니다."><meta property="og:locale" content="ko-kr"><meta property="og:type" content="article"><meta property="article:section" content="devops"><meta property="article:published_time" content="2025-11-23T00:00:00+09:00"><meta property="article:modified_time" content="2025-11-23T00:00:00+09:00"><meta property="article:tag" content="Linux"><meta property="article:tag" content="Shell"><meta property="article:tag" content="Parallel"><meta property="article:tag" content="Performance"><meta name=twitter:card content="summary"><meta name=twitter:title content="GNU Parallel: xargs를 넘어선 강력한 병렬 처리"><meta name=twitter:description content="리눅스 환경에서 대량의 데이터나 파일을 처리하다 보면, 단일 코어만 사용하는 쉘 스크립트의 성능 한계에 부딪히게 됩니다. xargs를 통해 어느 정도 병렬 처리가 가능하지만, 더 복잡하고 강력한 기능을 제공하는 도구가 바로 GNU Parallel입니다.
🚀 parallel 개요
GNU Parallel은 로컬 또는 원격 컴퓨터에서 작업을 병렬로 실행하기 위한 쉘 도구입니다. 덴마크의 Ole Tange가 Perl로 개발했으며, 표준 입력(stdin)이나 파일로부터 인자를 받아 명령어를 병렬로 실행합니다.
가장 큰 특징은 xargs나 find -exec와 같은 기존 도구들의 사용성을 유지하면서도, 출력 제어, 작업 슬롯 관리, 원격 실행 등 고급 기능을 제공한다는 점입니다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Devops","item":"https://cdecl.github.io/devops/"},{"@type":"ListItem","position":2,"name":"GNU Parallel: xargs를 넘어선 강력한 병렬 처리","item":"https://cdecl.github.io/devops/gnu-parallel-guide/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"GNU Parallel: xargs를 넘어선 강력한 병렬 처리","name":"GNU Parallel: xargs를 넘어선 강력한 병렬 처리","description":"리눅스 환경에서 대량의 데이터나 파일을 처리하다 보면, 단일 코어만 사용하는 쉘 스크립트의 성능 한계에 부딪히게 됩니다. xargs를 통해 어느 정도 병렬 처리가 가능하지만, 더 복잡하고 강력한 기능을 제공하는 도구가 바로 GNU Parallel입니다.\n🚀 parallel 개요 GNU Parallel은 로컬 또는 원격 컴퓨터에서 작업을 병렬로 실행하기 위한 쉘 도구입니다. 덴마크의 Ole Tange가 Perl로 개발했으며, 표준 입력(stdin)이나 파일로부터 인자를 받아 명령어를 병렬로 실행합니다.\n가장 큰 특징은 xargs나 find -exec와 같은 기존 도구들의 사용성을 유지하면서도, 출력 제어, 작업 슬롯 관리, 원격 실행 등 고급 기능을 제공한다는 점입니다.\n","keywords":["linux","shell","parallel","performance"],"articleBody":"리눅스 환경에서 대량의 데이터나 파일을 처리하다 보면, 단일 코어만 사용하는 쉘 스크립트의 성능 한계에 부딪히게 됩니다. xargs를 통해 어느 정도 병렬 처리가 가능하지만, 더 복잡하고 강력한 기능을 제공하는 도구가 바로 GNU Parallel입니다.\n🚀 parallel 개요 GNU Parallel은 로컬 또는 원격 컴퓨터에서 작업을 병렬로 실행하기 위한 쉘 도구입니다. 덴마크의 Ole Tange가 Perl로 개발했으며, 표준 입력(stdin)이나 파일로부터 인자를 받아 명령어를 병렬로 실행합니다.\n가장 큰 특징은 xargs나 find -exec와 같은 기존 도구들의 사용성을 유지하면서도, 출력 제어, 작업 슬롯 관리, 원격 실행 등 고급 기능을 제공한다는 점입니다.\n⚙️ 주요 기능 및 내부 구현 1. 출력 그룹화 (Output Grouping) 병렬 처리 시 가장 큰 골칫거리 중 하나는 여러 프로세스의 출력이 뒤섞이는 것입니다.\nxargs -P를 사용하면 여러 줄의 출력이 섞여서 알아보기 힘든 경우가 많습니다. Parallel은 각 작업의 출력을 임시 파일이나 메모리에 버퍼링했다가, 작업이 완료되는 순간 한꺼번에 출력합니다. 따라서 출력이 섞이지 않고 깔끔하게 보장됩니다. 2. 지능적인 작업 슬롯 관리 parallel은 기본적으로 시스템의 CPU 코어 수를 감지하여 최적의 병렬 작업 수(Job slot)를 결정합니다. --load 옵션을 통해 시스템 부하(Load Average)에 따라 새로운 작업을 시작할지 대기할지 동적으로 결정할 수도 있습니다. 3. 강력한 인자 치환 (Replacement Strings) xargs보다 훨씬 유연한 인자 치환 기능을 제공합니다.\n{}: 전체 인자 (기본값) {.}: 확장자를 제외한 파일명 (file.txt -\u003e file) {/}: 경로를 제외한 파일명 (Basename, dir/file.txt -\u003e file.txt) {//}: 파일명을 제외한 경로 (Dirname, dir/file.txt -\u003e dir) {/.}: 경로와 확장자를 모두 제외한 순수 파일명 (dir/file.txt -\u003e file) {#}: 작업의 시퀀스 번호 (1부터 시작) {%}: 작업 슬롯 번호 (1 ~ 병렬 작업 수) {n}: n번째 입력 소스의 인자 (예: {1}, {2} - ::: 또는 :::: 사용 시) 4. Perl 기반 구현 GNU Parallel은 단일 Perl 스크립트로 구현되어 있습니다. 이는 별도의 컴파일 과정 없이 Perl이 설치된 대부분의 유닉스/리눅스 시스템에서 즉시 사용할 수 있음을 의미합니다.\n🎛️ 주요 옵션 (Major Options) parallel은 매우 방대한 옵션을 제공하지만, 자주 사용되는 핵심 옵션들은 다음과 같습니다.\n--jobs N / -j N: 동시에 실행할 작업(Job)의 개수를 지정합니다. (기본값: CPU 코어 수) +N: 코어 수 + N개 -N: 코어 수 - N개 50%: 코어 수의 50% --load N / -l N: 시스템 부하(Load Average)가 N 이상이면 새 작업을 시작하지 않고 대기합니다. --delay N: 각 작업 시작 사이에 N초의 지연 시간을 둡니다. (API 호출 제한 등에 유용) --timeout N: 작업이 N초 이상 걸리면 강제로 종료합니다. --joblog FILE: 작업 실행 기록(Exit code, 실행 시간 등)을 파일에 저장합니다. --resume: --joblog를 사용하여 중단된 작업 지점부터 다시 시작합니다. --bar: 진행 상황을 프로그레스 바 형태로 보여줍니다. --dry-run: 명령어를 실제로 실행하지 않고, 실행될 명령어 구문을 출력합니다. --keep-order / -k: 작업 완료 순서와 상관없이, 입력 순서대로 출력을 정렬합니다. --pipe: 표준 입력을 덩어리(Block)로 나누어 여러 작업으로 분산 처리합니다. (대용량 파일 처리에 필수) --block N: --pipe 사용 시 나눌 블록의 크기를 지정합니다. (예: 10M, 1G) --tag: 각 출력 라인의 앞에 인자를 태그로 붙여서 어떤 작업의 결과인지 식별하게 해줍니다. --colsep regexp: 입력 라인을 정규표현식 구분자로 나누어 {1}, {2}, … 로 사용할 수 있게 합니다. (예: --colsep ',' - CSV 처리) 🆚 xargs와의 비교 특징 GNU Parallel xargs (-P 옵션) 출력 순서 작업 단위로 그룹화되어 섞이지 않음 라인 단위로 섞일 수 있음 (Interleaved) 사용 편의성 직관적이고 다양한 치환 문자 제공 ({.}, {/} 등) 비교적 제한적 (-I {} 등) 원격 실행 SSH를 통한 손쉬운 분산 처리 지원 (-S) 기본 지원 없음 (별도 구현 필요) 입력 처리 빈 칸, 따옴표 등 특수 문자 처리가 강력함 특수 문자 처리가 까다로울 수 있음 (-0 필요) 성능 Perl 오버헤드가 약간 있음 (작업당 수 ms) C로 구현되어 매우 가벼움 Note: 수백만 개의 아주 짧은 작업(ms 단위)을 실행할 때는 xargs가 더 빠를 수 있지만, 대부분의 실무 작업(초 단위 이상)에서는 parallel의 오버헤드는 무시할 만하며 편의성이 압도적입니다.\n💻 샘플 명령어 10선 1. 기본 사용법: 파일 압축하기 (Basic) 현재 디렉토리의 모든 *.log 파일을 gzip으로 병렬 압축합니다.\nls *.log | parallel gzip 기본 동작: 파이프(|)로 전달된 표준 입력의 각 라인을 인자로 받아 gzip 명령어를 병렬 실행합니다. 별도 옵션이 없으면 CPU 코어 수만큼의 작업이 동시에 실행됩니다. 2. 인자 치환 활용: 이미지 변환 (Image Processing) images 폴더의 모든 .jpg 파일을 .png로 변환하여 converted 폴더에 저장합니다.\nls images/*.jpg | parallel convert {} converted/{/.}.png {}: 입력 파일 전체 경로 (images/photo.jpg) {/.}: 경로와 확장자를 제외한 파일명 (photo) 3. 여러 인자 조합하기 (Cartesian Product) 여러 리스트의 모든 조합을 실행할 때 매우 유용합니다. :::, :::: 구분자를 사용합니다.\nparallel echo \"Color: {1}, Size: {2}\" ::: Red Blue Green ::: S M L ::: : 커맨드 라인 인자로 리스트를 전달할 때 사용합니다. {1}, {2}: 첫 번째, 두 번째 리스트의 인자를 각각 참조합니다. 파일로부터 인자를 읽어올 때는 ::::를 사용합니다.\n# userlist.txt와 hostlist.txt의 모든 조합 실행 parallel echo \"User: {1}, Host: {2}\" :::: userlist.txt :::: hostlist.txt :::: : 파일의 내용을 인자 리스트로 사용할 때 사용합니다. 각 파일의 라인들이 조합됩니다. 4. 원격 서버 분산 처리 (Remote Execution) 로컬의 파일을 여러 서버로 전송하지 않고, 명령어만 분산 실행합니다. (SSH 설정 필요)\n# server1, server2에서 hostname 실행 parallel --nonall -S server1,server2 hostname --nonall: 인자를 전달하지 않고, 모든 서버에서 명령어를 한 번씩만 실행합니다. -S server1,server2: 작업을 실행할 원격 서버 목록을 지정합니다. (콤마로 구분) 5. 대량 파일 다운로드 (Multiple URL Download) urls.txt에 있는 수많은 URL을 4개의 작업으로 병렬 다운로드합니다.\ncat urls.txt | parallel -j 4 wget {} -j 4: 동시에 실행할 작업 수를 4개로 고정합니다. (서버 부하 조절 시 유용) 6. 대규모 문자열 검색 (Large Scale Grep) 수만 개의 파일에서 특정 문자열을 검색할 때 grep 하나로는 느릴 수 있습니다.\nfind . -name \"*.txt\" | parallel grep \"pattern\" {} find와 조합하여 재귀적으로 파일을 찾고, grep을 병렬로 수행하여 검색 속도를 높입니다. 7. 동영상 변환 (Video Transcoding) ffmpeg를 사용하여 여러 동영상 파일을 동시에 변환합니다. CPU를 많이 쓰는 작업에 효과적입니다.\nls *.mp4 | parallel ffmpeg -i {} -c:v libx264 output/{.}.mkv {.}: 입력 파일명에서 확장자를 제거합니다. (video.mp4 -\u003e video) CPU 집약적인 작업에서 parallel의 진가가 발휘됩니다. 8. 데이터베이스 쿼리 병렬 실행 (Database Processing) 여러 테이블이나 데이터베이스에 대해 SQL 쿼리를 병렬로 수행합니다.\ncat tables.txt | parallel \"mysql -e 'CHECK TABLE {};'\" 명령어 전체를 따옴표(\")로 감싸서 복잡한 구문을 하나의 명령어로 전달합니다. {}가 SQL 쿼리 내부의 테이블명으로 치환됩니다. 9. 진행 상황 및 로그 기록 (Progress Bar \u0026 Job Log) 오래 걸리는 작업의 진행 상황을 확인하고, 결과를 로그로 남깁니다.\nseq 100 | parallel --bar --joblog my_jobs.log sleep {} --bar: 터미널 하단에 진행률(Progress Bar)을 표시합니다. --joblog my_jobs.log: 각 작업의 실행 결과(성공/실패, 소요 시간 등)를 로그 파일에 기록합니다. 10. 실패 시 재시도 (Fail/Retry Handling) 네트워크 불안정 등으로 작업이 실패할 경우 자동으로 재시도하게 할 수 있습니다.\n# 실패 시 3번까지 재시도 cat urls.txt | parallel --retries 3 wget {} --retries 3: 작업이 실패(Exit code != 0)할 경우, 최대 3번까지 재시도합니다. 11. CSV/TSV 데이터 처리 (Column Separation) CSV나 TSV 같은 구분자가 있는 데이터를 처리할 때 --colsep을 사용하면 각 컬럼을 개별 인자로 사용할 수 있습니다.\n# data.csv: name,age,email # Alice,30,alice@example.com cat data.csv | parallel --colsep ',' echo \"Name: {1}, Age: {2}, Email: {3}\" --colsep ',': 쉼표(,)를 구분자로 사용하여 입력 라인을 분리합니다. 분리된 각 컬럼은 {1}, {2}, {3}… 순서대로 접근할 수 있습니다. 탭 구분자 파일(TSV)의 경우 --colsep '\\t'를 사용합니다. 📝 결론 GNU Parallel은 단순한 병렬 실행 도구를 넘어, 복잡한 배치 작업을 효율적으로 처리할 수 있게 해주는 “Swiss Army Knife\"와 같습니다. 특히 데이터 처리 파이프라인이나 시스템 관리 스크립트에서 xargs의 한계를 느꼈다면, 꼭 도입해 보시기를 추천합니다.\n","wordCount":"1131","inLanguage":"en","datePublished":"2025-11-23T00:00:00+09:00","dateModified":"2025-11-23T00:00:00+09:00","author":{"@type":"Person","name":"Byung Kyu KIM"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://cdecl.github.io/devops/gnu-parallel-guide/"},"publisher":{"@type":"Organization","name":"cdeclog","logo":{"@type":"ImageObject","url":"https://cdecl.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://cdecl.github.io/ accesskey=h title="cdeclog (Alt + H)">cdeclog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://cdecl.github.io/dev/ title=Dev><span>Dev</span></a></li><li><a href=https://cdecl.github.io/devops/ title=DevOps><span>DevOps</span></a></li><li><a href=https://cdecl.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://cdecl.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://cdecl.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">GNU Parallel: xargs를 넘어선 강력한 병렬 처리</h1><div class=post-meta><span title='2025-11-23 00:00:00 +0900 KST'>November 23, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#-parallel-%ea%b0%9c%ec%9a%94 aria-label="🚀 parallel 개요">🚀 parallel 개요</a></li><li><a href=#-%ec%a3%bc%ec%9a%94-%ea%b8%b0%eb%8a%a5-%eb%b0%8f-%eb%82%b4%eb%b6%80-%ea%b5%ac%ed%98%84 aria-label="⚙️ 주요 기능 및 내부 구현">⚙️ 주요 기능 및 내부 구현</a><ul><li><a href=#1-%ec%b6%9c%eb%a0%a5-%ea%b7%b8%eb%a3%b9%ed%99%94-output-grouping aria-label="1. 출력 그룹화 (Output Grouping)">1. 출력 그룹화 (Output Grouping)</a></li><li><a href=#2-%ec%a7%80%eb%8a%a5%ec%a0%81%ec%9d%b8-%ec%9e%91%ec%97%85-%ec%8a%ac%eb%a1%af-%ea%b4%80%eb%a6%ac aria-label="2. 지능적인 작업 슬롯 관리">2. 지능적인 작업 슬롯 관리</a></li><li><a href=#3-%ea%b0%95%eb%a0%a5%ed%95%9c-%ec%9d%b8%ec%9e%90-%ec%b9%98%ed%99%98-replacement-strings aria-label="3. 강력한 인자 치환 (Replacement Strings)">3. 강력한 인자 치환 (Replacement Strings)</a></li><li><a href=#4-perl-%ea%b8%b0%eb%b0%98-%ea%b5%ac%ed%98%84 aria-label="4. Perl 기반 구현">4. Perl 기반 구현</a></li></ul></li><li><a href=#-%ec%a3%bc%ec%9a%94-%ec%98%b5%ec%85%98-major-options aria-label="🎛️ 주요 옵션 (Major Options)">🎛️ 주요 옵션 (Major Options)</a></li><li><a href=#-xargs%ec%99%80%ec%9d%98-%eb%b9%84%ea%b5%90 aria-label="🆚 xargs와의 비교">🆚 xargs와의 비교</a></li><li><a href=#-%ec%83%98%ed%94%8c-%eb%aa%85%eb%a0%b9%ec%96%b4-10%ec%84%a0 aria-label="💻 샘플 명령어 10선">💻 샘플 명령어 10선</a><ul><li><a href=#1-%ea%b8%b0%eb%b3%b8-%ec%82%ac%ec%9a%a9%eb%b2%95-%ed%8c%8c%ec%9d%bc-%ec%95%95%ec%b6%95%ed%95%98%ea%b8%b0-basic aria-label="1. 기본 사용법: 파일 압축하기 (Basic)">1. 기본 사용법: 파일 압축하기 (Basic)</a></li><li><a href=#2-%ec%9d%b8%ec%9e%90-%ec%b9%98%ed%99%98-%ed%99%9c%ec%9a%a9-%ec%9d%b4%eb%af%b8%ec%a7%80-%eb%b3%80%ed%99%98-image-processing aria-label="2. 인자 치환 활용: 이미지 변환 (Image Processing)">2. 인자 치환 활용: 이미지 변환 (Image Processing)</a></li><li><a href=#3-%ec%97%ac%eb%9f%ac-%ec%9d%b8%ec%9e%90-%ec%a1%b0%ed%95%a9%ed%95%98%ea%b8%b0-cartesian-product aria-label="3. 여러 인자 조합하기 (Cartesian Product)">3. 여러 인자 조합하기 (Cartesian Product)</a></li><li><a href=#4-%ec%9b%90%ea%b2%a9-%ec%84%9c%eb%b2%84-%eb%b6%84%ec%82%b0-%ec%b2%98%eb%a6%ac-remote-execution aria-label="4. 원격 서버 분산 처리 (Remote Execution)">4. 원격 서버 분산 처리 (Remote Execution)</a></li><li><a href=#5-%eb%8c%80%eb%9f%89-%ed%8c%8c%ec%9d%bc-%eb%8b%a4%ec%9a%b4%eb%a1%9c%eb%93%9c-multiple-url-download aria-label="5. 대량 파일 다운로드 (Multiple URL Download)">5. 대량 파일 다운로드 (Multiple URL Download)</a></li><li><a href=#6-%eb%8c%80%ea%b7%9c%eb%aa%a8-%eb%ac%b8%ec%9e%90%ec%97%b4-%ea%b2%80%ec%83%89-large-scale-grep aria-label="6. 대규모 문자열 검색 (Large Scale Grep)">6. 대규모 문자열 검색 (Large Scale Grep)</a></li><li><a href=#7-%eb%8f%99%ec%98%81%ec%83%81-%eb%b3%80%ed%99%98-video-transcoding aria-label="7. 동영상 변환 (Video Transcoding)">7. 동영상 변환 (Video Transcoding)</a></li><li><a href=#8-%eb%8d%b0%ec%9d%b4%ed%84%b0%eb%b2%a0%ec%9d%b4%ec%8a%a4-%ec%bf%bc%eb%a6%ac-%eb%b3%91%eb%a0%ac-%ec%8b%a4%ed%96%89-database-processing aria-label="8. 데이터베이스 쿼리 병렬 실행 (Database Processing)">8. 데이터베이스 쿼리 병렬 실행 (Database Processing)</a></li><li><a href=#9-%ec%a7%84%ed%96%89-%ec%83%81%ed%99%a9-%eb%b0%8f-%eb%a1%9c%ea%b7%b8-%ea%b8%b0%eb%a1%9d-progress-bar--job-log aria-label="9. 진행 상황 및 로그 기록 (Progress Bar & Job Log)">9. 진행 상황 및 로그 기록 (Progress Bar & Job Log)</a></li><li><a href=#10-%ec%8b%a4%ed%8c%a8-%ec%8b%9c-%ec%9e%ac%ec%8b%9c%eb%8f%84-failretry-handling aria-label="10. 실패 시 재시도 (Fail/Retry Handling)">10. 실패 시 재시도 (Fail/Retry Handling)</a></li><li><a href=#11-csvtsv-%eb%8d%b0%ec%9d%b4%ed%84%b0-%ec%b2%98%eb%a6%ac-column-separation aria-label="11. CSV/TSV 데이터 처리 (Column Separation)">11. CSV/TSV 데이터 처리 (Column Separation)</a></li></ul></li><li><a href=#-%ea%b2%b0%eb%a1%a0 aria-label="📝 결론">📝 결론</a></li></ul></div></details></div><div class=post-content><p>리눅스 환경에서 대량의 데이터나 파일을 처리하다 보면, 단일 코어만 사용하는 쉘 스크립트의 성능 한계에 부딪히게 됩니다. <code>xargs</code>를 통해 어느 정도 병렬 처리가 가능하지만, 더 복잡하고 강력한 기능을 제공하는 도구가 바로 <strong>GNU Parallel</strong>입니다.</p><h2 id=-parallel-개요>🚀 parallel 개요<a hidden class=anchor aria-hidden=true href=#-parallel-개요>#</a></h2><p><strong>GNU Parallel</strong>은 로컬 또는 원격 컴퓨터에서 작업을 병렬로 실행하기 위한 쉘 도구입니다. 덴마크의 Ole Tange가 Perl로 개발했으며, 표준 입력(stdin)이나 파일로부터 인자를 받아 명령어를 병렬로 실행합니다.</p><p>가장 큰 특징은 <code>xargs</code>나 <code>find -exec</code>와 같은 기존 도구들의 사용성을 유지하면서도, <strong>출력 제어</strong>, <strong>작업 슬롯 관리</strong>, <strong>원격 실행</strong> 등 고급 기능을 제공한다는 점입니다.</p><h2 id=-주요-기능-및-내부-구현>⚙️ 주요 기능 및 내부 구현<a hidden class=anchor aria-hidden=true href=#-주요-기능-및-내부-구현>#</a></h2><h3 id=1-출력-그룹화-output-grouping>1. 출력 그룹화 (Output Grouping)<a hidden class=anchor aria-hidden=true href=#1-출력-그룹화-output-grouping>#</a></h3><p>병렬 처리 시 가장 큰 골칫거리 중 하나는 여러 프로세스의 출력이 뒤섞이는 것입니다.</p><ul><li><code>xargs -P</code>를 사용하면 여러 줄의 출력이 섞여서 알아보기 힘든 경우가 많습니다.</li><li><strong>Parallel</strong>은 각 작업의 출력을 임시 파일이나 메모리에 버퍼링했다가, 작업이 완료되는 순간 <strong>한꺼번에 출력</strong>합니다. 따라서 출력이 섞이지 않고 깔끔하게 보장됩니다.</li></ul><h3 id=2-지능적인-작업-슬롯-관리>2. 지능적인 작업 슬롯 관리<a hidden class=anchor aria-hidden=true href=#2-지능적인-작업-슬롯-관리>#</a></h3><ul><li><code>parallel</code>은 기본적으로 시스템의 CPU 코어 수를 감지하여 최적의 병렬 작업 수(Job slot)를 결정합니다.</li><li><code>--load</code> 옵션을 통해 시스템 부하(Load Average)에 따라 새로운 작업을 시작할지 대기할지 동적으로 결정할 수도 있습니다.</li></ul><h3 id=3-강력한-인자-치환-replacement-strings>3. 강력한 인자 치환 (Replacement Strings)<a hidden class=anchor aria-hidden=true href=#3-강력한-인자-치환-replacement-strings>#</a></h3><p><code>xargs</code>보다 훨씬 유연한 인자 치환 기능을 제공합니다.</p><ul><li><code>{}</code>: 전체 인자 (기본값)</li><li><code>{.}</code>: 확장자를 제외한 파일명 (<code>file.txt</code> -> <code>file</code>)</li><li><code>{/}</code>: 경로를 제외한 파일명 (Basename, <code>dir/file.txt</code> -> <code>file.txt</code>)</li><li><code>{//}</code>: 파일명을 제외한 경로 (Dirname, <code>dir/file.txt</code> -> <code>dir</code>)</li><li><code>{/.}</code>: 경로와 확장자를 모두 제외한 순수 파일명 (<code>dir/file.txt</code> -> <code>file</code>)</li><li><code>{#}</code>: 작업의 시퀀스 번호 (1부터 시작)</li><li><code>{%}</code>: 작업 슬롯 번호 (1 ~ 병렬 작업 수)</li><li><code>{n}</code>: n번째 입력 소스의 인자 (예: <code>{1}</code>, <code>{2}</code> - <code>:::</code> 또는 <code>::::</code> 사용 시)</li></ul><h3 id=4-perl-기반-구현>4. Perl 기반 구현<a hidden class=anchor aria-hidden=true href=#4-perl-기반-구현>#</a></h3><p>GNU Parallel은 단일 Perl 스크립트로 구현되어 있습니다. 이는 별도의 컴파일 과정 없이 Perl이 설치된 대부분의 유닉스/리눅스 시스템에서 즉시 사용할 수 있음을 의미합니다.</p><h2 id=-주요-옵션-major-options>🎛️ 주요 옵션 (Major Options)<a hidden class=anchor aria-hidden=true href=#-주요-옵션-major-options>#</a></h2><p><code>parallel</code>은 매우 방대한 옵션을 제공하지만, 자주 사용되는 핵심 옵션들은 다음과 같습니다.</p><ul><li><code>--jobs N</code> / <code>-j N</code>: 동시에 실행할 작업(Job)의 개수를 지정합니다. (기본값: CPU 코어 수)<ul><li><code>+N</code>: 코어 수 + N개</li><li><code>-N</code>: 코어 수 - N개</li><li><code>50%</code>: 코어 수의 50%</li></ul></li><li><code>--load N</code> / <code>-l N</code>: 시스템 부하(Load Average)가 N 이상이면 새 작업을 시작하지 않고 대기합니다.</li><li><code>--delay N</code>: 각 작업 시작 사이에 N초의 지연 시간을 둡니다. (API 호출 제한 등에 유용)</li><li><code>--timeout N</code>: 작업이 N초 이상 걸리면 강제로 종료합니다.</li><li><code>--joblog FILE</code>: 작업 실행 기록(Exit code, 실행 시간 등)을 파일에 저장합니다.</li><li><code>--resume</code>: <code>--joblog</code>를 사용하여 중단된 작업 지점부터 다시 시작합니다.</li><li><code>--bar</code>: 진행 상황을 프로그레스 바 형태로 보여줍니다.</li><li><code>--dry-run</code>: 명령어를 실제로 실행하지 않고, 실행될 명령어 구문을 출력합니다.</li><li><code>--keep-order</code> / <code>-k</code>: 작업 완료 순서와 상관없이, 입력 순서대로 출력을 정렬합니다.</li><li><code>--pipe</code>: 표준 입력을 덩어리(Block)로 나누어 여러 작업으로 분산 처리합니다. (대용량 파일 처리에 필수)</li><li><code>--block N</code>: <code>--pipe</code> 사용 시 나눌 블록의 크기를 지정합니다. (예: <code>10M</code>, <code>1G</code>)</li><li><code>--tag</code>: 각 출력 라인의 앞에 인자를 태그로 붙여서 어떤 작업의 결과인지 식별하게 해줍니다.</li><li><code>--colsep regexp</code>: 입력 라인을 정규표현식 구분자로 나누어 <code>{1}</code>, <code>{2}</code>, &mldr; 로 사용할 수 있게 합니다. (예: <code>--colsep ','</code> - CSV 처리)</li></ul><h2 id=-xargs와의-비교>🆚 xargs와의 비교<a hidden class=anchor aria-hidden=true href=#-xargs와의-비교>#</a></h2><table><thead><tr><th style=text-align:left>특징</th><th style=text-align:left>GNU Parallel</th><th style=text-align:left>xargs (-P 옵션)</th></tr></thead><tbody><tr><td style=text-align:left><strong>출력 순서</strong></td><td style=text-align:left>작업 단위로 그룹화되어 섞이지 않음</td><td style=text-align:left>라인 단위로 섞일 수 있음 (Interleaved)</td></tr><tr><td style=text-align:left><strong>사용 편의성</strong></td><td style=text-align:left>직관적이고 다양한 치환 문자 제공 (<code>{.}</code>, <code>{/}</code> 등)</td><td style=text-align:left>비교적 제한적 (<code>-I {}</code> 등)</td></tr><tr><td style=text-align:left><strong>원격 실행</strong></td><td style=text-align:left>SSH를 통한 손쉬운 분산 처리 지원 (<code>-S</code>)</td><td style=text-align:left>기본 지원 없음 (별도 구현 필요)</td></tr><tr><td style=text-align:left><strong>입력 처리</strong></td><td style=text-align:left>빈 칸, 따옴표 등 특수 문자 처리가 강력함</td><td style=text-align:left>특수 문자 처리가 까다로울 수 있음 (<code>-0</code> 필요)</td></tr><tr><td style=text-align:left><strong>성능</strong></td><td style=text-align:left>Perl 오버헤드가 약간 있음 (작업당 수 ms)</td><td style=text-align:left>C로 구현되어 매우 가벼움</td></tr></tbody></table><blockquote><p><strong>Note:</strong> 수백만 개의 아주 짧은 작업(ms 단위)을 실행할 때는 <code>xargs</code>가 더 빠를 수 있지만, 대부분의 실무 작업(초 단위 이상)에서는 <code>parallel</code>의 오버헤드는 무시할 만하며 편의성이 압도적입니다.</p></blockquote><h2 id=-샘플-명령어-10선>💻 샘플 명령어 10선<a hidden class=anchor aria-hidden=true href=#-샘플-명령어-10선>#</a></h2><h3 id=1-기본-사용법-파일-압축하기-basic>1. 기본 사용법: 파일 압축하기 (Basic)<a hidden class=anchor aria-hidden=true href=#1-기본-사용법-파일-압축하기-basic>#</a></h3><p>현재 디렉토리의 모든 <code>*.log</code> 파일을 gzip으로 병렬 압축합니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ls *.log | parallel gzip
</span></span></code></pre></div><ul><li><strong>기본 동작</strong>: 파이프(<code>|</code>)로 전달된 표준 입력의 각 라인을 인자로 받아 <code>gzip</code> 명령어를 병렬 실행합니다.</li><li>별도 옵션이 없으면 CPU 코어 수만큼의 작업이 동시에 실행됩니다.</li></ul><h3 id=2-인자-치환-활용-이미지-변환-image-processing>2. 인자 치환 활용: 이미지 변환 (Image Processing)<a hidden class=anchor aria-hidden=true href=#2-인자-치환-활용-이미지-변환-image-processing>#</a></h3><p><code>images</code> 폴더의 모든 <code>.jpg</code> 파일을 <code>.png</code>로 변환하여 <code>converted</code> 폴더에 저장합니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ls images/*.jpg | parallel convert <span style=color:#ff79c6>{}</span> converted/<span style=color:#ff79c6>{</span>/.<span style=color:#ff79c6>}</span>.png
</span></span></code></pre></div><ul><li><code>{}</code>: 입력 파일 전체 경로 (<code>images/photo.jpg</code>)</li><li><code>{/.}</code>: 경로와 확장자를 제외한 파일명 (<code>photo</code>)</li></ul><h3 id=3-여러-인자-조합하기-cartesian-product>3. 여러 인자 조합하기 (Cartesian Product)<a hidden class=anchor aria-hidden=true href=#3-여러-인자-조합하기-cartesian-product>#</a></h3><p>여러 리스트의 모든 조합을 실행할 때 매우 유용합니다. <code>:::</code>, <code>::::</code> 구분자를 사용합니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>parallel <span style=color:#8be9fd;font-style:italic>echo</span> <span style=color:#f1fa8c>&#34;Color: {1}, Size: {2}&#34;</span> ::: Red Blue Green ::: S M L
</span></span></code></pre></div><ul><li><code>::: </code>: 커맨드 라인 인자로 리스트를 전달할 때 사용합니다.</li><li><code>{1}</code>, <code>{2}</code>: 첫 번째, 두 번째 리스트의 인자를 각각 참조합니다.</li></ul><p>파일로부터 인자를 읽어올 때는 <code>::::</code>를 사용합니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#6272a4># userlist.txt와 hostlist.txt의 모든 조합 실행</span>
</span></span><span style=display:flex><span>parallel <span style=color:#8be9fd;font-style:italic>echo</span> <span style=color:#f1fa8c>&#34;User: {1}, Host: {2}&#34;</span> :::: userlist.txt :::: hostlist.txt
</span></span></code></pre></div><ul><li><code>:::: </code>: 파일의 내용을 인자 리스트로 사용할 때 사용합니다. 각 파일의 라인들이 조합됩니다.</li></ul><h3 id=4-원격-서버-분산-처리-remote-execution>4. 원격 서버 분산 처리 (Remote Execution)<a hidden class=anchor aria-hidden=true href=#4-원격-서버-분산-처리-remote-execution>#</a></h3><p>로컬의 파일을 여러 서버로 전송하지 않고, 명령어만 분산 실행합니다. (SSH 설정 필요)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#6272a4># server1, server2에서 hostname 실행</span>
</span></span><span style=display:flex><span>parallel --nonall -S server1,server2 hostname
</span></span></code></pre></div><ul><li><code>--nonall</code>: 인자를 전달하지 않고, 모든 서버에서 명령어를 한 번씩만 실행합니다.</li><li><code>-S server1,server2</code>: 작업을 실행할 원격 서버 목록을 지정합니다. (콤마로 구분)</li></ul><h3 id=5-대량-파일-다운로드-multiple-url-download>5. 대량 파일 다운로드 (Multiple URL Download)<a hidden class=anchor aria-hidden=true href=#5-대량-파일-다운로드-multiple-url-download>#</a></h3><p><code>urls.txt</code>에 있는 수많은 URL을 4개의 작업으로 병렬 다운로드합니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>cat urls.txt | parallel -j <span style=color:#bd93f9>4</span> wget <span style=color:#ff79c6>{}</span>
</span></span></code></pre></div><ul><li><code>-j 4</code>: 동시에 실행할 작업 수를 4개로 고정합니다. (서버 부하 조절 시 유용)</li></ul><h3 id=6-대규모-문자열-검색-large-scale-grep>6. 대규모 문자열 검색 (Large Scale Grep)<a hidden class=anchor aria-hidden=true href=#6-대규모-문자열-검색-large-scale-grep>#</a></h3><p>수만 개의 파일에서 특정 문자열을 검색할 때 <code>grep</code> 하나로는 느릴 수 있습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>find . -name <span style=color:#f1fa8c>&#34;*.txt&#34;</span> | parallel grep <span style=color:#f1fa8c>&#34;pattern&#34;</span> <span style=color:#ff79c6>{}</span>
</span></span></code></pre></div><ul><li><code>find</code>와 조합하여 재귀적으로 파일을 찾고, <code>grep</code>을 병렬로 수행하여 검색 속도를 높입니다.</li></ul><h3 id=7-동영상-변환-video-transcoding>7. 동영상 변환 (Video Transcoding)<a hidden class=anchor aria-hidden=true href=#7-동영상-변환-video-transcoding>#</a></h3><p><code>ffmpeg</code>를 사용하여 여러 동영상 파일을 동시에 변환합니다. CPU를 많이 쓰는 작업에 효과적입니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ls *.mp4 | parallel ffmpeg -i <span style=color:#ff79c6>{}</span> -c:v libx264 output/<span style=color:#ff79c6>{</span>.<span style=color:#ff79c6>}</span>.mkv
</span></span></code></pre></div><ul><li><code>{.}</code>: 입력 파일명에서 확장자를 제거합니다. (<code>video.mp4</code> -> <code>video</code>)</li><li>CPU 집약적인 작업에서 <code>parallel</code>의 진가가 발휘됩니다.</li></ul><h3 id=8-데이터베이스-쿼리-병렬-실행-database-processing>8. 데이터베이스 쿼리 병렬 실행 (Database Processing)<a hidden class=anchor aria-hidden=true href=#8-데이터베이스-쿼리-병렬-실행-database-processing>#</a></h3><p>여러 테이블이나 데이터베이스에 대해 SQL 쿼리를 병렬로 수행합니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>cat tables.txt | parallel <span style=color:#f1fa8c>&#34;mysql -e &#39;CHECK TABLE {};&#39;&#34;</span>
</span></span></code></pre></div><ul><li>명령어 전체를 따옴표(<code>"</code>)로 감싸서 복잡한 구문을 하나의 명령어로 전달합니다.</li><li><code>{}</code>가 SQL 쿼리 내부의 테이블명으로 치환됩니다.</li></ul><h3 id=9-진행-상황-및-로그-기록-progress-bar--job-log>9. 진행 상황 및 로그 기록 (Progress Bar & Job Log)<a hidden class=anchor aria-hidden=true href=#9-진행-상황-및-로그-기록-progress-bar--job-log>#</a></h3><p>오래 걸리는 작업의 진행 상황을 확인하고, 결과를 로그로 남깁니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>seq <span style=color:#bd93f9>100</span> | parallel --bar --joblog my_jobs.log sleep <span style=color:#ff79c6>{}</span>
</span></span></code></pre></div><ul><li><code>--bar</code>: 터미널 하단에 진행률(Progress Bar)을 표시합니다.</li><li><code>--joblog my_jobs.log</code>: 각 작업의 실행 결과(성공/실패, 소요 시간 등)를 로그 파일에 기록합니다.</li></ul><h3 id=10-실패-시-재시도-failretry-handling>10. 실패 시 재시도 (Fail/Retry Handling)<a hidden class=anchor aria-hidden=true href=#10-실패-시-재시도-failretry-handling>#</a></h3><p>네트워크 불안정 등으로 작업이 실패할 경우 자동으로 재시도하게 할 수 있습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#6272a4># 실패 시 3번까지 재시도</span>
</span></span><span style=display:flex><span>cat urls.txt | parallel --retries <span style=color:#bd93f9>3</span> wget <span style=color:#ff79c6>{}</span>
</span></span></code></pre></div><ul><li><code>--retries 3</code>: 작업이 실패(Exit code != 0)할 경우, 최대 3번까지 재시도합니다.</li></ul><h3 id=11-csvtsv-데이터-처리-column-separation>11. CSV/TSV 데이터 처리 (Column Separation)<a hidden class=anchor aria-hidden=true href=#11-csvtsv-데이터-처리-column-separation>#</a></h3><p>CSV나 TSV 같은 구분자가 있는 데이터를 처리할 때 <code>--colsep</code>을 사용하면 각 컬럼을 개별 인자로 사용할 수 있습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#6272a4># data.csv: name,age,email</span>
</span></span><span style=display:flex><span><span style=color:#6272a4># Alice,30,alice@example.com</span>
</span></span><span style=display:flex><span>cat data.csv | parallel --colsep <span style=color:#f1fa8c>&#39;,&#39;</span> <span style=color:#8be9fd;font-style:italic>echo</span> <span style=color:#f1fa8c>&#34;Name: {1}, Age: {2}, Email: {3}&#34;</span>
</span></span></code></pre></div><ul><li><code>--colsep ','</code>: 쉼표(<code>,</code>)를 구분자로 사용하여 입력 라인을 분리합니다.</li><li>분리된 각 컬럼은 <code>{1}</code>, <code>{2}</code>, <code>{3}</code>&mldr; 순서대로 접근할 수 있습니다. 탭 구분자 파일(TSV)의 경우 <code>--colsep '\t'</code>를 사용합니다.</li></ul><h2 id=-결론>📝 결론<a hidden class=anchor aria-hidden=true href=#-결론>#</a></h2><p>GNU Parallel은 단순한 병렬 실행 도구를 넘어, 복잡한 배치 작업을 효율적으로 처리할 수 있게 해주는 &ldquo;Swiss Army Knife"와 같습니다. 특히 데이터 처리 파이프라인이나 시스템 관리 스크립트에서 <code>xargs</code>의 한계를 느꼈다면, 꼭 도입해 보시기를 추천합니다.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://cdecl.github.io/tags/linux/>Linux</a></li><li><a href=https://cdecl.github.io/tags/shell/>Shell</a></li><li><a href=https://cdecl.github.io/tags/parallel/>Parallel</a></li><li><a href=https://cdecl.github.io/tags/performance/>Performance</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://cdecl.github.io/>cdeclog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>