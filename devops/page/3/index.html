<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Devops | cdeclog</title><meta name=keywords content><meta name=description content="Devops - cdeclog"><meta name=author content="Byung Kyu KIM"><link rel=canonical href=https://cdecl.github.io/devops/><link crossorigin=anonymous href=/assets/css/stylesheet.f939c4ffefb264e6fe85e04352266f79db6bb1303c8e16ae9b6064c1247b5e32.css integrity="sha256-+TnE/++yZOb+heBDUiZvedtrsTA8jhaum2BkwSR7XjI=" rel="preload stylesheet" as=style><link rel=icon href=https://cdecl.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://cdecl.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://cdecl.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://cdecl.github.io/apple-touch-icon.png><link rel=mask-icon href=https://cdecl.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://cdecl.github.io/devops/index.xml title=rss><link rel=alternate hreflang=en href=https://cdecl.github.io/devops/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-VQQHHYPN7K"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VQQHHYPN7K")}</script><meta property="og:url" content="https://cdecl.github.io/devops/"><meta property="og:site_name" content="cdeclog"><meta property="og:title" content="Devops"><meta property="og:description" content="cdecl's Dev.Ops Blog"><meta property="og:locale" content="ko-kr"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Devops"><meta name=twitter:description content="cdecl's Dev.Ops Blog"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Devops","item":"https://cdecl.github.io/devops/"}]}</script></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://cdecl.github.io/ accesskey=h title="cdeclog (Alt + H)">cdeclog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://cdecl.github.io/dev/ title=Dev><span>Dev</span></a></li><li><a href=https://cdecl.github.io/devops/ title=DevOps><span class=active>DevOps</span></a></li><li><a href=https://cdecl.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://cdecl.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://cdecl.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://cdecl.github.io/>Home</a></div><h1>Devops</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>클라우드 2.0의 의의 - AI 시대를 위한 차세대 컴퓨팅</h2></header><div class=entry-content><p>클라우드 컴퓨팅은 IT 인프라의 핵심으로 자리 잡았지만, AI의 급속한 발전과 함께 새로운 진화 단계에 접어들고 있습니다. 클라우드 2.0은 이러한 변화의 중심에 있으며, 기존 클라우드의 한계를 넘어 더 지능적이고 분산된 형태로 발전하고 있습니다. 이 글에서는 온프레미스와 클라우드의 기본 정의 및 비교를 시작으로 클라우드 1.0과 2.0의 정의, 특징, 비교를 살펴보고, AI 시대에서 클라우드 2.0의 의의를 자세히 탐구
온프레미스와 클라우드의 정의 및 비교 온프레미스(On-Premises)와 클라우드 컴퓨팅은 IT 인프라를 구축하는 두 가지 주요 접근 방식입니다. 이 둘의 차이를 이해하는 것은 클라우드 2.0의 맥락을 파악하는 데 필수적입니다.
...</p></div><footer class=entry-footer><span title='2025-10-01 00:00:00 +0900 KST'>October 1, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to 클라우드 2.0의 의의 - AI 시대를 위한 차세대 컴퓨팅" href=https://cdecl.github.io/devops/cloud-2/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>옵시디언 개인 플러그인 15선</h2></header><div class=entry-content><p>Obsidian은 그 자체로도 강력한 노트 앱이지만, 진정한 힘은 커뮤니티 플러그인을 통해 발휘됩니다. 수많은 플러그인 중에서 어떤 것을 선택해야 할지 막막한 분들을 위해, 생산성을 극대화하고 노트 경험을 한 차원 높여줄 필수 플러그인 15가지를 엄선하여 소개합니다.
플러그인 목록 1. Tasks 기능: 옵시디언 내에서 강력한 할 일 관리 시스템을 구축합니다. 마감일, 반복 작업, 우선순위, 필터링 등 체계적인 작업 관리에 필요한 모든 기능을 제공합니다. (자세히 보기) 효과: 별도의 할 일 관리 앱 없이 옵시디언 내에서 모든 작업을 추적하고 관리할 수 있어 지식 관리와 작업 관리를 하나로 통합할 수 있습니다. 2. Advanced Tables 기능: 마크다운 테이블 작성을 획기적으로 개선합니다. Tab 키를 이용한 셀 이동, 자동 서식 지정, 간단한 수식 계산 등 고급 편집 기능을 지원합니다. 효과: 복잡한 표를 만들 때 드는 시간과 노력을 크게 줄여주어, 데이터를 정리하고 비교하는 작업을 훨씬 수월하게 만들어 줍니다. 3. Style Settings 기능: 테마나 다른 플러그인의 디자인을 코딩 없이 세밀하게 조정할 수 있게 해줍니다. 글꼴, 색상, 간격 등 다양한 시각적 요소를 사용자 인터페이스를 통해 직접 변경할 수 있습니다. 효과: 나만의 맞춤형 옵시디언 환경을 손쉽게 구축하여 시각적 만족도와 가독성을 높일 수 있습니다. 4. Git 기능: 옵시디언 볼트를 Git 저장소로 만들어 버전 관리를 자동화합니다. 설정된 시간마다 자동으로 변경 사항을 커밋하고 원격 저장소에 푸시합니다. 효과: 모든 노트의 변경 이력을 안전하게 보관하고, 실수로 내용을 삭제하거나 잘못 수정했을 때 언제든지 이전 상태로 복원할 수 있어 데이터 안정성이 크게 향상됩니다. 5. Iconize 기능: 파일, 폴더, 노트 제목 등 옵시디언의 거의 모든 요소에 아이콘을 추가할 수 있게 해줍니다. 효과: 시각적인 구분을 통해 원하는 정보를 더 빠르고 직관적으로 찾을 수 있도록 도와주며, 파일 탐색기를 더 다채롭게 꾸밀 수 있습니다. 6. Minimal Theme Settings 기능: 인기 테마인 ‘Minimal’의 색상, 글꼴, 레이아웃 등을 세부적으로 설정할 수 있는 전용 패널을 제공합니다. 효과: Minimal 테마 사용자에게 최적화된 맞춤 설정을 제공하여, 개인의 취향에 완벽하게 부합하는 작업 환경을 만들 수 있습니다. 7. File Explorer Note Count 기능: 파일 탐색기의 각 폴더명 옆에 해당 폴더에 포함된 노트의 개수를 표시해 줍니다. 효과: 폴더별 노트 분포를 한눈에 파악할 수 있어, 노트 정리 및 구조화에 유용한 정보를 제공합니다. 8. Excel to Markdown Table 기능: Microsoft Excel, Google Sheets, Apple Numbers 등 스프레드시트 프로그램에서 복사한 데이터를 마크다운 테이블 형식으로 깔끔하게 붙여넣을 수 있습니다. 효과: 외부 표 데이터를 옵시디언으로 가져오는 과정을 극도로 단순화하여, 데이터 이전 작업의 효율을 높입니다. 9. Local REST API 기능: 로컬 REST API를 통해 외부 애플리케이션이나 스크립트가 옵시디언 노트와 상호작용할 수 있도록 해줍니다. 효과: 다른 서비스(예: Alfred, Raycast, 스크립트)와 연동하여 노트 생성, 검색, 수정을 자동화하는 등 무한한 확장 가능성을 열어줍니다. 10. Todoist Sync 기능: Todoist의 작업을 옵시디언 노트 내에서 확인하고 관리할 수 있도록 동기화합니다. 효과: 외부 할 일 관리 서비스와 지식 베이스를 연결하여, 작업의 맥락을 노트와 함께 파악하고 관리할 수 있습니다. 11. Strange New Worlds 기능: 노트 간의 연결(링크)을 시각적으로 탐색할 수 있는 독특한 인터페이스를 제공합니다. 현재 노트와 연결된 다른 노트들을 깊이별로 보여줍니다. (자세히 보기) 효과: 생각의 흐름을 따라가며 예상치 못한 아이디어를 발견하거나, 잊고 있던 노트 간의 관계를 재발견하는 데 도움을 줍니다. 12. Smart Composer 기능: 노트 내용을 컨텍스트로 활용하는 AI 채팅 기능을 제공합니다. 볼트 전체를 대상으로 RAG(Retrieval-Augmented Generation) 검색을 수행하여 글쓰기, 요약, 아이디어 생성을 돕습니다. (자세히 보기) 효과: 내가 작성한 모든 노트를 기반으로 AI와 대화하며 글을 쓸 수 있어, 개인화된 AI 글쓰기 비서처럼 활용할 수 있습니다. 13. Copy Block Link 기능: 마우스 오른쪽 클릭 메뉴에 ‘블록 링크 복사’ 옵션을 추가하여, 특정 문단이나 블록에 대한 링크를 손쉽게 생성할 수 있습니다. 효과: 노트의 특정 부분으로 직접 연결되는 링크를 만들어, 생각을 더 세밀하게 연결하고 참조의 정확성을 높입니다. 14. Ultimate Todoist Sync 기능: Todoist와의 동기화 기능을 더욱 강화한 플러그인입니다. 효과: Todoist를 핵심 작업 관리 도구로 사용하는 유저들에게 더 안정적이고 다양한 동기화 옵션을 제공합니다. 15. Keyshots 기능: VS Code나 JetBrains 등 인기 개발 도구에서 사용되는 단축키를 옵시디언에 추가해 줍니다. 효과: 개발자나 코딩에 익숙한 사용자가 손에 익은 단축키를 그대로 사용하여 텍스트 편집 효율을 극대화할 수 있습니다. 추가 정보: Text Generator 기능: 템플릿 기반으로 텍스트를 생성하는 플러그인입니다. (자세히 보기) 효과: 반복적인 텍스트 입력을 자동화하여 문서 작성 시간을 단축시킵니다. 결론 소개해 드린 플러그인들을 활용하여 자신만의 옵시디언 작업 환경을 구축해 보세요. 각 플러그인의 기능을 조합하면 단순한 노트 앱을 넘어, 강력한 개인 지식 관리 및 생산성 시스템으로 거듭날 것입니다. 지금 바로 커뮤니티 플러그인 탐색을 시작하고 당신의 두 번째 뇌를 업그레이드해 보세요.</p></div><footer class=entry-footer><span title='2025-07-26 00:00:00 +0900 KST'>July 26, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to 옵시디언 개인 플러그인 15선" href=https://cdecl.github.io/devops/obsidian-plugins-guide/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Obsidian Smart Composer - 내 모든 노트를 아는 AI 글쓰기 비서</h2></header><div class=entry-content><p>Obsidian은 강력한 노트 테이킹 앱이지만, 방대하게 쌓인 노트를 활용해 새로운 콘텐츠를 만드는 것은 종종 어려운 과제입니다. Obsidian Smart Composer는 이러한 문제를 해결하기 위해 등장한 플러그인으로, 내 볼트(Vault)의 모든 콘텐츠를 이해하는 개인 AI 비서처럼 작동합니다. 이 글에서는 Smart Composer의 핵심 기능과 함께, 실제 시나리오 기반의 효율적인 활용법을 자세히 알아보겠습니다.
Smart Composer란? Smart Composer(GitHub)는 Obsidian 내에서 AI를 활용하여 글쓰기 효율을 극대화하는 플러그인입니다. 단순히 ChatGPT를 연동하는 것을 넘어, 특정 노트나 폴더, 심지어 웹사이트와 유튜브 영상까지 ‘컨텍스트’로 참조하여 AI와 대화할 수 있습니다. 이를 통해 내 지식 기반 위에서 더욱 정확하고 맥락에 맞는 결과물을 얻을 수 있습니다.
...</p></div><footer class=entry-footer><span title='2025-07-24 00:00:00 +0900 KST'>July 24, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to Obsidian Smart Composer - 내 모든 노트를 아는 AI 글쓰기 비서" href=https://cdecl.github.io/devops/obsidian-smart-composer-guide/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>OpenRouter - 모든 AI 모델을 하나로 연결하는 관문</h2></header><div class=entry-content><p>수많은 대규모 언어 모델(LLM)이 등장하면서, 개발자와 기획자들은 프로젝트에 가장 적합한 모델을 선택하고 연동하는 데 많은 시간과 노력을 쏟고 있습니다. OpenRouter는 이러한 문제를 해결하기 위해 등장한 플랫폼으로, 다양한 AI 모델을 단일 API로 통합하여 제공하는 ‘AI의 관문(Gateway)’ 역할을 합니다. 이 글에서는 OpenRouter의 핵심 기능부터 요금 체계, 활용 방법까지 자세히 알아보겠습니다.
OpenRouter란? OpenRouter(https://openrouter.ai/)는 GPT-4, Claude 3.5 Sonnet, Gemini 2.5 Flash, Llama 3.1 등 여러 제공업체의 최신 AI 모델들을 하나의 표준화된 API 엔드포인트로 묶어 제공하는 서비스입니다. 개발자는 더 이상 각 모델의 API 문서를 따로 학습하거나, 여러 결제 시스템을 관리할 필요 없이 OpenRouter를 통해 원하는 모델을 손쉽게 테스트하고 실제 프로덕션에 적용할 수 있습니다.
...</p></div><footer class=entry-footer><span title='2025-07-23 00:00:00 +0900 KST'>July 23, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to OpenRouter - 모든 AI 모델을 하나로 연결하는 관문" href=https://cdecl.github.io/devops/openrouter-ai-gateway-guide/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Obsidian Tasks 플러그인으로 할 일 관리</h2></header><div class=entry-content><p>Obsidian을 단순한 노트 앱을 넘어 강력한 할 일 관리(To-Do) 도구로 만들어주는 Tasks 플러그인에 대해 알아봅니다. 이 플러그인을 활용하면 여러 노트에 흩어져 있는 할 일들을 한 곳에서 모아보고, 마감일, 우선순위, 반복 설정 등 다양한 기능을 통해 체계적으로 관리할 수 있습니다.
Tasks 플러그인 핵심 기능 Tasks 플러그인은 마크다운 기반의 할 일 관리를 한 단계 업그레이드해줍니다. 기본적인 체크박스 외에 다양한 메타데이터를 추가하여 할 일을 더욱 스마트하게 관리할 수 있습니다.
기본 Task 생성 가장 기본적인 할 일은 마크다운의 체크박스 문법을 사용하여 생성합니다.
...</p></div><footer class=entry-footer><span title='2025-07-22 00:00:00 +0900 KST'>July 22, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to Obsidian Tasks 플러그인으로 할 일 관리" href=https://cdecl.github.io/devops/obsidian-tasks-plugin-guide/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>macOS 데스크탑 화면 이동 순서 관리하기</h2></header><div class=entry-content><p>macOS의 Mission Control과 Spaces 기능을 활용하여 여러 데스크탑 화면을 효율적으로 관리하고 이동하는 방법에 대해 알아봅니다. 자동 재정렬 기능을 끄고 단축키를 활용하면 작업 생산성을 크게 높일 수 있습니다.
Mission Control 및 Spaces 기능 Mission Control: Mac에서 열려있는 모든 윈도우와 Spaces를 한눈에 보여주는 기능입니다. 여러 데스크탑 화면(Spaces)을 만들어 사용하거나, 전체 화면으로 실행 중인 앱 윈도우를 나열하는 데 사용됩니다. Spaces: macOS에서 제공하는 가상 데스크탑 기능으로, 여러 작업 공간을 분리하여 사용할 수 있습니다. Spaces를 통해 여러 개의 데스크탑을 만들고 각 데스크탑에 작업 윈도우를 배치하여 작업 효율성을 높일 수 있습니다. 최대 16개의 Spaces를 만들 수 있습니다. Spaces 순서 변경 및 고정 Spaces 자동 재정렬 끄기 macOS에서는 Spaces를 최근 사용 내역에 따라 자동으로 재정렬하는 기능이 기본적으로 활성화되어 있습니다. 이 기능을 끄면 데스크탑 순서가 사용자가 설정한 순서대로 고정됩니다. 설정 방법: 시스템 설정 열기. 데스크탑 및 Dock 또는 Mission Control 메뉴를 찾습니다. Mission Control 설정에서 “Spaces를 최근 사용 내역에 따라 자동으로 재정렬” 옵션을 끕니다. Spaces 순서 고정의 장점 데스크탑 순서가 바뀌지 않아 작업 공간을 예측 가능하게 관리할 수 있습니다. Control + 숫자 단축키를 사용하여 원하는 데스크탑으로 빠르게 이동할 수 있습니다. Spaces 이동 방법 트랙패드 제스처 세 손가락 또는 네 손가락을 사용하여 트랙패드를 좌우로 쓸어 넘겨 Spaces를 이동할 수 있습니다. 설정 확인: 시스템 환경설정 > 트랙패드에서 “Mission Control” 제스처가 활성화되어 있는지 확인합니다. 키보드 단축키 Control + ← 또는 Control + → 키를 사용하여 이전 또는 다음 Spaces로 이동할 수 있습니다. Control + 숫자 (1, 2, 3...) 키를 사용하여 특정 Spaces로 바로 이동할 수 있습니다. 단축키 활성화: 시스템 환경설정 > 키보드 > 단축키 > Mission Control에서 “데스크탑 X로 전환” 옵션을 활성화해야 합니다. Mission Control 사용 Mission Control을 열어(F3 키 또는 Control + ↑) 화면 상단의 Spaces 막대에서 원하는 Spaces를 클릭하여 이동할 수 있습니다. 추가 팁 Mission Control 설정 시스템 설정에서 Mission Control 관련 설정을 변경하여 작업 스타일에 맞게 조정할 수 있습니다. 예를 들어, “응용 프로그램으로 전환할 때, 응용 프로그램에 대해 윈도우가 열려 있는 Space로 전환” 옵션을 활성화하면 앱 전환 시 해당 앱의 윈도우가 열려 있는 Space로 자동으로 이동합니다. 핫 코너 활용 핫 코너를 설정하여 마우스 커서를 화면 모서리로 이동하면 Mission Control이 활성화되도록 할 수 있습니다. 시스템 설정 > 데스크탑 및 Dock > 핫 코너에서 설정할 수 있습니다. 윈도우 이동 Mission Control을 사용하여 윈도우를 다른 데스크탑으로 드래그 앤 드롭할 수 있습니다. 창 상단을 클릭한 상태에서 화면 위쪽 모서리로 마우스 커서를 이동하면 Spaces 막대가 나타나고, 원하는 데스크탑으로 창을 이동시킬 수 있습니다. Dock 활용 Dock에서 앱 아이콘을 Control-클릭하여 옵션 메뉴를 열고, “Option > Dock에 유지"를 선택하면 해당 앱이 Dock에 항상 표시되도록 할 수 있습니다. 이 정보가 macOS 데스크탑 화면 이동 순서를 관리하는 데 도움이 되기를 바랍니다.</p></div><footer class=entry-footer><span title='2025-07-21 00:00:00 +0900 KST'>July 21, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to macOS 데스크탑 화면 이동 순서 관리하기" href=https://cdecl.github.io/devops/macos-desktop-screen-switching-order/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>macOS에서 키를 길게 눌렀을 때 동작 변경하기</h2></header><div class=entry-content><p>macOS에서 키를 길게 눌렀을 때 기본적으로 악센트 메뉴(예: “a"를 길게 누르면 à, á, â 등이 표시)가 나타나지만, 이를 키 반복(Windows와 유사한 문자 반복 입력)으로 변경할 수 있습니다.
개요 이 문서에서는 터미널 명령어(defaults)를 사용해 ApplePressAndHoldEnabled 설정을 변경하는 방법과 관련된 동작 방식, 설정 확인, 삭제, 주의사항을 설명합니다.
ApplePressAndHoldEnabled 설정은 키를 길게 눌렀을 때의 동작을 제어합니다:
true (기본값): 키를 길게 누르면 악센트 메뉴가 표시됩니다. 예를 들어, “e” 키를 길게 누르면 é, è, ê 등의 선택 메뉴가 나타납니다. false: 키를 길게 누르면 해당 문자가 반복적으로 입력됩니다(예: “eeeee”). 이는 Windows의 키보드 동작과 유사합니다. 이 설정은 시스템 전반 또는 특정 응용 프로그램에 적용할 수 있습니다.
...</p></div><footer class=entry-footer><span title='2025-07-20 00:00:00 +0900 KST'>July 20, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to macOS에서 키를 길게 눌렀을 때 동작 변경하기" href=https://cdecl.github.io/devops/macos-key-repeat-settings/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Obsidian - Smart Connections 플러그인</h2></header><div class=entry-content><p>이 글에서는 Obsidian Smart Connections 플러그인의 개념부터 기능, 설정 방법, 주요 기능과 예제, 그리고 비슷한 플러그인까지 상세히 알아보겠습니다.
1. Obsidian Smart Connections 플러그인이란? Smart Connections는 Obsidian에서 AI 임베딩을 활용해 노트 간의 의미적 연결을 찾아주는 강력한 플러그인입니다. 사용자의 노트를 분석하여 관련된 콘텐츠를 실시간으로 추천하거나, 노트를 기반으로 대화형 AI와 상호작용할 수 있게 합니다. 블로그 작성, 연구, 지식 관리 등에서 생산성을 높여주며, 특히 대규모 노트 저장소에서 유용합니다.
주요 특징:
의미적 검색: 키워드가 아닌 노트의 의미를 기반으로 관련 노트를 찾아줍니다. 로컬 및 클라우드 AI 지원: Ollama, LM Studio 같은 로컬 모델과 OpenAI, Gemini, Claude 등 100개 이상의 API를 지원합니다. Smart Chat: 노트를 기반으로 AI와 대화하며 질문에 답변하거나 콘텐츠를 생성합니다. 컨텍스트 인식: 현재 노트나 선택한 텍스트를 활용해 관련 콘텐츠를 제안합니다. 오프라인 지원: 로컬 임베딩 모델을 사용해 데이터 프라이버시를 보장합니다. 2. 설치 및 설정 Smart Connections 플러그인은 Obsidian의 커뮤니티 플러그인 마켓에서 설치할 수 있습니다. 아래는 기본 설치 및 설정 방법입니다.
...</p></div><footer class=entry-footer><span title='2025-07-20 00:00:00 +0900 KST'>July 20, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to Obsidian - Smart Connections 플러그인" href=https://cdecl.github.io/devops/obsidian-smart-connections-plugin/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Obsidian Text Generator 플러그인 가이드 (selected_text, context)</h2></header><div class=entry-content><p>이 글에서는 Obsidian Text Generator 플러그인의 개념부터 기능, 설정 방법, 명령어, 예약어 사용법, 그리고 유용한 추가 기능까지 상세히 알아보겠습니다.
1. Obsidian Text Generator 플러그인이란? Obsidian Text Generator 플러그인은 Obsidian에서 AI를 활용해 텍스트를 생성하는 강력한 도구입니다. 노트 작성, 아이디어 생성, 콘텐츠 요약 등 다양한 작업을 자동화하여 생산성을 높여줍니다. 이 플러그인은 사용자가 선택한 텍스트나 노트의 컨텍스트를 기반으로 AI 모델을 통해 문장을 완성하거나 새로운 콘텐츠를 생성합니다.
주요 특징:
다양한 AI 지원: OpenAI(GPT-3, GPT-4), Google Gemini, Anthropic Claude, 그리고 LM Studio와 같은 로컬 모델을 지원합니다. 템플릿 엔진: 반복 작업을 간소화하는 사용자 정의 템플릿을 제공합니다. 컨텍스트 인식: 현재 노트, 선택한 텍스트, 링크된 노트를 활용해 문맥에 맞는 텍스트를 생성합니다. 커뮤니티 템플릿: 다른 사용자의 템플릿을 공유하거나 가져와 다양한 활용 사례를 탐색할 수 있습니다. 유연한 설정: Frontmatter를 통해 AI 모델, 토큰 수, 온도 등을 세부적으로 조정 가능합니다. 2. 설치 및 Gemini 기반 설정 Text Generator 플러그인은 Obsidian의 커뮤니티 플러그인 마켓에서 설치할 수 있습니다. Google Gemini를 사용한 설정 예시는 다음과 같습니다.
...</p></div><footer class=entry-footer><span title='2025-07-17 00:00:00 +0900 KST'>July 17, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to Obsidian Text Generator 플러그인 가이드 (selected_text, context)" href=https://cdecl.github.io/devops/obsidian-text-generator-plugin/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>웹에서 만나는 터미널, ttyd 가이드</h2></header><div class=entry-content><p>이 글에서는 ttyd의 개념부터 설치, 활용법, 그리고 보안 강화 방안까지 상세하게 알아보겠습니다.
1. ttyd란 무엇인가? 개발자, 시스템 관리자, 혹은 단순히 터미널 작업을 즐기는 분이라면 원격으로 shell에 접속해야 하는 경우가 많습니다. SSH가 가장 일반적인 해결책이지만, 웹 브라우저만 있다면 어디서든 터미널에 접속할 수 있는 더 가벼운 방법이 있습니다. 바로 ttyd입니다.
ttyd는 ‘TTY over Web’의 약자로, 명령줄 도구를 웹 애플리케이션으로 변환해 주는 간단하고 효율적인 C언어 기반 프로그램입니다. 내부적으로는 Libwebsockets를 사용하여 웹소켓 통신을 처리하고, 프론트엔드에서는 xterm.js를 통해 완벽한 기능의 터미널을 웹 브라우저에 구현합니다.
...</p></div><footer class=entry-footer><span title='2025-07-13 00:00:00 +0900 KST'>July 13, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to 웹에서 만나는 터미널, ttyd 가이드" href=https://cdecl.github.io/devops/ttyd/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://cdecl.github.io/devops/page/2/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://cdecl.github.io/devops/page/4/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2026 <a href=https://cdecl.github.io/>cdeclog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>