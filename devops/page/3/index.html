<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Devops | cdeclog</title><meta name=keywords content><meta name=description content="Devops - cdeclog"><meta name=author content="Byung Kyu KIM"><link rel=canonical href=https://cdecl.github.io/devops/><link crossorigin=anonymous href=/assets/css/stylesheet.f939c4ffefb264e6fe85e04352266f79db6bb1303c8e16ae9b6064c1247b5e32.css integrity="sha256-+TnE/++yZOb+heBDUiZvedtrsTA8jhaum2BkwSR7XjI=" rel="preload stylesheet" as=style><link rel=icon href=https://cdecl.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://cdecl.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://cdecl.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://cdecl.github.io/apple-touch-icon.png><link rel=mask-icon href=https://cdecl.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://cdecl.github.io/devops/index.xml title=rss><link rel=alternate hreflang=en href=https://cdecl.github.io/devops/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-VQQHHYPN7K"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VQQHHYPN7K")}</script><meta property="og:url" content="https://cdecl.github.io/devops/"><meta property="og:site_name" content="cdeclog"><meta property="og:title" content="Devops"><meta property="og:description" content="cdecl's Dev.Ops Blog"><meta property="og:locale" content="ko-kr"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Devops"><meta name=twitter:description content="cdecl's Dev.Ops Blog"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Devops","item":"https://cdecl.github.io/devops/"}]}</script></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://cdecl.github.io/ accesskey=h title="cdeclog (Alt + H)">cdeclog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://cdecl.github.io/dev/ title=Dev><span>Dev</span></a></li><li><a href=https://cdecl.github.io/devops/ title=DevOps><span class=active>DevOps</span></a></li><li><a href=https://cdecl.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://cdecl.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://cdecl.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://cdecl.github.io/>Home</a></div><h1>Devops</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Obsidian - Smart Connections 플러그인</h2></header><div class=entry-content><p>이 글에서는 Obsidian Smart Connections 플러그인의 개념부터 기능, 설정 방법, 주요 기능과 예제, 그리고 비슷한 플러그인까지 상세히 알아보겠습니다.
1. Obsidian Smart Connections 플러그인이란? Smart Connections는 Obsidian에서 AI 임베딩을 활용해 노트 간의 의미적 연결을 찾아주는 강력한 플러그인입니다. 사용자의 노트를 분석하여 관련된 콘텐츠를 실시간으로 추천하거나, 노트를 기반으로 대화형 AI와 상호작용할 수 있게 합니다. 블로그 작성, 연구, 지식 관리 등에서 생산성을 높여주며, 특히 대규모 노트 저장소에서 유용합니다.
주요 특징:
의미적 검색: 키워드가 아닌 노트의 의미를 기반으로 관련 노트를 찾아줍니다. 로컬 및 클라우드 AI 지원: Ollama, LM Studio 같은 로컬 모델과 OpenAI, Gemini, Claude 등 100개 이상의 API를 지원합니다. Smart Chat: 노트를 기반으로 AI와 대화하며 질문에 답변하거나 콘텐츠를 생성합니다. 컨텍스트 인식: 현재 노트나 선택한 텍스트를 활용해 관련 콘텐츠를 제안합니다. 오프라인 지원: 로컬 임베딩 모델을 사용해 데이터 프라이버시를 보장합니다. 2. 설치 및 설정 Smart Connections 플러그인은 Obsidian의 커뮤니티 플러그인 마켓에서 설치할 수 있습니다. 아래는 기본 설치 및 설정 방법입니다.
...</p></div><footer class=entry-footer><span title='2025-07-20 00:00:00 +0900 KST'>July 20, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to Obsidian - Smart Connections 플러그인" href=https://cdecl.github.io/devops/obsidian-smart-connections-plugin/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Obsidian Text Generator 플러그인 가이드 (selected_text, context)</h2></header><div class=entry-content><p>이 글에서는 Obsidian Text Generator 플러그인의 개념부터 기능, 설정 방법, 명령어, 예약어 사용법, 그리고 유용한 추가 기능까지 상세히 알아보겠습니다.
1. Obsidian Text Generator 플러그인이란? Obsidian Text Generator 플러그인은 Obsidian에서 AI를 활용해 텍스트를 생성하는 강력한 도구입니다. 노트 작성, 아이디어 생성, 콘텐츠 요약 등 다양한 작업을 자동화하여 생산성을 높여줍니다. 이 플러그인은 사용자가 선택한 텍스트나 노트의 컨텍스트를 기반으로 AI 모델을 통해 문장을 완성하거나 새로운 콘텐츠를 생성합니다.
주요 특징:
다양한 AI 지원: OpenAI(GPT-3, GPT-4), Google Gemini, Anthropic Claude, 그리고 LM Studio와 같은 로컬 모델을 지원합니다. 템플릿 엔진: 반복 작업을 간소화하는 사용자 정의 템플릿을 제공합니다. 컨텍스트 인식: 현재 노트, 선택한 텍스트, 링크된 노트를 활용해 문맥에 맞는 텍스트를 생성합니다. 커뮤니티 템플릿: 다른 사용자의 템플릿을 공유하거나 가져와 다양한 활용 사례를 탐색할 수 있습니다. 유연한 설정: Frontmatter를 통해 AI 모델, 토큰 수, 온도 등을 세부적으로 조정 가능합니다. 2. 설치 및 Gemini 기반 설정 Text Generator 플러그인은 Obsidian의 커뮤니티 플러그인 마켓에서 설치할 수 있습니다. Google Gemini를 사용한 설정 예시는 다음과 같습니다.
...</p></div><footer class=entry-footer><span title='2025-07-17 00:00:00 +0900 KST'>July 17, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to Obsidian Text Generator 플러그인 가이드 (selected_text, context)" href=https://cdecl.github.io/devops/obsidian-text-generator-plugin/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>웹에서 만나는 터미널, ttyd 가이드</h2></header><div class=entry-content><p>이 글에서는 ttyd의 개념부터 설치, 활용법, 그리고 보안 강화 방안까지 상세하게 알아보겠습니다.
1. ttyd란 무엇인가? 개발자, 시스템 관리자, 혹은 단순히 터미널 작업을 즐기는 분이라면 원격으로 shell에 접속해야 하는 경우가 많습니다. SSH가 가장 일반적인 해결책이지만, 웹 브라우저만 있다면 어디서든 터미널에 접속할 수 있는 더 가벼운 방법이 있습니다. 바로 ttyd입니다.
ttyd는 ‘TTY over Web’의 약자로, 명령줄 도구를 웹 애플리케이션으로 변환해 주는 간단하고 효율적인 C언어 기반 프로그램입니다. 내부적으로는 Libwebsockets를 사용하여 웹소켓 통신을 처리하고, 프론트엔드에서는 xterm.js를 통해 완벽한 기능의 터미널을 웹 브라우저에 구현합니다.
...</p></div><footer class=entry-footer><span title='2025-07-13 00:00:00 +0900 KST'>July 13, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to 웹에서 만나는 터미널, ttyd 가이드" href=https://cdecl.github.io/devops/ttyd/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>구글의 AI 코딩 어시스턴트, Gemini CLI 사용 가이드</h2></header><div class=entry-content><p>Gemini CLI의 핵심 개념, 주요 기능, 설치 및 구성 방법, 그리고 다른 AI 코딩 도우미와의 비교를 통해 Gemini CLI를 효과적으로 활용하는 방법을 알아봅니다.
Gemini CLI란? Gemini CLI는 구글에서 개발한 대화형 AI 코딩 어시스턴트로, 터미널 환경에서 직접 작동합니다. 개발자는 자연어 명령을 통해 복잡한 개발 작업을 Gemini에게 위임할 수 있습니다. 파일 시스템 조작, 코드 리팩토링, 셸 명령어 실행, Git 버전 관리 등 다양한 작업을 자동화하여 개발 생산성을 크게 향상시킵니다. 이 포스트에서는 Gemini CLI의 핵심 철학, 주요 기능, 설치 및 구성, 그리고 GitHub Copilot CLI와의 비교를 통해 그 차이점을 명확히 설명합니다.
...</p></div><footer class=entry-footer><span title='2025-07-08 00:00:00 +0900 KST'>July 8, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to 구글의 AI 코딩 어시스턴트, Gemini CLI 사용 가이드" href=https://cdecl.github.io/devops/gemini_cli/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>오픈소스 AI 코딩 어시스턴트, Cline 사용 가이드</h2></header><div class=entry-content><p>Cline의 핵심 개념, 역할, 지원 AI 모델, 설치 및 구성 방법, 그리고 유용한 기능들을 상세히 소개합니다.
Cline이란? Cline은 Visual Studio Code(VS Code)와 통합된 오픈소스 AI 코딩 어시스턴트로, 복잡한 소프트웨어 개발 작업을 자동화하고 생산성을 극대화합니다. Claude 3.7 Sonnet, DeepSeek, Google Gemini 등 다양한 대형 언어 모델(LLM)을 활용하여 코드 작성, 디버깅, 리팩토링, 터미널 명령 실행 등을 지원합니다. 이 포스트에서는 Cline의 정의, 역할, 지원 AI 모델, 설치 및 구성 방법, 그리고 개발자를 위한 유용한 기능들을 자세히 다룹니다.
...</p></div><footer class=entry-footer><span title='2025-07-07 00:00:00 +0900 KST'>July 7, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to 오픈소스 AI 코딩 어시스턴트, Cline 사용 가이드" href=https://cdecl.github.io/devops/cline_usage_guide/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Tailscale 가이드 - 안전한 매쉬 VPN 활용법</h2></header><div class=entry-content><p>Tailscale의 핵심 개념, VPN 정의, 동작 방식, 설치 및 구성 방법, 엔드포인트 관리, 포트 제어, 다른 단말 접속, 그리고 보안 설정 방법
Tailscale이란? Tailscale은 WireGuard 프로토콜을 기반으로 한 현대적인 매쉬 VPN 솔루션으로, 복잡한 네트워크 설정 없이 장치 간 안전하고 빠른 연결을 제공합니다. 개인, 팀, 또는 기업의 장치를 연결하여 로컬 네트워크, 원격 서버, 모바일 장치를 쉽게 관리할 수 있습니다. 이 포스트에서는 Tailscale의 핵심 개념, VPN 정의와 매쉬 VPN 동작 방식, 설치 및 구성, 엔드포인트 확인, 포트 제어, 다른 단말 접속, 그리고 보안 설정을 자세히 다룹니다.
...</p></div><footer class=entry-footer><span title='2025-07-05 00:00:00 +0900 KST'>July 5, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to Tailscale 가이드 - 안전한 매쉬 VPN 활용법" href=https://cdecl.github.io/devops/tailscale-guide/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Obsidian 101 - 강력한 노트 관리 도구 활용법</h2></header><div class=entry-content><p>Obsidian의 주요 기능과 설정, 테마와 외관, 그리고 필수 커뮤니티 플러그인을 활용한 생산성 향상 방법
Obsidian이란? Obsidian은 마크다운 기반의 강력한 노트 관리 및 지식 관리 도구로, 로컬 파일을 활용해 개인 지식 베이스를 구축하는 데 최적화되어 있습니다. 링크를 통한 노트 간 연결, 그래프 뷰, 플러그인 생태계를 통해 유연한 워크플로우를 제공합니다. 이번 포스트에서는 Obsidian의 주요 기능, 설정, 테마와 외관, 그리고 생산성을 극대화할 수 있는 커뮤니티 플러그인(예: Tasks, Advanced Tables, Git 등)을 자세히 다룹니다.
...</p></div><footer class=entry-footer><span title='2025-07-04 00:00:00 +0900 KST'>July 4, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to Obsidian 101 - 강력한 노트 관리 도구 활용법" href=https://cdecl.github.io/devops/obsidian-101/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>정규식의 멀티라인 expressions 활용</h2></header><div class=entry-content><p>멀티라인 표현식의 활용법, Dotall (Single Line) 모드, Multi Line 모드, Non-Dotall 모드의 차이점, 여러 줄을 처리하는 방법
정규식의 멀티라인 표현식이란? 정규식(Regular Expression, Regex)은 텍스트 패턴을 검색하거나 조작할 때 강력한 도구로 사용됩니다. 특히 멀티라인 표현식은 여러 줄에 걸친 텍스트를 처리할 때 유용하며, 줄바꿈(\n)을 포함한 패턴 매칭을 가능하게 합니다. 이번 포스트에서는 멀티라인 표현식의 활용법, Dotall (Single Line) 모드, Multi Line 모드, Non-Dotall 모드의 차이점, 여러 줄을 처리하는 방법, 그리고 특정 패턴(예: start로 시작하고 end로 끝나는 패턴) 매칭 방법 등을 다룹니다. 또한, /s, /S, /w, /W, .|\n의 모드별 동작 차이를 설명합니다.
...</p></div><footer class=entry-footer><span title='2025-07-01 00:00:00 +0900 KST'>July 1, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to 정규식의 멀티라인 expressions 활용" href=https://cdecl.github.io/devops/regex-multiline/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>모던 쉘 명령어로 터미널 생산성 높이기</h2></header><div class=entry-content><p>모던 쉘 명령어: 전통적인 도구를 대체하는 강력한 대안
터미널은 개발자와 시스템 관리자의 핵심 도구입니다. 하지만 전통적인 쉘 명령어(grep, sed, find, cat, watch, top, du)는 속도, 가독성, 사용 편의성 면에서 한계가 있습니다. 2025년 기준, 이러한 명령어들을 대체하는 모던 대안들이 주목받고 있습니다. 이 포스트에서는 ripgrep, sd, fd, bat, hwatch, htop, dust를 전통 명령어와 비교하며 특징과 사용법을 소개합니다.
모던 쉘 명령어 요약 전통 명령어 모던 대안 주요 특징 설치 명령어 (Ubuntu/Debian) grep ripgrep (rg) 고속 검색, .gitignore 통합, 컬러 출력 sudo apt-get install ripgrep sed sd 간단한 치환 문법, 빠른 처리 sudo apt-get install sd find fd 직관적 검색, .gitignore 지원 sudo apt-get install fd-find cat bat 구문 강조, Git 통합, 페이징 sudo apt-get install bat watch hwatch 변경 강조, 로그 저장 sudo apt-get install hwatch top htop 컬러 UI, 프로세스 트리 뷰 sudo apt-get install htop du dust 트리 구조, 직관적 시각화 sudo apt-get install dust 왜 모던 쉘 명령어가 필요한가? 모던 쉘 명령어는 Rust, Go 같은 현대 언어로 작성되어 속도와 효율성이 뛰어나며, 사용자 친화적인 인터페이스를 제공합니다. 주요 장점은 다음과 같습니다:
...</p></div><footer class=entry-footer><span title='2025-05-25 00:00:00 +0900 KST'>May 25, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to 모던 쉘 명령어로 터미널 생산성 높이기" href=https://cdecl.github.io/devops/moden-shell-command/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>정규 표현식(BRE, ERE, PCRE) 기능 비교 및 명령어 지원 가이드</h2></header><div class=entry-content><p>정규 표현식(BRE, ERE, PCRE) 기능 비교 및 명령어 지원 가이드
1. 정규 표현식이란? 정규 표현식(Regular Expression, Regex)은 텍스트 패턴을 검색, 치환, 검증하는 데 사용되는 강력한 도구입니다.
POSIX 기반의 BRE(Basic Regular Expressions), ERE(Extended Regular Expressions), 그리고 Perl 호환 PCRE(Perl-Compatible Regular Expressions)는 각각 다른 기능과 지원 범위를 제공합니다.
이 글에서는 각 정규 표현식 유형의 특징과 grep, egrep, sed, ripgrep, awk 같은 도구에서의 지원 옵션을 정리합니다.
2. 정규 표현식 유형별 기능 기능 BRE (Basic) ERE (Extended) PCRE (Perl) 기본 메타문자 ., *, ^, $, [], [^ ] BRE + +, ?, ` , {n,m}` 그룹화 \(\) () (), 이름 붙은 그룹 지원 백레퍼런스 \1, \2 \1, \2 \1, \2, 이름 참조 가능 반복 *, \{n,m\} *, +, ?, {n,m} *, +, ?, {n,m}, *?, +? 고급 기능 없음 없음 전방 탐색((?=...)), 후방 탐색((?&lt;=...)) 예시 a\(b*\)c → abbbc `a(b+ c)d→abbd, acd` 제한점 +, ?, |는 이스케이프 필요 비탐욕적 매칭, 전방/후방 탐색 미지원 POSIX 도구에서 제한적 지원 2.1 기본 정규 표현식 (BRE) 설명: POSIX 표준의 기본 정규 표현식, 가장 제한적. 주요 기능: 메타문자(., *, ^, $, []), 그룹화(\(\)), 백레퍼런스(\1, \2). 제한점: +, ?, |는 이스케이프(\+, \?, \|) 필요. 2.2 확장 정규 표현식 (ERE) 설명: POSIX 확장 표준, BRE보다 간결하고 표현력 높음. 주요 기능: 추가 메타문자(+, ?, |, {n,m}), 그룹화(()). 제한점: 비탐욕적 매칭이나 전방/후방 탐색 미지원. 2.3 Perl 호환 정규 표현식 (PCRE) 설명: Perl 기반, 가장 강력한 정규 표현식. 주요 기능: 비탐욕적 매칭(*?, +?), 전방/후방 탐색, 유니코드 지원. 제한점: POSIX 도구에서 제한적 지원. 3. 명령어별 정규 표현식 지원 옵션 명령어 BRE ERE PCRE grep 기본 (옵션 없음) -E -P (GNU grep만) egrep - 기본 (옵션 없음) - sed 기본 (옵션 없음) -r (GNU) / -E (BSD) - ripgrep - 기본 (옵션 없음) 기본 (옵션 없음) awk 기본 (옵션 없음) - - (gawk는 제한적 PCRE 지원) 4. 모범 사례 POSIX 우선: 이식성을 위해 BRE/ERE 사용.
...</p></div><footer class=entry-footer><span title='2025-05-20 00:00:00 +0900 KST'>May 20, 2025</span>&nbsp;·&nbsp;<span>Byung Kyu KIM</span></footer><a class=entry-link aria-label="post link to 정규 표현식(BRE, ERE, PCRE) 기능 비교 및 명령어 지원 가이드" href=https://cdecl.github.io/devops/regexp-bre-ere-pcre/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://cdecl.github.io/devops/page/2/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://cdecl.github.io/devops/page/4/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2026 <a href=https://cdecl.github.io/>cdeclog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>